[
{
	"uri": "/kr/ros_basic_noetic/",
	"title": "ROS Basics",
	"tags": [],
	"description": "",
	"content": "\nLecture1. Lecture1 - Introduction to ROS Lecture2. Dev Env Setup Lecture3. Core of ROS Lecture4. ROS Launch, RViz Lecture5. First Programming, ROS Topic Lecture6. ROS Service, Parameter Lecture7. Rqt Tools and rosbag, ROS Time Lecture8. Deal with Open Source Projects, Custom Interfaces Lecture9. ROS TF and Examples Lecture10. TF2 Examples, Outro "
},
{
	"uri": "/kr/ros2_basic_foxy/",
	"title": "ROS 2 Basics",
	"tags": [],
	"description": "",
	"content": "\nLecture1. Lecture1 - Introduction to ROS 2 Lecture2. ROS 2 Node, Package Lecture3. ROS 2 NODE PROGRAMMING, ROS 2 PARAMETER Lecture4. ROS 2 NODE C++ PROGRAMMING Lecture5. ROS 2 TOPIC AND EXAMPLES Lecture6. ROS 2 SERVICE AND EXAMPLES Lecture7. USEFUL ROS 2 EXAMPLE, NAVIGATION2 Lecture8. ROS 2 ACTION AND EXAMPLES Lecture9. About Real Robot, Outro "
},
{
	"uri": "/kr/",
	"title": "2023 Road Balance ROS Lecture Note",
	"tags": [],
	"description": "",
	"content": "2023 ROAD BALANCE ROS LECTURE NOTE 본 사이트는 2023년 Road Balance의 ROS/ROS 2 강의에 사용되는 강의 노트입니다.\nROS Noetic Lecture Lecture1. Lecture1 - Introduction to ROS Lecture2. Dev Env Setup Lecture3. Core of ROS Lecture4. ROS Launch, RViz Lecture5. First Programming, ROS Topic Lecture6. ROS Service, Parameter Lecture7. Rqt Tools and rosbag, ROS Time Lecture8. Deal with Open Source Projects, Custom Interfaces Lecture9. ROS TF and Examples Lecture10. TF2 Examples, Outro ROS 2 Foxy Lecture Lecture1. Lecture1 - Introduction to ROS 2 Lecture2. ROS 2 Node, Package Lecture3. ROS 2 Node Programming, ROS 2 Parameter Lecture4. ROS 2 Node C++ Programming Lecture5. ROS 2 Topic and Examples Lecture6. ROS 2 Service and Examples Lecture7. Useful ROS 2 Examples, Nav2 Lecture8. ROS 2 Action and Examples Lecture9. C++ Programming Again, Outro "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture1/",
	"title": "Lecture1 - Introduction to ROS 2",
	"tags": [],
	"description": "",
	"content": "About ROS 2 image from : foxglove.dev ROS의 시작은 연구실이었습니다. 구글의 핵심 개발자였던 Scott Hassan은 2006년 Willow Garage를 설립하였고, 여기서 처음으로 ROS가 탄생하였습니다. 이후 Willow Garage는 여러 Spin-off를 거친 뒤 OSRF와 OSRC등으로 나뉘게 되었고, 현재 Gazebo와 ROS는 이들에 의해 관리되고 있습니다.\n2022년 12월 기준 구글의 자회사인 Alphabet의 Intrinsic이 OSRF를 품게 되었으며, Ubuntu Linux를 관리하는 Canonical에서 ROS의 공식 서포트를 약속하고, Jetson 보드와 Issac Sim들을 개발하고 있는 Nvidia에서도 ROS를 공식 지원하고 있습니다.\n이렇게 많은 기업들이 ROS에 거는 기대가 큰 만큼 로봇 시장의 성장성도 기대가 됩니다. 하지만, 로봇이 상용화되기 위해서는 여러 난관이 있습니다.\n보안 안정성 실시간성 개발 용이성 기술 지원 하드웨어 연동 etc… 연구용으로 설계된 기존 ROS를 통해서는 이러한 모든 조건을 충족할 수 없다는 결론을 내렸고, Open Robotics는 ROS 2를 새롭게 선보이게 됩니다.\nROS 1 vs ROS 2 기존 언급되었던 ROS 1의 모든 문제들이 ROS 2에서 해결되었다고 할 수는 없지만 적어도 해결을 고려하여 설계되었다고 말하고 싶습니다.\nROS 1과 비교하여 ROS 2의 장점들을 간단히 살펴봅시다.\nimage from : maker.pro 상용화를 고려한 가장 큰 변화로 패킷 통신에 TCPROS/UPDROS가 아닌 DDS(Data Distribution Service)를 도입하였다는 것입니다.\nimage from : omg.org 뿐만 아니라, 임베디드 시스템을 위한 micro-ros와 같은 멋진 프로젝트들도 ROS 2에서 새롭게 등장하였습니다.\nimage from : freertos 이렇게 멋진 ROS 2를 지금부터 함께 배워보겠습니다.\nAbout this lecture ROS 1 강의에서는 ROS Noetic 버전을 사용하였으며, 동일한 Ubuntu 20.04 버전에서 구동되는 ROS 2 Foxy를 사용할 예정입니다.\nROS 설정을 잘 따라오셨다면 별도의 설치 과정은 필요 없으며, 리눅스 커멘드 사용법, 패키지 설치 등 기본적인 내용은 알고 있다는 가정 하에 강의를 진행해보겠습니다.\nimage from : docs.ros.org ROS 1강의를 통해 탄탄하게 다진 기본기를 바탕으로 아래와 같은 내용들을 다뤄봅니다.\nROS 2 기본 커멘드 C++ ROS 프로그래밍 Nav 2를 사용한 자율주행 실제 로봇 데이터 활용해보기 과제를 통한 ROS 2 응용 프로그래밍 더불어, 이번 강의를 통해 실제 로봇이 어떻게 개발되는지 바닥부터 살펴보고자 합니다.\n로봇 설계 시뮬레이션 제작과 실습 실제 로봇을 만들기 위해 필요한 요소들 유지 보수와 로봇 제품 개발 Road Balance의 차량형 교육 로봇, SRC를 통해 실습해보겠습니다.\n강의를 수강하기 위해 필요한 선수지식 ROS 2는 Python 3와 C++ 11이상의 버전을 지원합니다. 따라서 최소한의 프로그래밍 지식이 있다는 가정 하에 강의가 진행되며, 환경 설정, ROS 개념 등 ROS 1 강의를 모두 수강했다는 전제 하에 진행됩니다.\nimage from : docs.ros.org 이번 강의에서는 좀 더 실질적인 ROS 2 개발을 맛보고자 C++를 활용한 프로그래밍도 준비해 보았으니 이번 기회에 C++를 공부해 보는 것도 좋은 기회가 되실 겁니다.\nROS 2 Workspace 생성 ROS 1에서 catkin build system을 사용한 것과 유사하게, ROS 2에서는 colcon이라는 빌드 시스템을 사용하고 있습니다. colcon을 사용하기 위해서 Workspace가 필요하며, ROS 1과 ROS 2를 모두 사용하는 현재 시스템 같은 경우, 혼란스럽지 않도록 이름을 달리 설정하겠습니다.\ncd ~/ mkdir -p ros2_ws/src cd ros2_ws colcon build 아래와 같은 폴더 구조가 생성되었을 것입니다. build : 컴파일 된 C++ 프로그램, custom interface 등이 위치하게 됩니다. install : ros2 launch와 ros2 run 등의 명령어는 프로그램의 실행 시 이 install 폴더 내 파일들을 조회합니다. 일종의 바로가기들의 모임이라고 생각하면 됩니다. log : colcon build 시 발생하는 로드들이 위치하게 됩니다. src : 모든 소스 코드들이 위치하게 됩니다. Package를 지우고 싶은 경우 ⇒ build와 install 폴더에서 해당 package에 해당하는 내용들을 삭제합니다.\ncolcon을 사용하여 package를 빌드하는 방법들을 간단히 소개합니다.\ncolcon build : src 폴더 내부에 존재하는 모든 package들을 빌드합니다. colcon build \u0026ndash;packages-up-to : 해당 package의 종속성이 존재할 시, 이들을 먼저 빌드하고 pkg-name을 빌드합니다. colcon build \u0026ndash;packages-select : 해당 package만을 빌드합니다. 새로운 Package를 빌드한 다음 ROS 2에서도 setup.bash를 source 해주어야 합니다. 이 작업에는 크게 두가지가 존재합니다.\nsource install/setup.bash ⇒ workspace를 source하고 ROS 2시스템 전체를 갱신합니다. source install/local_setup.bash ⇒ workspace만을 sources합니다. (여러 ROS 2 workspace가 있는 경우 local_setup.bash를 사용합시다.) # source chained prefixes # setting COLCON_CURRENT_PREFIX avoids determining the prefix in the sourced script COLCON_CURRENT_PREFIX=\u0026#34;/opt/ros/foxy\u0026#34; _colcon_prefix_chain_bash_source_script \u0026#34;$COLCON_CURRENT_PREFIX/local_setup.bash\u0026#34; # source this prefix # setting COLCON_CURRENT_PREFIX avoids determining the prefix in the sourced script COLCON_CURRENT_PREFIX=\u0026#34;$(builtin cd \u0026#34;`dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;`\u0026#34; \u0026gt; /dev/null \u0026amp;\u0026amp; pwd)\u0026#34; _colcon_prefix_chain_bash_source_script \u0026#34;$COLCON_CURRENT_PREFIX/local_setup.bash\u0026#34; unset COLCON_CURRENT_PREFIX unset _colcon_prefix_chain_bash_source_script 마지막으로, 이번 실습에 필요한 소스 코드를 clone 하고, apt 패키지를 설치하면서, 강의를 마치겠습니다.\ncd ~/ros2_ws/src git clone https://github.com/RB2023ROS/du2023-ros2.git cd du2023-ros2 ./setup_scripts.sh 참고자료\nhttps://www.theconstructsim.com/infographic-ros-1-vs-ros-2-one-better-2/ https://rsl.ethz.ch/education-students/lectures/ros.html https://velog.io/@hwang-chaewon/ROS2006 "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture2/",
	"title": "Lecture2 - ROS 2 Node, Package",
	"tags": [],
	"description": "",
	"content": " ROS Noetic 강의를 이미 학습하였기 때문에, Node, Package, launch file, Topic, Message, Service와 같은 개념은 이미 알고 계실 것이라 생각합니다. (맞죠?)\n혹시나 잊어버리셨을 수 있으니 강의 중간중간 제가 간단히 리뷰를 하면서 진행하겠습니다.\nROS 2 Node image from : docs.rog.org ROS에서의 Node는 하나의 실행 가능한 프로그램을 이야기하며, 각각의 Node는 본인 고유의 기능을 담당합니다.\n서로 다른 역할을 담당하는 Node들이 각자의 동작을 수행하고 서로 간의 데이터를 주고받게 됨으로 시스템을 형성하게 되고, 따라서, ROS를 통한 로봇 개발은 곧, 적절한 Node들의 개발이라고도 말할 수 있습니다.\nROS 2 Node 실행 - ROS 2에서 Node의 실행은 ros2 run \u0026lt;pkg-name\u0026gt; \u0026lt;executable-name\u0026gt;입니다. sudo apt install ros-foxy-turtlesim -y ros2 run turtlesim turtlesim_node ROS 2의 Node를 다루는 명령어는 ROS 1과 크게 다르지 않습니다. $ ros2 node list /teleop_turtle /turtlesim $ ros2 node info /turtlesim /turtlesim Subscribers: /parameter_events: rcl_interfaces/msg/ParameterEvent /turtle1/cmd_vel: geometry_msgs/msg/Twist Publishers: /parameter_events: rcl_interfaces/msg/ParameterEvent /rosout: rcl_interfaces/msg/Log /turtle1/color_sensor: turtlesim/msg/Color /turtle1/pose: turtlesim/msg/Pose Service Servers: /clear: std_srvs/srv/Empty … rqt_graph도 동일하게 사용 가능합니다. $ rqt_graph ROS 2 Package ROS의 Package는 파일 관점에서 관련된 소스코드, 라이브러리, 모델링 파일들, 설정 파일들을 한데 모아둔 폴더로 생각할 수 있으며, 기능 관점에서 시뮬레이션, 하드웨어 제어, 센서 다루기 등으로 분리시킨 모듈로 생각할 수 있습니다.\nimage from : packthub 새로운 패키지를 생성하는 과정에서, ROS 2는 ROS 1과 차이점이 있습니다.\nROS 1에서 catkin_create_package를 사용했던 것처럼, ROS 2에서는 colcon을 사용하여 새로운 package를 생성합니다. 하지만, ROS 2에서는 사용하는 프로그래밍 언어(python/c++)에 따라 다른 build type을 지정할 수 있습니다.\nROS 2 Python Package 파이썬 패키지의 생성은 다음과 같습니다. $ ros2 pkg create --build-type ament_python \u0026lt;package_name\u0026gt; $ ros2 pkg create --build-type ament_python my_first_pkg going to create a new package package name: my_first_pkg destination directory: /home/kimsooyoung/ros2_ws/src package format: 3 version: 0.0.0 ... 그리고, 다음과 같은 폴더 구조가 자동 생성됩니다. my_first_pkg/ ├── my_first_pkg │ └── __init__.py ├── package.xml ├── resource │ └── my_first_pkg ├── setup.cfg ├── setup.py └── test ├── test_copyright.py ├── test_flake8.py └── test_pep257.py 새롭게 만든 패키지를 빌드해봅시다. $ cd ~/ros2_ws $ colcon build --packages-select my_first_pkg Starting \u0026gt;\u0026gt;\u0026gt; my_first_pkg Finished \u0026lt;\u0026lt;\u0026lt; my_first_pkg [1.56s] Summary: 1 package finished [1.96s] $ source install/local_setup.bash 생성한 파이썬 코드 패키지에서, 실제 파이썬 코드는 어디에 위치할까요?\n새로운 패키지를 생성하면 해당 패키지 폴더 안에 패키지 이름과 동일한 폴더가 하나 위치하게 됩니다. 이 폴더 안에는 init.py 파일이 기본적으로 위치합니다. 참고로, wsl에서 파일 탐색기를 열기 위해서는 explorer.exe . 를 입력하시면 됩니다.\n강의 예시 소스코드를 하나 끌어와 빌드해보겠습니다. 아주 간단한 파이썬 예시가 실행될 것입니다. $ cd ~/ros2_sw $ colcon build --packages-select py_node_tutorial Starting \u0026gt;\u0026gt;\u0026gt; py_node_tutorial Finished \u0026lt;\u0026lt;\u0026lt; py_node_tutorial [1.85s] Summary: 1 package finished [2.14s] $ source install/local_setup.bash $ ros2 run py_node_tutorial example_node_1 [INFO] [1672462290.252773294] [example_node_1]: ==== Hello ROS 2 ==== 여기서 주목할 점은, node의 실행 시 roscore가 없어도 된다는 점입니다. DDS를 사용함으로 각각의 node가 분산 처리가 가능하기 때문에 가능한 것입니다.\nimage from : design.ros2.org ROS 2 C++ Package 대부분의 오픈소스 패키지들은 C++로 개발되어 있는 경우가 많습니다. turtlesim의 소스코드를 확인해봅시다.\nhttps://github.com/ros/ros_tutorials\n모두 C++로 개발되어 있습니다. 따라서, 실제 작업 시 파이썬을 위주로 사용하더라도 적어도 C++ 패키지의 구조는 파악하고 있어야 오류 상황에 대처할 수 있습니다.\nC++ 패키지의 생성은 다음과 같습니다. $ ros2 pkg create --build-type ament_cmake \u0026lt;package_name\u0026gt; $ ros2 pkg create --build-type ament_cmake my_first_cpp_pkg going to create a new package package name: my_first_cpp_pkg destination directory: /home/kimsooyoung/ros2_ws/src package format: 3 version: 0.0.0 ... C++ 패키지는 다음과 같은 구조를 갖습니다. 파이썬과 달리, C++는 컴파일 언어이기 때문에 CMake를 위한 CMakeLists.txt 파일이 추가되어 있습니다. my_first_cpp_pkg ├── CMakeLists.txt ├── include │ └── my_first_cpp_pkg ├── package.xml └── src 일반적으로 C++ 개발을 하다보면 header와 source의 분리를 시키곤 합니다.\n이를 위해 보통 include 폴더 안에 헤더 파일을 위치시키고, src 폴더 안에 소스 코드를 위치시킵니다.\n빌드와 실행은 C++ 패키지도 동일한 커멘드 라인을 사용합니다. $ colcon build --packages-select cpp_node_tutorial $ source install/local_setup.bash Starting \u0026gt;\u0026gt;\u0026gt; cpp_node_tutorial Finished \u0026lt;\u0026lt;\u0026lt; cpp_node_tutorial [0.42s] Summary: 1 package finished [0.64s] $ ros2 run cpp_node_tutorial example_node_1 [INFO] [1672462275.581606122] [example_node_1]: ==== Hello ROS 2 ==== apt를 통한 패키지 사용하기 널리 사용되고 검증된 패키지들은 소스 코드 빌드 없이 명령어 하나만으로 사용할 수 있습니다. 다만, ROS 1과 ROS 2, 그리고 같은 ROS 2일지라도 버전에 따라 재설치를 해줘야 합니다.\n$ sudo apt install ros-\u0026lt;DISTRO\u0026gt;-\u0026lt;pkg-name\u0026gt; $ sudo apt install ros-foxy-turtlesim 지금까지 우리가 사용했던 turtlesim, turtle_teleop_key는 모두 apt install turtlesim을 통해 설치가 가능하였기에 코드에 대한 고려 없이 바로 실행할 수 있던 것입니다.\n이를 사용하여 ROS 개발 초기에는 바로 설치 가능한 패키지들을 조합하여 빠르게 검증을 하고, 이후 직접 Customizing해야 하는 부분은 별도 소스코드 빌드를 통해 업그레이드를 하곤 합니다.\nROS 2 Launch ROS 2의 launch파일은 기본적으로 Python 문법을 사용합니다. 기존 ROS 1에서 xml 문법을 사용하던 것에서 비교하면, 보다 손쉽게 접근할 수 있어졌습니다.\n예제를 통해 기본 구조에 대해 짚고 넘어가겠습니다. $ cd ~/ros2_ws $ colcon build --packages-select src_description $ source install/local_setup.bash $ ros2 launch src_description src_description.launch.py 사진과 같이 RViz2와 joint state publisher gui가 등장할 것입니다. joint state publisher gui의 슬라이드바를 이리저리 옮겨보세요.\nROS 1 강의에서 배워보았던 tf에 대해서도 복습할 수 있는 기회입니다.\nros2의 launch 명령어는 다음과 같이 구성되어 있습니다. $ ros2 launch \u0026lt;package-name\u0026gt; \u0026lt;launch-file-name\u0026gt; 패키지 내에 존재하는 특정 launch 파일을 실행해라, 라는 뜻이 됩니다.\n예제 launch file을 살펴봅시다. ros2의 launch file은 python과 xml을 지원합니다. python 파일의 경우 .launch.py로 이름짓는 것이 일반적입니다.\n항상 launch file의 분석은 가장 하단부터 시작합니다. return LaunchDescription([ TimerAction( period=3.0, actions=[rviz2] ), robot_state_publisher, joint_state_publisher_gui, ]) LaunchDescription[] 안에 위치한 프로그램들을 동시에 실행하는 것이 launch file을 작성하는 이유입니다.\n상단 옵션을 하나씩 살피겠습니다. launch file에서 특정 폴더, 파일에 접근하기 위해 package에 기반하여 경로를 탐색합니다. def generate_launch_description(): pkg_path = os.path.join(get_package_share_directory(\u0026#34;src_description\u0026#34;)) rviz_config_file = os.path.join(pkg_path, \u0026#34;rviz\u0026#34;, \u0026#34;description.rviz\u0026#34;) urdf_file = os.path.join(pkg_path, \u0026#34;urdf\u0026#34;, \u0026#34;src_body.urdf\u0026#34;) urdf - Unified Robotics Description Format란 로봇의 형상을 파일로 표현하는 일종의 포멧입니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;!-- | This document was autogenerated by xacro from /home/kimsooyoung/ros2_ws/src/du2023-ros2/src_gazebo/urdf/src_body.urdf.xacro | --\u0026gt; \u0026lt;!-- | EDITING THIS FILE BY HAND IS NOT RECOMMENDED | --\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;robot name=\u0026#34;src_body\u0026#34;\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.700 0.700 0.700 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;1.000 1.000 1.000 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.0 0.8 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;green\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.8 0.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;grey\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.2 0.2 0.2 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; ... image from : http://library.isr.ist.utl.pt/ src의 urdf와 description 결과를 함께 살펴보면서 urdf에 대한 개념을 익혀봅시다.\nurdf를 생성하는 여러 방법들이 있습니다.\nxacro와 함께 직접 텍스트를 작성하기 CAD 프로그램을 사용하기 SOLIDWORKS Fusion 360 blender 시뮬레이션 프로그램 내 model builder 사용하기 Gazebo Colleliasim 저의 경우, Fusion 360에서 사용할 수 있는 오픈소스 urdf exporter를 통해 시뮬레이션을 개발하였습니다.\nhttps://github.com/syuntoku14/fusion2urdf\nurdf를 사용하여 ROS에게 로봇에 대한 정보를 전달하고 지속 주시하는 것이 아래 두 Node의 역할입니다. joint_state_publisher_gui = Node( package=\u0026#34;joint_state_publisher_gui\u0026#34;, executable=\u0026#34;joint_state_publisher_gui\u0026#34;, name=\u0026#34;joint_state_publisher_gui\u0026#34;, ) robot_state_publisher = Node( package=\u0026#39;robot_state_publisher\u0026#39;, executable=\u0026#39;robot_state_publisher\u0026#39;, name=\u0026#39;robot_state_publisher\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[{\u0026#39;use_sim_time\u0026#39;: True}], arguments=[urdf_file], ) launch file 분석의 마지막으로 Rviz2 실행입니다. Rviz와 동일하게 launch file에서 config option을 줄 수 있으며, TimerAction을 통해 3초의 여유를 갖고 실행하도록 하였습니다. # Launch RViz rviz2 = Node( package=\u0026#34;rviz2\u0026#34;, executable=\u0026#34;rviz2\u0026#34;, name=\u0026#34;rviz2\u0026#34;, output=\u0026#34;screen\u0026#34;, arguments=[\u0026#34;-d\u0026#34;, rviz_config_file], ) return LaunchDescription([ TimerAction( period=3.0, actions=[rviz2] ), ROS 2의 launch file 작성법을 간단하게 설명하고 넘어가겠습니다. robot_state_publisher = Node( package=\u0026#39;robot_state_publisher\u0026#39;, executable=\u0026#39;robot_state_publisher\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[robot_description] ) Node : Node 하나를 실행시킬 수 있는 옵션입니다. package : 실행시킬 Node가 포함된 package를 선택해줍니다. executable : c++ Node의 경우, colcon build를 하면 실행 가능한 프로그램이 생성됩니다. python의 경우도 스크립트를 실행 시키게 되며, 추후 코딩 실습을 거치면 완벽히 이해하실 수 있을 것입니다. parameters : 실행시킬 Node의 추가 매개변수가 있다면 이 부분에 추가됩니다. 이렇게 launch file 하나를 분석해 보았습니다. 하지만, 제가 보여드린 것은 하나의 예시일 뿐이며, launch file은 여러 형식으로 사용되고 있습니다.\n일례로, 자율 주행 시 사용되는 nav2 패키지의 lanuch file은 다음과 같은 형태를 갖습니다.\ndeclare_namespace_cmd = DeclareLaunchArgument( \u0026#39;namespace\u0026#39;, default_value=\u0026#39;\u0026#39;, description=\u0026#39;Top-level namespace\u0026#39;) ... # Create the launch description and populate ld = LaunchDescription() # Set environment variables ld.add_action(stdout_linebuf_envvar) # Declare the launch options ld.add_action(declare_namespace_cmd) ld.add_action(declare_use_namespace_cmd) ld.add_action(declare_slam_cmd) ld.add_action(declare_map_yaml_cmd) ld.add_action(declare_use_sim_time_cmd) ld.add_action(declare_params_file_cmd) ld.add_action(declare_autostart_cmd) ld.add_action(declare_bt_xml_cmd) # Add the actions to launch all of the navigation nodes ld.add_action(bringup_cmd_group) return ld 아직 프로그래밍을 시작하지도 않았기 때문에, launch file에 대해서 모두 이해하려 하지는 않으셔도 됩니다. 남은 강의들에서 계속해서 살펴보겠습니다.\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture3/",
	"title": "Lecture3 - ROS 2 Node Programming, ROS 2 parameter",
	"tags": [],
	"description": "",
	"content": " Python을 사용하여 Node Programming을 실습해봅시다. 강의 마지막에는 간단히 C++ 코딩에 대해서도 다뤄보겠습니다.\nexample 1 - Hello ROS 2 강의를 위해 준비된 예제 코드 패키지를 실습하고 분석하겠습니다.\n$ colcon build --packages-select cbp py_node_tutorial $ source install/local_setup.bash $ ros2 run py_node_tutorial example_node_1 [INFO] [1672463872.778216198] [example_node_1]: ==== Hello ROS 2 ==== 모든 예제 코드는 아래 링크에서 확인할 수 있습니다. https://github.com/RB2023ROS/du2023-ros2/tree/main/py_node_tutorial/py_node_tutorial\n코드 분석을 차근차근 함께 해보겠습니다.\nrcl은 ROS Client Libraries의 약자로 ROS 2에서는 rclc, rclcpp, rclpy, rcljs와 같은 다양한 언어를 지원하고 있습니다. 파이썬에서 ROS 2 개발을 하기 위해서는 필수적으로 rclpy의 import가 필요하며 Node의 사용을 위해서는 Node class를 import 해야 합니다.\n# !/usr/bin/env python3 import rclpy from rclpy.node import Node rclpy 코딩 규칙 ROS 2에서 파이썬 파일을 조회하고 실행하는 과정이 있어 아래와 같이 main()부분을 항상 따로 분리하여 작성하도록 합니다.\nif __name__ == \u0026#39;__main__\u0026#39;: \u0026#34;\u0026#34;\u0026#34;main function\u0026#34;\u0026#34;\u0026#34; main() Node 생성 def main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) node.destroy_node() rclpy.shutdown() 실제 동작을 수행하는 main 함수를 살펴보면 다음과 같은 과정을 거치고 있습니다.\nrclpy.init을 통해 initialization, 즉 초기화를 하고 있습니다. node = Node(\u0026rsquo;node_name\u0026rsquo;) : Node를 생성하는 부분으로 앞서 import한 Node class를 사용하고 있습니다. 매개변수로 node의 이름이 들어갑니다. node.destroy_node() : Node를 생성하고 원하는 작업을 모두 수행했다면, 이제 사용했던 Node를 제거해야 할 것입니다. 그래야 불필요한 자원의 낭비를 줄일 수 있겠지요. rclpy.shutdown() : 이번 예제의 제일 첫 부분에 rclpy.init을 통하여 초기화를 해주었습니다. 이제 rclpy를 통한 작업이 모두 끝났으므로 안전하게 종료시켜줍니다. 위 과정이 Python에서 rclpy를 통해 Node를 다루는 기본 절차입니다.\n1과 4, 2와 3이 짝꿍처럼 보이지요?\nsetup.py 수정 파이썬 파일을 ros2 run 으로 실행하기 위해서 패키지 내 setup.py 파일에 entry_points를 추가해 주어야 합니다.\nentry_points={ \u0026#39;console_scripts\u0026#39;: [ \u0026#39;example_node_1 = py_node_tutorial.node_example_1:main\u0026#39;, \u0026#39;example_node_2 = py_node_tutorial.node_example_2:main\u0026#39;, \u0026#39;example_node_3 = py_node_tutorial.node_example_3:main\u0026#39;, \u0026#39;example_node_4 = py_node_tutorial.node_example_4:main\u0026#39;, \u0026#39;example_node_5 = py_node_tutorial.node_example_5:main\u0026#39;, ], }, 작성하는 방법은 다음과 같습니다. ⇒ 실행 시 사용될 이름 = \u0026lt;패키지 이름\u0026gt;.\u0026lt;파일 이름\u0026gt;.main\nexample 2 - timer 로봇은 실행된 이후 계속해서 작업을 수행해야 하기에 주기적으로 무언가를 실행하는 일이 잦습니다. 이를 구현하는 Timer를 살펴봅시다. $ ros2 run py_node_tutorial example_node_2 ==== Hello ROS 2 : 1==== ==== Hello ROS 2 : 2==== ==== Hello ROS 2 : 3==== ==== Hello ROS 2 : 4==== ==== Hello ROS 2 : 5==== main문에 추가된 create_timer와 timer_callback 함수를 확인할 수 있습니다. def timer_callback(): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; global count count += 1 print(f\u0026#39;==== Hello ROS 2 : {count}====\u0026#39;) def main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.create_timer(0.2, timer_callback) rclpy.spin(node) node.destroy_node() rclpy.shutdown() timer를 생성하기 위해서 create_timer 함수가 사용됩니다.\ntimer_period_sec : 실행 주기 (초) callback : 해당 주기마다 실행될 함수 image from : docs.ros2.org\nexample 3 - spin_once, spin Node의 상태를 살피면서 반복 실행시키는 spin 함수에 대해 좀 더 자세하게 살펴봅니다.\n예제 실행 $ ros2 run py_node_tutorial example_node_3 ==== Hello ROS 2 : 1==== ==== Hello ROS 2 : 2==== ==== Hello ROS 2 : 3==== ... 주요 코드를 분석해 보겠습니다. Node는 상태를 지속 유지하면서 변경된 내용에 따라 지정된 동작을 수행해야 합니다. 이는 로봇 프로그램에서 매우 보편적인 작업으로, ROS 2에서는 **spin()**이라는 이름의 함수로 기능을 제공하고 있습니다.\ndef main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.create_timer(0.2, timer_callback) while True: rclpy.spin_once(node, timeout_sec=10) node.destroy_node() rclpy.shutdown() spin을 비롯하여 spin_once, spin_until_future_complete와 같이 프로그램의 실행을 관리하기 위한 다양한 추가 함수들이 존재합니다.\ntimer_callback과 OOP의 필요성 def timer_callback(): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; global count count += 1 print(f\u0026#39;==== Hello ROS 2 : {count}====\u0026#39;) # How can I use logger without globalization ? # node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) callback 함수가 사용되면 필연적으로 두 함수 간 공유되는 count와 같은 자원이 생기며, 이 count를 다루면서 예기치 못한 실수가 발생할 수 있습니다.\n지금은 모두 전역 변수로 작업하고 있었는데, 이것을 어떻게 효율적으로 처리할 수 있을까요?\nexample 4 - OOP Node 예제 실행의 결과는 이전과 같습니다. 하지만 구현에서 차이를 갖습니다. $ ros2 run py_node_tutorial example_node_5 [INFO] [1657348011.971419700] [composition_example_node]: ==== Hello ROS 2 : 1==== [INFO] [1657348012.163466100] [composition_example_node]: ==== Hello ROS 2 : 2==== [INFO] [1657348012.363590700] [composition_example_node]: ==== Hello ROS 2 : 3==== class를 사용하여 Node를 구현한 모습을 확인할 수 있습니다. class NodeClass(Node): \u0026#34;\u0026#34;\u0026#34;Second Node Class. Just print log periodically. \u0026#34;\u0026#34;\u0026#34; def __init__(self): \u0026#34;\u0026#34;\u0026#34;Node Initialization. You must type name of the node in inheritanced initializer. \u0026#34;\u0026#34;\u0026#34; super().__init__(\u0026#39;composition_example_node\u0026#39;) self.create_timer(0.2, self.timer_callback) self._count = 1 def timer_callback(self): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; self.get_logger().info(f\u0026#39;==== Hello ROS 2 : {self._count}====\u0026#39;) self._count += 1 ROS 1과 달리, ROS 2의 OOP 구현은 Node를 상속받습니다. (때문에 생성 시, Node이름을 super().__init__()안에 넣어주어야 합니다.)\n이렇게 객체지향을 사용하면 Node의 기능들을 적극 활용하여 더욱 쉽고 강력한 ROS 2 개발이 가능해집니다. 앞으로의 예시에서는 모두 객체 지향을 사용하겠습니다.\nrclpy logger super().__init__(\u0026#39;node_name\u0026#39;) ... node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) rospy.loginfo()와 같이 rclpy에서도 get_logger라는 logging API를 제공합니다. 다만, rclpy의 logger는 Node에 종속되는 개념입니다. (ROS 2에서는 여러 Node가 하나의 프로세스 안에서 실행될 수 있기 때문입니다.)\nget_logger()를 사용하면 일반적인 print 콘솔 출력과는 달리, 실행중인 Node이름, 시간, 위험성 등을 디버깅할 수 있어 이후 복잡한 시스템에서 큰 도움이 됩니다.\nexample 5 - Logger Level 기본 node 프로그래밍의 마지막 예시입니다. $ ros2 run py_node_tutorial example_node_5 [INFO] [1657348108.163389800] [node_name]: ==== Hello ROS 2 : 1==== [WARN] [1657348108.163810900] [node_name]: ==== Hello ROS 2 : 1==== [ERROR] [1657348108.164126200] [node_name]: ==== Hello ROS 2 : 1==== [FATAL] [1657348108.164514300] [node_name]: ==== Hello ROS 2 : 1==== ... ROS 1에서와 유사하게 ROS 2에서도 위험도에 따라서 다른 logger level을 적용할 수 있습니다.\ninfo를 기준으로 아래로 갈수록 높은 레벨의 log이며, 제일 심각한 error와 fatal의 경우, 콘솔 출력시에도 빨간 글씨로 보이는 것을 확인할 수 있습니다.\nimage from : 51CTO debug의 경우 실제 콘솔 출력으로는 나타나지 않으며, 효과적인 Tracking을 위해 ROS 1 강의에서 배운 rqt console 사용을 권장합니다.\nROS 2 Parameter ROS 1에서와 마찬가지로, ROS 2에서도 각종 매개변수를 다룰 수 있는 커멘드 명령어와 코드 API를 제공합니다.\n예제 Package 빌드와 실행 $ colcon build --packages-select py_param_tutorial $ source install/local_setup.bash $ ros2 run py_param_tutorial param_example [INFO] [1672390971.030532687] [param_ex_node]: string_param: world int_param: 119 float_param: 3.1415 arr_param: [1, 2, 3] nested_param.string_param: Wee Woo param_ex_node에서 5종류의 매개변수가 선언되었습니다. 이들을 확인하는 커멘드 라인을 배워봅시다.\nros2 param list $ ros2 param list /param_ex_node: arr_param float_param int_param nested_param.string_param string_param use_sim_time ros2 param get/set - node 이름과 매개변수 이름을 모두 필요로 함에 주의합니다. $ ros2 param get /param_ex_node arr_param Integer values are: array(\u0026#39;q\u0026#39;, [1, 2, 3]) $ ros2 param set /param_ex_node arr_param \u0026#39;[1,2,3,4]\u0026#39; Set parameter successful $ ros2 param get /param_ex_node arr_param Integer values are: array(\u0026#39;q\u0026#39;, [1, 2, 3, 4]) 이제, 파이썬 코드를 분석해봅시다.\nparameter의 생성은 node 내에서 이루어지며, declare_parameter를 통해 생성합니다. 함수의 두번째 인자는 기본값입니다. nested_param과 같이, parameter는 계층 구조를 가질 수 있으며 . 을 통해 구분할 수 있습니다. string_param이라는 이름을 가진 parameter가 두 종류 존재하지만 서로 소속된 계층이 달라 공존할 수 있는 것입니다.\nclass ParamExNode(rclpy.node.Node): def __init__(self): super().__init__(\u0026#39;param_ex_node\u0026#39;) self.declare_parameter(\u0026#39;string_param\u0026#39;, \u0026#39;world\u0026#39;) self.declare_parameter(\u0026#39;int_param\u0026#39;, 119) self.declare_parameter(\u0026#39;float_param\u0026#39;, 3.1415) self.declare_parameter(\u0026#39;arr_param\u0026#39;, [1,2,3]) self.declare_parameter(\u0026#39;nested_param.string_param\u0026#39;, \u0026#39;Wee Woo\u0026#39;) 선언된 매개변수의 값은 get_parameter를 통해 확인 가능합니다. get_parameter 자체는 Object이고, value 속성이 실제 값을 갖고 있습니다. string_param = self.get_parameter(\u0026#39;string_param\u0026#39;) int_param = self.get_parameter(\u0026#39;int_param\u0026#39;) float_param = self.get_parameter(\u0026#39;float_param\u0026#39;) arr_param = self.get_parameter(\u0026#39;arr_param\u0026#39;) nested_param = self.get_parameter(\u0026#39;nested_param.string_param\u0026#39;) self.get_logger().info(f\u0026#34;\\nstring_param: {string_param.value} \\ \\nint_param: {int_param.value} \\ \\nfloat_param: {float_param.value} \\ \\narr_param: {arr_param.value} \\ \\nnested_param.string_param: {nested_param.value}\u0026#34; ) parameter는 launch file에서도 설정할 수 있습니다. - Hello, 112로 변경된 값을 확인해봅시다. $ ros2 launch py_param_tutorial launch_with_param.launch.py ... [param_example-1] [INFO] [1672387864.135213913] [param_example]: [param_example-1] string_param: Hello [param_example-1] int_param: 112 [param_example-1] float_param: 3.1415 [param_example-1] arr_param: [1, 2, 3] launch file의 parameters 옵션을 사용하여 이러한 작업이 가능합니다. def generate_launch_description(): param_ex_node = Node( package=\u0026#39;py_param_tutorial\u0026#39;, executable=\u0026#39;param_example\u0026#39;, name=\u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[ {\u0026#39;string_param\u0026#39;: \u0026#39;Hello\u0026#39;}, {\u0026#39;int_param\u0026#39;: 112}, ], ) parameter가 매우 많은 경우에는 ROS 1에서와 같이 yaml 파일을 사용해 관리할 수 있습니다. launch file의 주석된 부분을 해제하고 다시 실행해봅시다. config = os.path.join( get_package_share_directory(\u0026#39;py_param_tutorial\u0026#39;), \u0026#39;config\u0026#39;, \u0026#39;params.yaml\u0026#39; ) param_ex_node = Node( package = \u0026#39;py_param_tutorial\u0026#39;, executable = \u0026#39;param_example\u0026#39;, name = \u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters = [config] ) 모든 매개변수들이 변경된 것을 확인 가능합니다.\n$ ros2 launch py_param_tutorial launch_with_param.launch.py ... [param_example-1] [INFO] [1672391557.995024614] [param_example]: [param_example-1] string_param: Yaml Yaml [param_example-1] int_param: 5 [param_example-1] float_param: 3.14 [param_example-1] arr_param: [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;ROS 2\u0026#39;] [param_example-1] nested_param.string_param: Ooh Wee yaml 파일은 config/params.yaml에 위치하고 있습니다. parameter 관리 용도로 사용하기 위해서 yaml 파일은 일정한 규칙을 갖춰야 합니다. param_example: ros__parameters: string_param: \u0026#34;Yaml Yaml\u0026#34; int_param: 5 float_param: 3.14 arr_param: [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;ROS 2\u0026#39;] nested_param: string_param: \u0026#34;Ooh Wee\u0026#34; \u0026lt;node-name\u0026gt;: ros__parameters: \u0026lt;param-name\u0026gt;: \u0026lt;param-value\u0026gt; ... \u0026lt;nested-layer-name\u0026gt;: \u0026lt;param-name\u0026gt;: \u0026lt;param-value\u0026gt; 이렇게 새로운 폴더와 파일을 추가한 경우, python 패키지의 setup.py를 수정해주어야 하며 패키지 빌드도 새로 해주어야 합니다. import os from glob import glob from setuptools import setup package_name = \u0026#39;py_param_tutorial\u0026#39; setup( name=package_name, version=\u0026#39;0.0.0\u0026#39;, packages=[package_name], data_files=[ (\u0026#39;share/ament_index/resource_index/packages\u0026#39;, [\u0026#39;resource/\u0026#39; + package_name]), (\u0026#39;share/\u0026#39; + package_name, [\u0026#39;package.xml\u0026#39;]), (os.path.join(\u0026#39;share\u0026#39;, package_name, \u0026#39;config\u0026#39;), glob(\u0026#39;config/*.yaml\u0026#39;)), (os.path.join(\u0026#39;share\u0026#39;, package_name, \u0026#39;launch\u0026#39;), glob(\u0026#39;launch/*.launch.py\u0026#39;)), ], launch file에 추가된 내용을 다시 살펴보면, 방금 전의 yaml 파일을 불러와서 node의 실행 option에 전달하고 있습니다. config = os.path.join( get_package_share_directory(\u0026#39;py_param_tutorial\u0026#39;), \u0026#39;config\u0026#39;, \u0026#39;params.yaml\u0026#39; ) param_ex_node = Node( package = \u0026#39;py_param_tutorial\u0026#39;, executable = \u0026#39;param_example\u0026#39;, name = \u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters = [config] ) 아래 예시에서 보이듯이 로봇의 초기 속도, 최대/최소 값들, 하드웨어와 관련된 튜닝값 등 수많은 매개변수들이 사용되며 모두 지금 배운 parameter를 사용하게 됩니다.\nhttps://github.com/ros-planning/navigation2/blob/main/nav2_bt_navigator/src/bt_navigator.cpp\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture4/",
	"title": "Lecture4 - ROS 2 Node C++ Programming",
	"tags": [],
	"description": "",
	"content": " 실제 로봇 개발에서 Python만 사용되지는 않습니다. tensorflow, pytorch와 같은 딥러닝 프레임워크들이 모두 Python을 사용하고 있고, 상대적으로 개발 과정이 쉬워 많은 사람들이 Python을 사용하고 있지만, 제어, 센싱을 위해서는 C++를 대부분 사용한다고 보시면 됩니다.\nimage from : wikipedia 따라서 앞선 node 프로그래밍 예시들을 모두 C++로 구현해 볼 예정입니다. 아래와 같은 C++ 지식이 필요하지만 필수는 아닙니다.\n클래스 생성 (OOP) 스마트 포인터 헤더 분리 람다 함수 std::bind와 placeholders C++ 빌드 시스템 (CMake) 코드 설명에 앞서 ROS 2 C++ 패키지를 개발하는 절차에 대해 빠르게 훑어보겠습니다.\n패키지 생성 후 src \u0026amp; include 폴더에서 코드 작성 ros2 pkg create --build-type ament_cmake \u0026lt;package_name\u0026gt; CMakeLists.txt \u0026amp; package.xml 수정 add_executable(example_node_1 src/node_example_1.cpp) ament_target_dependencies(example_node_1 rclcpp) install( TARGETS example_node_1 DESTINATION lib/${PROJECT_NAME} ) 코드 빌드와 디버깅 colcon build --packages-select \u0026lt;package_name\u0026gt; source install/local_setup.bash 코드 실행 ros2 run \u0026lt;pkg-name\u0026gt; \u0026lt;executable-name\u0026gt; 개발 과정 자체는 파이썬 package와 크게 다르지 않습니다.\n하지만, C++ 개발은 코드를 빌드하는 과정에서 각종 컴파일 에러와 링크 에러, 런타임 에러까지 발생하기 때문에 개발에 여러움이 생길 수 있습니다.\n⇒ 이를 해결하기 위해서, 학생 라이센스로 무료 사용 가능한 IDE를 소개하고, 함께 셋업해보고자 합니다.\nCLion 설치와 ROS 2 개발환경 설정 CLion은 IDE의 명가 Jetbrains에서 만든 C/C++용 통합 개발 환경입니다. C++ 개발자를 힘들게 하는 각종 에러들의 디버깅을 편리하게 해줄 뿐더러 ROS 2 개발을 위한 솔루션도 제공하고 있습니다.\nimage from : wikipedia CLion은 오픈소스가 아닌 판매되고 있는 소프트웨어입니다.\n하지만 학생에게는 무료 라이센스를 제공하고 있습니다. 아래 링크를 통해서 회원가입과 학생인증을 진행한 다음, CLion을 설치합시다.\nhttps://www.jetbrains.com/clion/\nhttps://www.jetbrains.com/community/education/#students\n이메일 인증을 거치면 어렵지 않게 학생인증이 완료됩니다. 이 과정은 생략하겠습니다.\n학생 라이센스를 통해 CLion을 비롯하여 IntelliJ, PyCharm, WebStorm과 같은 다양한 언어의 IDE를 무료로 사용 가능합니다. snapcraft를 통해 CLion을 설치하고 실행 해봅시다. $ sudo snap install clion --classic [sudo] password for kimsooyoung: clion 2022.3.1 from jetbrains✓ installed $ clion 약관 동의 및 로그인을 통한 학생 인증을 거치면 모든 설치 절차가 완료됩니다. colcon build를 통해 빌드했던 cpp_node_tutorial package를 clion 프로젝트로 열어보겠습니다. clion에서 File ⇒ Open을 실행한 뒤 cpp_node_tutorial의 CMakeLists.txt를 선택합니다. build target를 지정하고 실행하면 CLion상에서 ROS 2 프로그램을 실행시킬 수 있습니다. CLion에서의 장점을 직접 살펴보기 위해 프로그램 개발을 함께 해보겠습니다. 라이브 코딩 Time!!\n모든 설정이 완료되었다면, 이제 본격적으로 C++ 예제 코드를 살펴봅시다.\nexample 1 - Hello ROS 2 파이썬에서 한차례 살펴본 바 있기에 자세한 로직들은 생략합니다.\n예제 실행 $ ros2 run cpp_node_tutorial example_node_1 [INFO] [1666431282.586519100] [example_node_1]: ==== Hello ROS 2 ==== 코드 분석 #include \u0026lt;rclcpp/rclcpp.hpp\u0026gt; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;example_node_1\u0026#34;); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 ====\u0026#34;); rclcpp::shutdown(); return 0; } rclcpp은 ROS 2를 C++에서 사용하기 위해 필요한 코드의 집합입니다.\nNode 생성 시 주의하셔야 할 점은 “모든 Node가 포인터의 형식을 갖는다”는 것입니다. shared_ptr를 사용하여 메모리 누수를 막기 위해 파생된 모든 데이터들을 추적하고 있습니다.\nrclcpp에서 로그의 실행은 RCLCPP_INFO와 get_logger() 메소드를 통해 실행할 수 있으며, 로그는 Node에서 실행된다는 점을 기억합시다.\nCMakeLists.txt 수정\n# find_package를 통해 종속성들을 추가합니다. find_package(\u0026lt;depends\u0026gt; REQUIRED) # 실행 프로그램 빌드 설정 add_executable(\u0026lt;program_name\u0026gt; include/\u0026lt;header\u0026gt;.hpp src/\u0026lt;code\u0026gt;.cpp ...) ament_target_dependencies(\u0026lt;program_name\u0026gt; \u0026lt;dependency1\u0026gt; \u0026lt;dependency2\u0026gt; ...) install( TARGETS \u0026lt;program_name\u0026gt; DESTINATION lib/${PROJECT_NAME} ) 패키지 빌드 \u0026amp; 실행 colcon build --packages-select cpp_node_tutorial source install/local_setup.bash ros2 run cpp_node_tutorial example_node_1 예제 소스 코드를 조금이라도 수정하여 여러분들만의 코드를 작성해보고 CLion을 통한 빌드까지 스스로 한 번 해봅시다.\nexample 2 - Timer 예제 실행 $ ros2 run cpp_node_tutorial example_node_2 ==== Hello ROS 2 : 0 ==== ==== Hello ROS 2 : 1 ==== ==== Hello ROS 2 : 2 ==== ==== Hello ROS 2 : 3 ==== ==== Hello ROS 2 : 4 ==== ... rclcpp에서 timer는 create_wall_timer를 사용합니다. #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; static int count = 0; void timer_callback(){ std::cout \u0026lt;\u0026lt; \u0026#34;==== Hello ROS 2 : \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; ====\u0026#34; \u0026lt;\u0026lt; std::endl; count++; } int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;example_node_2\u0026#34;); auto timer = node-\u0026gt;create_wall_timer(std::chrono::milliseconds(200), timer_callback); rclcpp::spin(node); rclcpp::shutdown(); return 0; } example 3 - OOP Node 기능 자체는 큰 의미가 없으므로 코드를 위주로 설명하겠습니다. #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; class NodeClass: public rclcpp::Node { public: NodeClass(): Node(\u0026#34;example_node_4\u0026#34;) {} }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;NodeClass\u0026gt;(); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 ====\u0026#34;); rclcpp::shutdown(); return 0; } 모든 Node는 rclcpp::Node로부터 상속을 받습니다. 상속 후 생성자에서 Node의 이름을 지정해줘야 하며, topic pub/sub, logger와 같은 기능들은 모두 rclcpp::Node에 구현되어 있습니다.\n더불어, Node 자체는 포인터로 취급된다는 점도 다시 한 번 강조드립니다.\nexample 4 - OOP Timer Node callback 함수를 binding하는 부분에 집중하세요. timer_callback는 클래스 메소드이기 때문에 binding 시 NodeClass::timer_callback와 같이 명시해주어야 합니다. #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; class NodeClass: public rclcpp::Node { private: size_t count; rclcpp::TimerBase::SharedPtr timer; void timer_callback() { RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d\u0026#34;, count); count++; } public: NodeClass() : Node(\u0026#34;example_node_5\u0026#34;) { timer = this-\u0026gt;create_wall_timer( std::chrono::milliseconds(200), std::bind(\u0026amp;NodeClass::timer_callback, this) ); } }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;NodeClass\u0026gt;(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } 마지막으로 rclcpp logger level을 간단히 살펴보고 마무리짓겠습니다. void timer_callback() { RCLCPP_DEBUG(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_WARN(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_ERROR(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_FATAL(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); count++; } 참고자료\nhttps://roboticsbackend.com/ros2-yaml-params/ https://roboticsbackend.com/rclpy-params-tutorial-get-set-ros2-params-with-python/ https://www.jetbrains.com/help/clion/ros2-tutorial.html#change-prj-root "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture5/",
	"title": "Lecture5 - ROS 2 Topic and Examples",
	"tags": [],
	"description": "",
	"content": " Topic에 대해 배워보기 전에, 실습 시스템을 구축해봅시다.\nSRC Gazebo 이번 ROS 2 강의의 실습들은 Road Balance의 차량형 로봇 SRC를 통해 진행하고자 합니다. 실습을 진행하기 전 Gazebo 환경을 함께 세팅해보겠습니다.\nsrc_gazebo 실행 세팅 - 다소 번거로운 작업이므로 gif를 보시면서 차근차근 잘 따라와주세요! cd ~/ros2_ws/src/du2023-ros2 ./setup_scripts.sh # CMakeLists.txt 수정 (주석) colcon build --packages-select src_gazebo source install/local_setup.bash # CMakeLists.txt 수정 (주석 해제) colcon build --packages-select src_gazebo colcon build --packages-select src_odometry colcon build --packages-select src_controller source install/local_setup.bash empty world 실행 ros2 launch src_gazebo empty_world.launch.py 빈 gazebo 환경에 차량형 로봇이 등장할 것입니다. 함께 등장하는 rqt_robot_steering을 통해 로봇을 움직여보세요. 실행 중 발생할 수 있는 오류와 해결방법을 제시드립니다. 아래와 같은 에러 발생 시 sudo apt dist-upgrade를 입력하면 됩니다. 로봇에 부착되어 있는 센서 데이터들과 제어 데이터를 ros2 topic list로 확인해봅시다.\n/cmd_vel : Twist msg를 통해 로봇을 제어하는 topic /imu/data : imu 데이터 /scan : 2D lidar /logi_camera_sensor/image_raw : 전방 카메라 데이터 ROS 2 Topic 강의를 열심히 따라오면서 ROS 개념을 잊어버렸을 수도 있으므로 간단히 개념 복습을 해보겠습니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름이며, 적절한 이름으로 데이터를 송수신하지 않으면 원하는 동작을 수행할 수 없습니다. image from : docs.ros.org\nTopic의 중요한 특징으로 Topic은 여러 Node들로부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. image from : docs.ros.org topic을 통해 데이터가 전달되는 과정은 다음과 같습니다.\n데이터를 보내는 주체인 publisher는 topic을 통해 원하는 정보를 subscriber에게 전달합니다. 이것을 topic publish라고 부르지요. 반대로, 데이터를 받는 주체인 subscriber 입장에선 topic을 통해 데이터를 받게 되며 이것은 topic subscribe라고 불립니다. ROS 2 Topic msg 로봇 프로그래밍 시 센서, 제어 데이터를 비롯하여 다양한 유형의 데이터들이 Topic을 통해 오고 갑니다. ROS에서는 이러한 데이터 형식을 msg - Message라는 형태로 제공하며, 원하는 데이터에 적합한 topic msg를 사용하면 더욱 효율적인 로봇 프로그래밍이 가능해집니다.\nimage from : ethz.ch geometry_msgs/Twist와 같은 message는 ROS 2에서도 동일하게 사용할 수 있습니다. 다만, ROS 2에서는 msg/srv/action 과 같이 필드의 구분이 하나 더 추가됩니다.\nROS 1 : geometry_msgs/Twist ROS 2 : geometry_msgs/msg/Twist 출처 : http://docs.ros.org/ 특정 message가 어떻게 구성되어 있는지 알고 싶을 때는 다음과 같은 커멘드 라인을 사용합니다.\n$ ros2 interface show geometry_msgs/msg/Twist # This expresses velocity in free space broken into its linear and angular parts. Vector3 linear Vector3 angular 혹은 앞서 제가 살펴본 것 처럼 검색을 해 보아도 됩니다.\nROS 2로 넘어오면서, topic 커멘드들은 다음과 같이 살짝 바뀌었습니다.\nrostopic list ⇒ ros2 topic list rostopic info ⇒ ros2 topic info rostopic echo ⇒ ros2 topic echo ROS 2 Topic Tools ROS 2에서도 GUI툴 RQT를 사용할 수 있습니다. Topic과 관련된 rqt tools들을 사용해봅시다.\nROS 1과 ROS 2의 rqt는 다른 프로그램이며 ROS 1의 plugin과 ROS 2의 plugin이 완전 동일하지는 않습니다.\n실습을 위해 gazebo와 rqt를 실행합니다. # Terminal 1 ros2 launch src_gazebo empty_world.launch.py # Terminal 2 rqt rqt 상단의 메뉴바에서 Plugins ⇒ Topics ⇒ Topic Monitor를 클릭합니다. topic monitor를 통해 현재 오가고 있는 topic들을 한눈에 볼 수 있습니다. 이번에는 rqt 상단의 메뉴바에서 Plugins ⇒ Topics ⇒ Message Publisher를 클릭하고, + 버튼을 눌러 publish를 원하는 topic을 추가합니다.\nTopic Publisher는 별도의 작업 없이 msg에 원하는 값을 채워 topic publish가 가능하게 해주는 툴입니다. 최종 publish를 위해 체크박스를 클릭하고, 원하는 값을 채워넣습니다. ROS Bridge 강의노트를 작성하고 있는 2023년 지금도 ROS 1으로 개발된 시스템에 종속성을 가진 기업들과 프로젝트들이 많습니다. ROS 1과 ROS 2를 같이 사용할 수는 없을까요? ros1 bridge를 실습해봅시다.\n일전, ROS 1에서 사용하던 smb gazebo를 오랜만에 실행시켜봅시다. roslaunch smb_gazebo smb_gazebo.launch ros1 bridge를 통해 ROS 2 시스템에서 로봇을 제어해보겠습니다. 새로운 터미널을 열고, 초기 옵션 선택 시 3번을 선택하면 ros1 bridge가 실행됩니다. (이 동작은 사실 dynamic_bridge를 실행시키는 것입니다.) sudo apt install ros-foxy-ros1-bridge -y # Terminal 1 - ros bridge ros2 run ros1_bridge dynamic_bridge # Terminal 2 - ros2 foxy ros2 run teleop_twist_keyboard teleop_twist_keyboard ROS 2로 설정된 터미널에서 ROS 1으로 구동되고 있는 로봇을 조종할 수 있습니다. ros bridge가 있으니 ROS 2 개발을 굳이 하지 않아도 된다고 생각할 수 있습니다. 하지만 보안, 지연과 같은 ROS 1의 고질적인 문제들은 여전히 남아있게 되므로 프로젝트를 시작하는 단계라면, ROS 2로 모든 개발을 진행하시길 추천드립니다. image from : swri.org 참고로, /opt/ros/\u0026lt;ros-version\u0026gt;/setup.bash는 ROS 시스템을 사용하기 위해서 필요한 설정이 담긴 파일입니다. 혹여나 galactic, humble과 같이 최신 버전을 사용하고 싶을 때 참고하시기 바랍니다.\nROS 1과 ROS 2를 모두 관리하기에는 많은 노력이 필요하고, 원하는 기능이 모두 동작하지 않을 수 있습니다. 이전 버전 legacy가 있는 경우, 잘 판단하여 시스템을 유지/보수합시다.\nMy Gazebo World Topic의 응용으로 Gazebo를 사용하여 나만의 장애물을 만들고, 충돌을 회피하는 코드를 작성해보고자 합니다. 이를 위해 Gazebo의 Building Editor 사용법을 알려드리겠습니다.\ngazebo를 실행시킨 뒤, 상단 Edit 옵션에서 Building Editor를 실행합니다. 상단 모눈종이에 스케치를 통해 건물 벽을 생성할 수 있으며, 하단 view를 통해 실시간으로 업데이트되는 건물을 확인할 수 있습니다. 혹여 실수를 했거나, 보다 정확한 수치를 입력하고 싶은 경우, 모눈종이 위의 검은 선을 더블 클릭하면 사진과 같이 구체적인 설정을 변경할 수 있는 탭이 등장합니다. 수정이 완료되었다면, 왼쪽 탭에서 door, stairs도 사용해보고, Texture도 입혀봅시다. 모든 작업을 마친 뒤, File 탭에서 Save As를 선택하여 완성한 물체를 저장합니다. (저는 wall 이라는 이름으로 저장해보겠습니다.) 저장된 폴더 내부는 다음과 같은 구조를 갖게 됩니다. ├─ wall ├── model.config └── model.sdf model.config : 해당 model의 이름, 작성자 등 기본적인 정보들이 기입됩니다. model.sdf : 실직적인 sdf 형식의 모델이 위치합니다. 작성한 물체를 Gazebo에서 두고두고 사용하는 몇가지 방법들이 있습니다.\nGAZEBO_MODEL_PATH에 추가하기 ⇒ ~/.gazebo/gui.ini 파일 내 model_paths에 building 폴더에 절대 경로를 추가합니다. $ gedit ~/.gazebo/gui.ini [geometry] x=0 y=0 [model_paths] filenames=/home/kimsooyoung/\u0026lt;your-folder-location\u0026gt; launch file에서 GAZEBO_MODEL_PATH 수정하기 ⇒ 대신 이렇게 하면 해당 launch file 사용 시에만 GAZEBO_MODEL_PATH가 반영됩니다. if \u0026#39;GAZEBO_MODEL_PATH\u0026#39; in os.environ: os.environ[\u0026#39;GAZEBO_MODEL_PATH\u0026#39;] += \u0026#34;:\u0026#34; + gazebo_model_path else: os.environ[\u0026#39;GAZEBO_MODEL_PATH\u0026#39;] = gazebo_model_path 이제 Gazebo를 실행시키면, 사진과 같이 Insert 부분에 building이 추가되어있음을 확인 가능합니다. 이를 클릭 후 gazebo 환경으로 커서를 옮기면 원하는 위치에 wall을 위치시킬 수 있습니다. wall이 추가된 world는 별도로 저장해줘야 합니다. File ⇒ Save World As를 클릭하면 완성된 world 파일을 저장합시다. 생성한 world 파일을 launch 파일로 실행해봅시다.\n저장해두었던 Gazebo world 파일을 src_gazebo의 worlds 폴더에 위치시킵니다. launch 파일을 수정하여 새로운 world 파일의 위치를 전달합니다.\ndef generate_launch_description(): ... # gazebo pkg_gazebo_ros = FindPackageShare(package=\u0026#39;gazebo_ros\u0026#39;).find(\u0026#39;gazebo_ros\u0026#39;) pkg_path = os.path.join(get_package_share_directory(\u0026#39;src_gazebo\u0026#39;)) world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;여러분의-world-file.world\u0026#39;) ... # Start Gazebo server start_gazebo_server_cmd = IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(pkg_gazebo_ros, \u0026#39;launch\u0026#39;, \u0026#39;gzserver.launch.py\u0026#39;)), launch_arguments={\u0026#39;world\u0026#39;: world_path}.items() ) package를 빌드하고, gazebo를 다시 실행해봅시다. colcon build --packages-select src_gazebo source install/local_setup.bash ros2 launch src_gazebo empty_world.launch.py 제작한 world와 로봇이 함께 등장하는 것을 확인할 수 있습니다. 최대한 여러분들만의 장애물을 만들어보시고, 혹시나 이 과정에서 도저히 모르겠는 오류가 발생했거나, 시간이 없는 경우, 우선 제가 제작한 world와 launch file을 사용하도록 합니다. ⇒ ros2 launch src_gazebo wall_world.launch.py\nROS 2 Topic 프로그래밍 example1 - cmd_vel publish 준비된 예시를 우선 실행해봅시다. # Terminal 1 ros2 launch src_gazebo empty_world.launch.py # Terminal 2 cd ~/ros2_ws colcon build --packages-select py_topic_tutorial source install/local_setup.bash ros2 run py_topic_tutorial topic_pub_node 로봇이 원을 그리며 움직이기 시작합니다. ROS 1 강의를 완료하였다면 어떻게 구현하였을지 아시겠지요? 코드를 살펴보겠습니다 - 시작으로, 필요한 파이썬 패키지들을 import 합니다. ROS 2에서 파이썬 프로그래밍을 하기 위해서는 rclpy를 import 해야 합니다. 더불어, Twist를 import하는 문법도 눈여겨봅시다. import random from geometry_msgs.msg import Twist import rclpy from rclpy.node import Node 핵심이 되는 TwistPubNode 클래스의 생성자부터 살펴보겠습니다. class TwistPubNode(Node): def __init__(self): super().__init__(\u0026#39;twist_pub_node\u0026#39;) self.get_logger().info( f\u0026#39;TwistPubNode Created at {self.get_clock().now().to_msg().sec}\u0026#39; ) # self.twist_publisher = self.create_publisher(Twist, \u0026#34;twist_topic\u0026#34;, 10) self.twist_publisher = self.create_publisher(Twist, \u0026#39;/cmd_vel\u0026#39;, 10) create_publisher는 topic publisher를 생성하는 함수로 3개의 매개변수를 받으며 각각에 대한 설명은 다음과 같습니다.\nmessage type : Topic 통신에 사용될 msg Type 입니다. topic name : 사용할 Topic 이름을 지정합니다. (이 이름을 잘못 설정하면 존재하지 않는 topic에 Publish하는 오류 상황이 발생하니 주의합니다.) queue_size : 대기열의 크기라고 이해하시면 좋습니다. timer callback에서 publish가 이루어집니다. 생성한 publisher에서 publish 함수를 사용하며 매개변수로 message가 전달됩니다. ... self.create_timer(0.2, self.timer_callback) def timer_callback(self): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; msg = Twist() # Fill in msg with compatible values msg.linear.x = 0.5 msg.angular.z = 1.0 self.twist_publisher.publish(msg) example2 - scan subscription 이번 예시는 라이다 데이터를 다뤄보고자 합니다. 명령어를 실행해봅시다. # Terminal 1 $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ ros2 run py_topic_tutorial topic_sub_node [INFO] [1672494602.141200628] [scan_sub_node]: msg.ranges[0] : inf msg.ranges[30] : inf msg.ranges[60] : 0.7975894212722778 msg.ranges[90] : inf msg.ranges[119] : inf ... 예시를 실행시킨 상황에서 Gazebo 상의 로봇 주변으로 물체를 등장시켜봅시다.\nscan data의 ranges는 사진과 같은 거리 데이터를 담고 있답니다.\n코드를 살펴봅시다. 이번에는 sensor_msgs/msg/LaserScan이 사용되었습니다. import rclpy from rclpy.node import Node from sensor_msgs.msg import LaserScan ScanSubNode 클래스의 생성자에서는 scan topic의 subscriber가 생성됩니다. class ScanSubNode(Node): def __init__(self): super().__init__(\u0026#39;scan_sub_node\u0026#39;) queue_size = 10 # Queue Size self.pose_subscriber = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, queue_size ) create_subscription은 4개의 매개변수를 받으며 각각에 대한 설명은 다음과 같습니다.\nMessage Type : Topic 통신에 사용될 msg Type 입니다. topic name : 데이터를 Subscribe할 Topic의 이름을 지정합니다. (이 이름을 잘못 설정하면 아무것도 publish하고 있지 않는 topic을 마냥 기다리고 있게 되는 상황이 발생할 것입니다.) subscribe callback : 데이터가 전달될 때마다 실행되는 callback 함수로, 전달된 데이터를 통해 실행할 작업이 이 함수 안에 구현됩니다. queue_size : create_publisher때와 마찬가지로, 대기열의 크기라고 이해하시면 좋습니다. sub_callback의 첫번쨰 매개변수는 항상 topic message data가 됩니다. 해당 message에서 원하는 데이터만 추출한 다음, logger를 통해 콘솔 출력을 진행합니다.\ndef sub_callback(self, msg): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; self.get_logger().info(f\u0026#39; \\ \\nmsg.ranges[0] : {msg.ranges[0]} \\ \\nmsg.ranges[30] : {msg.ranges[30]} \\ \\nmsg.ranges[60] : {msg.ranges[60]} \\ \\nmsg.ranges[90] : {msg.ranges[90]} \\ \\nmsg.ranges[119] : {msg.ranges[119]} \\ \u0026#39;) example3 - parking 이번 예시를 실행하기 전에, empty_world.launch.py를 수정해야 합니다. # gazebo pkg_gazebo_ros = FindPackageShare(package=\u0026#39;gazebo_ros\u0026#39;).find(\u0026#39;gazebo_ros\u0026#39;) pkg_path = os.path.join(get_package_share_directory(\u0026#39;src_gazebo\u0026#39;)) # world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;empty_world.world\u0026#39;) world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;wall_world.world\u0026#39;) 물체와 충돌하기 전까지 로봇을 움직이다가 일정 거리 내 벽이 검출되면 자동으로 멈추는 예시입니다. # Terminal 1 $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ ros2 run py_topic_tutorial parking_node ... [INFO] [1672563255.067421128] [parking_node]: Distance from Front Object : 0.6280616521835327 [INFO] [1672563255.173734128] [parking_node]: Distance from Front Object : 0.5546504259109497 [INFO] [1672563255.281276729] [parking_node]: Distance from Front Object : 0.5124648809432983 [INFO] [1672563255.389067729] [parking_node]: ==== Parking Done!!! ==== ... 이 기능을 구현하기 위해서는 Topic Publish와 Subscribe가 모두 필요합니다.\n/cmd_vel topic publish /scan topic subscribe ⇒ 따라서, Node의 생성자에서도 Publisher와 Subscriber를 모두 생성합니다.\nclass ParkingNode(Node): def __init__(self): super().__init__(\u0026#39;parking_node\u0026#39;) queue_size = 10 # Queue Size self.twist_publisher = self.create_publisher(Twist, \u0026#39;cmd_vel\u0026#39;, queue_size) self.scan_subscriber = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, queue_size ) sub_callback에서는 전방 (msg.ranges[60]) 물체와의 거리를 탐지하고, 이 거리가 0.5m 이하가 되면 정지 topic을 publish 합니다. def sub_callback(self, msg): twist_msg = Twist() distance_forward = msg.ranges[60] if distance_forward \u0026gt; 0.5: self.get_logger().info(f\u0026#39;Distance from Front Object : {distance_forward}\u0026#39;) twist_msg.linear.x = 0.5 self.twist_publisher.publish(twist_msg) else: self.get_logger().info(\u0026#39;==== Parking Done!!! ====\\n\u0026#39;) twist_msg.linear.x = 0.0 self.twist_publisher.publish(twist_msg) CV 2 and ROS 2 Topic과 ROS 2 Bag을 사용한 예시를 실행해보고자 합니다.\n이번 실습을 위해 제가 미리 준비한 데이터셋을 제공드리니, 기억하기 쉬운 위치에 다운받아 주세요.\n📁 quadrupped_train.zip\nWindows + WSL2 유저의 경우 explorer.exe 명령어를 통해 파일 탐색기를 열 수 있습니다.\n준비된 예시를 실행해봅시다. # 예제 실행 준비 sudo apt install ros-foxy-rosbag2 cd ~/ros2_ws colcon build --packages-select py_cv_tutorial source install/local_setup.bash # 터미널 1 – 데이터 위치로 이동하여 ros2 bag 실행 cd \u0026lt;데이터를 저장한 위치\u0026gt; ros2 bag play quadrupped_train.bag_0.db3 # 터미널 2 – image_view 실행 ros2 run rqt_image_view rqt_image_view 사진과 같이 기차 선로 모습이 보인다면 성공입니다. 해당 데이터셋은 기차 선로에서 주행하는 4족 보행 로봇으로부터 취득한 것입니다. 기차 선로는 주기적으로 관리가 필요하며, 길고 긴 선로를 로봇이 자동으로 검사해준다면 아주 유용할 것입니다. 이러한 상상을 해보면서 실습에 임해봅시다.\nExample1 - CV Bridge 이미지를 다루기 위한 오픈소스 라이브러리인 OpenCV를 사용해보려 합니다. 준비된 예시와, ros2 bag 파일을 실행하면 cv2.imshow를 통해 연속된 이미지를 확인할 수 있습니다.\n# 터미널 1 $ cd \u0026lt;bag 파일 위치\u0026gt; $ ros2 bag play quadruped_train/quadruped_train.bag_0.db3 [INFO] [1667077909.362223100] [rosbag2_storage]: Opened database \u0026#39;quadrupped_train/quadrupped_train.bag_0.db3\u0026#39; for READ_ONLY. # 터미널 2 $ ros2 run py_cv_tutorial img_sub [INFO] [1667077909.613586300] [image_subscriber]: Receiving video frame [INFO] [1667077910.934147000] [image_subscriber]: Receiving video frame ... OpenCV에서는 CV::Mat 이라는 특정 타입을 사용합니다. 이를 ROS 2의 Topic Message로 변환하기 위해서 CV Bridge라는 것을 사용합니다. from cv_bridge import CvBridge # Package to convert between ROS and OpenCV Images import cv2 # OpenCV library class ImageSubscriber(Node): def __init__(self): # Used to convert between ROS and OpenCV images self.br = CvBridge() ... def listener_callback(self, data): ... # Convert ROS Image message to OpenCV image current_frame = self.br.imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) edge_frame = self.hough_transform(current_frame) imgmsg_to_cv2를 통해 CV::Mat으로 변환된 이미지 데이터를 OpenCV의 다양한 기능들과 함께 사용할 수 있습니다. 코드의 imshow 부분을 바꿔서 이미지 처리를 적용해 봅시다. 직선을 검출하는 알고리즘이며, 매개변수의 최적화를 통해 선로를 인지할 수 있습니다. 직선 검출을 위해 사용된 OpenCV 기능들은 아래와 같습니다. 로직을 업그레이드하여 여러분만의 선로 검출 알고리즘을 만들어 보세요!\ncv2.GaussianBlur cv2.fillPoly / cv2.bitwise_and ROI 설정 cv2.HoughLinesP rosbag to img 컴퓨터 비전만으로 완벽한 선로 인식을 구현하기는 너무나 힘듭니다. 딥러닝을 사용해서 이를 극복할 수 있을 것이며, 데이터셋의 제작을 위해 rosbag 데이터에서 이미지를 추출하는 예시를 준비하였습니다.\n$ ros2 run py_cv_tutorial rosbag2_to_timedimg /home/kimsooyoung/djhrd_ws/quadrupped_train/quadrupped_train.bag_0.db3 saved: color_1666796292992515592.png saved: color_1666796293035428479.png saved: color_1666796293079139778.png saved: color_1666796293120768031.png 예제 실행 전 main 함수에서 bag 파일의 위치를 여러분의 것으로 수정해야 합니다. def main(args=None): # Change below roots to your ros2 bag locations ROOT_DIR = \u0026#34;/home/kimsooyoung/djhrd_ws/quadrupped_train\u0026#34; FILENAME = \u0026#34;/quadrupped_train.bag_0.db3\u0026#34; DESCRIPTION = \u0026#34;color_\u0026#34; 예제 실행 후 사진과 같이 기차 생성된 이미지들이 보인다면 성공입니다. "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture6/",
	"title": "Lecture6 - ROS 2 Service and Examples",
	"tags": [],
	"description": "",
	"content": "ROS 2 Service ROS Service의 개념을 다시 복습해봅시다.\nimage from : docs.ros.org Service 개념 정리\nService를 요청하는 주체를 Service Client라고 하며, Service 요청 자체를 Request, 혹은 Call이라고 합니다. Service를 요청받는 주체를 Service Server라고 하며, Service Server는 Request에 대한 응답, 즉 Service Response를 다시 Service Client에게 회답합니다. Request와 Response를 위해 사용되는 데이터 타입은 srv라고 하며 Request와 Response로 나뉩니다. Service의 중요한 특징 한 가지 추가하자면, 하나의 Service Server에 여러 Client가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지 못합니다.\nimage from : docs.ros.org ROS Service 커멘드 라인 지난 topic 예시와 같이 ROS 1에서 ROS 2로 넘어오면서 변경된 커멘드 라인들을 살펴보겠습니다.\nrosservice list ⇒ ros2 service list ros2 service info는 없으며, ros2 service type으로 변경되었습니다. srv는 ros2 interface show로 조회 가능합니다. $ ros2 interface show turtlesim/srv/Spawn float32 x float32 y float32 theta string name # Optional. A unique name will be created and returned if this is empty --- string name 서비스 타입 중간에 보이는 - - - 부분은 request와 response의 구분자라고 생각하시면 됩니다.\nService Example - 📸 KimChi Service 이번에 보여드릴 ROS 2 service 예시는 사진을 찍는 service server입니다.\n예시 실행 - rqt를 통해 service call이 성공하면 현재 시간에 해당하는 파일이름으로 로봇이 바라보는 시야의 카메라 이미지가 PNG 형식으로 저장됩니다. # Terminal 1 - 여러분들만의 world를 사용하시면 더욱 좋습니다. $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ colcon build --packages-select py_service_tutorial $ source install/local_setup.bash $ ros2 run py_service_tutorial take_picture_server [INFO] [turtle_circle_server]: Picture Taking Node Started [INFO] [turtle_circle_server]: KimChi~ [INFO] [turtle_circle_server]: Image saved in 1672569224.png # Terminal 3 - rqt 실행 후 service caller 실행 (plugins =\u0026gt; services =\u0026gt; service caller) $ rqt Service Caller의 사용법과 결과는 다음과 같습니다. 코드를 살펴보기 전에, 이를 어떻게 구현할 수 있을지 같이 생각해봅시다.\n사진 촬영을 포함하는 Service Server 필요 로봇 전방 image data의 Subscriber 필요 ROS의 sensor_msgs/msg/Image를 저장 가능한 포멧으로 변경 필요 따라서, Node의 생성자는 다음과 같이 작성합니다.\nclass PictureNode(Node): def __init__(self): super().__init__(\u0026#39;turtle_circle_server\u0026#39;) self.server = self.create_service( SetBool, \u0026#39;take_picture\u0026#39;, self.take_picture_callback ) self.subscriber = self.create_subscription( Image, \u0026#39;logi_camera_sensor/image_raw\u0026#39;, self.sub_callback, 10 ) self.br = CvBridge() self.is_request = False 이번에 사용하는 srv는 example_interfaces/srv/SetBool이며, Bool Type의 request와 String response를 갖고 있습니다. $ ros2 interface show example_interfaces/srv/SetBool # This is an example of a service to set a boolean value. # This can be used for testing but a semantically meaningful # one should be created to be built upon. bool data # e.g. for hardware enabling / disabling --- bool success # indicate successful run of triggered service string message # informational, e.g. for error messages service call에 대한 callback입니다. is_request를 바꿔주기만 하는데, 이것이 하는 역할이 무엇일지 생각해보세요. def take_picture_callback(self, request, response): if request.data is True: self.get_logger().info(\u0026#39;KimChi~\u0026#39;) self.is_request = True response.success = True response.message = \u0026#34;Successfully image written\u0026#34; return response 정답은 subscription callback에서 찾을 수 있습니다. subscribe된 이미지 데이터는 is_request가 True인 순간에만 사용됩니다. CV Bridge를 통해 ROS topic을 OpenCV 포맷으로 바꿀 수 있으며, imwrite를 통해 이미지를 저장할 수 있습니다. def sub_callback(self, data): if self.is_request: current_frame = self.br.imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) file_name = str(self.get_clock().now().to_msg().sec) + \u0026#39;.png\u0026#39; cv2.imwrite(file_name, current_frame) self.get_logger().info(f\u0026#39;Image saved in {file_name}\u0026#39;) self.is_request = False Gazebo에 다양한 물체를 배치시킨 뒤 사진을 찍어보는 것도 좋은 실습이 될 것입니다. 제가 준비한 dataset을 사용하여 여러분들만의 실습도 해보세요.\n📁 3DGEMS.zip\n제공되는 3DGEMS 폴더를 압축해제한 뒤, ~/.gazebo/models 폴더에 위치시킵니다. 해당 모델들의 출처는 다음과 같습니다. (\u0026ldquo;The Effect of Color Space Selection on Detectability and Discriminability of Colored Objects.\u0026rdquo; arXiv preprint arXiv:1702.05421 (2017).)\nWSL2를 사용하시는 분들께서는 터미널에서 explorer.exe . 를 입력하면 윈도우 파일 탐색기를 실행 가능합니다.\n다시 한 번 Gazebo를 실행시킨 뒤 새로 추가된 모델들을 사용해봅시다. Server Client Example - Spawn Model 이번 예시는 ROS 1강의에서도 살펴본 바 있는, urdf를 사용하여 gazebo 상에 물체를 등장시키는 예시입니다.\n예시 실행 ros2 launch src_gazebo wall_world.launch.py Gazebo에서 일정한 간격을 두고, 하얀색 박스가 등장하게 됩니다. 매번 박스가 등장할 때마다 service call이 이루어지는 것이지요.\nROS 1에서의 예시와 기능은 동일하므로 중요한 코드들만 간단히 분석해봅시다. 사용하는 srv는 gazebo_msgs/srv/SpawnEntity 입니다. from gazebo_msgs.srv import SpawnEntity import rclpy from rclpy.node import Node create_client를 통해 Service Client를 생설할 수 있습니다. class SpawnRobot(Node): def __init__(self): super().__init__(\u0026#39;gazebo_model_spawner\u0026#39;) self.client = self.create_client(SpawnEntity, \u0026#39;spawn_entity\u0026#39;) while not self.client.wait_for_service(timeout_sec=1.0): self.get_logger().error(\u0026#39;service not available, waiting again...\u0026#39;) create_client의 매개변수는 각각 다음과 같습니다.\nService srv type - SpawnEntity Service server 이름 - \u0026lsquo;spawn_entity\u0026rsquo; main문은, 일반적인 node 실행과 다소 차이를 보입니다. Future라는 개념을 사용하여 이벤트 기반 spin을 구현하였습니다.\nfuture = robot_spawn_node.send_req() rclpy.spin_until_future_complete(robot_spawn_node, future) if future.done(): try: response = future.result() except Exception: raise RuntimeError( \u0026#39;exception while calling service: %r\u0026#39; % future.exception() ) else: robot_spawn_node.get_logger().info(\u0026#39;==== Service Call Done ====\u0026#39;) robot_spawn_node.get_logger().info(f\u0026#39;Status_message : {response.status_message}\u0026#39;) finally: robot_spawn_node.get_logger().warn(\u0026#39;==== Shutting down node. ====\u0026#39;) 친구와 명확한 약속을 했다면, 그동안 다른 일을 할 수 있는 것처럼 Future는, 효율적인 비동기 프로그래밍을 위해 사용됩니다.\nimage from : brunch.co\nservice call이 이루어지는 send_req에서 이 Future를 반환하고 있습니다. def send_req(self): ... self.future = self.client.call_async(self.req) return self.future launch file을 보면 gazebo의 실행을 비롯하여 spawn_model node도 함께 실행됩니다. 그래서 gazebo가 등장하자마자 하얀 박스들이 생성되었던 것입니다. spawn_parking_lot = Node( package=\u0026#39;py_service_tutorial\u0026#39;, executable=\u0026#39;spawn_model\u0026#39;, name=\u0026#39;spawn_model\u0026#39;, output=\u0026#39;screen\u0026#39; ) 이 예시는 다음 Action에서도 활용되므로 잘 기억해두시기 바랍니다.\nCustom Interface와 코딩 과제 - Turtle Jail ROS 2에서 custom interface를 만들기 위해서는 C++ Package에서 작업이 이루어져야 합니다. C++ package는 build type ament_cmake를 사용하는 package였습니다.\n$ ros2 pkg create --build-type ament_cmake \u0026lt;package-name\u0026gt; $ ros2 pkg create --build-type ament_cmake custom_interfaces 해당 패키지 내 action, msg, srv 라는 폴더를 만들고 해당 폴더 안에 나만의 인터페이스를 작성합니다. 사용할 수 있는 기본 데이터 형식들은 이 링크를 참고합니다.\n이번에 만들어볼 custom interface는 다음 과제와 연결됩니다. 우선 저를 따라와 주세요.\nsrv라는 폴더를 만들고, TurtleJail.srv라는 파일을 생성하여 아래와 같은 내용을 작성합니다. float32 width float32 height --- bool success 해당 interface를 rclpy, rclcpp에서 사용 가능하도록 해봅시다. ROS 2는 DDS의 IDL(Interface Description Language)를 사용하여 다양한 언어에서 사용 가능한 데이터 타입을 만들 수 있습니다.\nCMakeLists.txt 수정 find_package(rosidl_default_generators REQUIRED) rosidl_generate_interfaces(${PROJECT_NAME} \u0026#34;msg/Num.msg\u0026#34; \u0026#34;srv/AddThreeInts.srv\u0026#34; \u0026#34;srv/TurningControl.srv\u0026#34; \u0026#34;srv/TurtleJail.srv\u0026#34; \u0026#34;action/Fibonacci.action\u0026#34; \u0026#34;action/Maze.action\u0026#34; ) package.xml 수정 \u0026lt;build_depend\u0026gt;rosidl_default_generators\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rosidl_default_runtime\u0026lt;/exec_depend\u0026gt; \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; 패키지 빌드 $ colcon build --packages-select custom_interfaces \u0026amp;\u0026amp; rosfoxy Starting \u0026gt;\u0026gt;\u0026gt; custom_interfaces Finished \u0026lt;\u0026lt;\u0026lt; custom_interfaces [0.62s] Summary: 1 package finished [0.84s] 이제 ROS 2에서 해당 인터페이스를 사용할 수 있습니다 (단, 해당 workspace를 바라보게 해야 합니다.) $ ros2 interface show custom_interfaces/srv/TurtleJail float32 width float32 height --- bool success custom interface의 사용 시 파이썬 패키지에서는 별도 작업 없이 사용 가능하지만 C++ 패키지는 코딩 시 CMakeLists.txt의 수정이 필요합니다. 이는 다소 난이도가 있어 강의에서 살피지는 않고 링크를 남겨두겠습니다.\nhttps://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Custom-ROS2-Interfaces.html#id10 Assignment - Turtle Jail topic과 service에 대해서 모두 살펴본 지금 상황에서 여러분들께 코딩 과제를 제시해보고자 합니다. 이번 코딩 과제에서 구현해야 하는 최종 결과는 다음과 같습니다.\nrqt를 통해 turtle_jail_size service call을 하며, 감옥의 사이즈를 설정합니다.\n거북이는 감옥을 벗어날 수 없으며, 감옥을 벗어나는 순간 원점으로 순간이동합니다.\n터미널에서 실행하는 절차는 다음과 같습니다. # Terminal 1 – turtlesim실행 ros2 run turtlesim turtlesim_node # Terminal 2 - turtle_teleop 실행 ros2 run turtlesim turtle_teleop_key # Terminal 3 - 과제 프로그램 실행 ros2 run py_service_tutorial turtle_jail [INFO] [turtle_jail_node]: === [Service Client : Ready to Call Service Request] === [INFO] [turtle_jail_node]: ==== [Service Server : Ready to receive Service Request] ==== # Terminal 4 - rqt의 service caller 실행 후 /turtle_jail_size에게 service call cd ~/ros2_ws source install/local_setup.bash rqt 이번 예시는 custom interface를 사용하므로 local_setup.bash를 꼭 실행해주세요!\n이 예시에서는 topic과 service를 모두 사용해야 합니다. 지금까지 학습한 내용들을 확인해볼 수 있는 좋은 기회가 될 것입니다.\n힌트1 : turtlesim의 좌표계 힌트 2 : 거북이를 순간이동시키기 위해 /turtle1/teleport_absolute service를 사용하세요. "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture7/",
	"title": "Lecture7 - Useful ROS 2 Example, Navigation2",
	"tags": [],
	"description": "",
	"content": " 코딩을 시작하기 전에 구현해야 하는 기능들과 Topic, Service 기준 input, output을 정리해봅시다.\nPart 1 - 감옥 구현 거북이가 일정 범위를 벗어나게 되면 다시 원위치로 돌아오게 한다.\n거북이의 위치는 /turtle1/pose topic subscribe을 통해 얻을 수 있습니다. 거북이가 일정 위치를 벗어나는 순간, 원위치로 돌아오게 하는 /turtle1/teleport_absolute service call을 해야 합니다. 이를 위한 service client가 필요합니다. Part 2 - 감옥 크기 변경 사용자로부터 감옥의 크기를 변경해달라는 service request가 오면 기존 감옥의 크기를 변경하는 작업이 필요하다.\n/turtle_jail_size service server를 구현해야 합니다. 감옥의 크기가 변경되면 topic 로직에도 반영되어야 하므로 OOP의 형태로 구현이 필요할 듯 합니다. 코드를 구현하기 위해 필요한 topic, service interface들을 조회합시다.\n$ ros2 interface show custom_interfaces/srv/TurtleJail float32 width float32 height --- bool success $ ros2 interface show turtlesim/ srv/TeleportAbsolute float32 x float32 y float32 theta --- $ ros2 interface show turtlesim/msg/Pose float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity 모든 필요조건들을 알게 되었습니다. 이제 프로그래밍을 해보겠습니다.\n필요 파이썬 패키지 import import rclpy from rclpy.node import Node from turtlesim.msg import Pose from turtlesim.srv import TeleportAbsolute from custom_interfaces.srv import TurtleJail Service Server, Service Client, Topic Subscriber 생성 # Create Turtle teleport client self.client = self.create_client(TeleportAbsolute, \u0026#39;turtle1/teleport_absolute\u0026#39;) while not self.client.wait_for_service(timeout_sec=1.0): self.get_logger().info(\u0026#39;Service not available, Waiting again...\u0026#39;) self.request_srv = TeleportAbsolute.Request() self.get_logger().info(\u0026#39;=== [Service Client : Ready to Call Service Request] ===\u0026#39;) # Create Subscriber for turtle1/pose queue_size = 10 # Queue Size self.pose_subscriber = self.create_subscription( Pose, \u0026#39;turtle1/pose\u0026#39;, self.sub_callback, queue_size ) # Create Service Server for User Interfaces self.srv = self.create_service( TurtleJail, \u0026#39;turtle_jail_size\u0026#39;, self.turtle_jail_callback ) self.get_logger().info(\u0026#39;==== [Service Server : Ready to receive Service Request] ====\u0026#39;) 클래스 변수 선언 (감옥 사이즈, 벽에 도달하기 전 거북이의 각도) # Preserve its rotation before teleport self.cur_theta = 0.0 # jail size in rectangular form self.jail_width = 6.0 self.jail_height = 6.0 topic subscribe와 service server에 대한 callback이 두 개 필요합니다.\n거북이의 Pose Topic Subscribe Callback def sub_callback(self, msg): \u0026#34;\u0026#34;\u0026#34;Turtle Pose Subscriber Callback\u0026#34;\u0026#34;\u0026#34; if abs(msg.x - 6.0) \u0026gt; self.jail_width or abs(msg.y - 6.0) \u0026gt; self.jail_height: self.cur_theta = msg.theta self.get_logger().warn(\u0026#34;You can\u0026#39;t go out Turtle! :(\u0026#34;) self.send_request() 감옥 사이즈 변경 요청 시 발생하는 Service Server Callback def turtle_jail_callback(self, request, response): \u0026#34;\u0026#34;\u0026#34;Service Server for jail resizing client request\u0026#34;\u0026#34;\u0026#34; self.jail_width = request.width self.jail_height = request.height self.get_logger().info(f\u0026#34;\u0026#34;\u0026#34;Jail Size Update to {self.jail_width}/{self.jail_height}\u0026#34;\u0026#34;\u0026#34;) response.success = True return response 마지막으로, 거북이를 원점으로 이동시켜달라는 service request를 구현합니다. def send_request(self): \u0026#34;\u0026#34;\u0026#34;Service Clinet request fuction\u0026#34;\u0026#34;\u0026#34; self.request_srv.x = 6.0 self.request_srv.y = 6.0 self.request_srv.theta = self.cur_theta self.future = self.client.call_async(self.request_srv) return self.future 바로 코딩을 시작하지 말고, 무엇을 구현해야 하는지 적어보는 것, 조금씩 조금씩 구현한 뒤, 확인하면서 개발하는 것, ROS 뿐만 아니라 앞으로의 프로그래밍에서 반드시 잊지 마시기 바랍니다.\nNavigation 2 이번 시간에는 유용한 ROS 2 프로젝트를 소개하고, 관련된 내용을 함께 살펴보고자 합니다. ROS 2의 자율 주행 메타페키지인 Navigation 2, Nav2 입니다.\nimage from : https://navigation.ros.org\nNav 2는 삼성 리서치 아메리카의 Steven Macenski의 주도 하에 개발되고 있으며, 아래와 같은 자율주행을 위해 필요한 거의 모든 기능들을 집합해둔 프로젝트입니다.\n지도 저장, 전송, 관리 (Map Server) 지도 상에서 로봇의 위치 파악하기 (AMCL) A to B 주행을 위한 경로 생성 (Nav2 Planner) 경로를 따라 로봇을 이동시키기 위한 컨트롤 시스템 (Nav2 Controller) 주행 경로의 최적화 (Nav2 Smoother) Costmap 생성과 센서 데이터 반영 (Nav2 Costmap 2D) Behavior Tree를 통한 복잡한 주행 시나리오 핸들링 (Nav2 Behavior Trees and BT Navigator) 주행 실패를 방지하기 위한 recovery behaviors (Nav2 Recoveries) Waypoints 주행 (Nav2 Waypoint Follower) Nav2 Node들의 모니터링과 관리 (Nav2 Lifecycle Manager) 커스텀 알고리즘 개발을 위한 Plugins (Nav2 Core) 일반 개발자나 기업이 자율주행을 구현하기 위해서는 이렇게 많은 것들이 필요합니다. 하지만, ROS 2를 사용한다면 Nav 2를 통해 많은 시간을 단축할 수 있지요!\n이 강의에서 모든 내용을 다루고 싶지만, 시간적 한계가 있기 때문에 예시를 통해 로봇 자율주행에 대한 개념을 체감해보도록 하겠습니다.\nNav 2 Example 1 - SLAM_ToolBox 처음 가보는 환경을 맞닥뜨리면, 우리는 주변 상황을 탐색하고 내 위치를 파악하려 할 것입니다. 이것을 로보틱스에서는 SLAM - Simultaneous localization and mapping이라고 이야기합니다.\nSLAM Toolbox는 Steven Macenski에 의해 제작된 ROS 2 패키지이며 backend와 frontend SLAM 알고리즘 뿐만 아니라, ROS 2와 호환되는 관리 도구, 최적화까지 담고 있습니다. 예시를 통해 SRC 로봇으로 SLAM을 실습해봅시다. 로봇을 이동시키면서 rviz에 갱신되는 지도를 확인합니다. colcon build --packages-select src_slam colcon build --packages-select src_odometry source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo racecourse.launch.py use_rviz:=false # Terminal 2 ros2 launch src_slam src_slam_gazebo_slam_toolbox.launch.py 지도를 저장하는 두 가지 방법이 있습니다.\nrviz plugin 사용 - RViz상의 공란에 지도를 저장할 위치를 포함한 절대경로를 기입하고 왼쪽 “Save Map” 버튼을 눌러 최종 지도를 추출합니다. 커멘드 라인 사용 - 저장 위치가 존재하는지 확인 후 실행하세요. ros2 run nav2_map_server map_saver_cli -f \u0026lt;map_dir\u0026gt;/\u0026lt;map_name\u0026gt; 저장 결과로 두 가지 파일이 생성되며, 이러한 지도 데이터를 관리해주는 것이 Nav 2의 Map Server 입니다. 지도 이미지 파일 지도 정보를 담은 yaml 파일 Localization 로봇의 현재 위치와 방향을 파악하는 것을 localization이라고 부릅니다.\nNav2의 AMCL 패키지는 주어진 맵을 기반으로 Adaptive Monte Carlo Localization 방식을 사용하여 로봇의 위치를 파악합니다.\nimage from : wikipedia\n이 Adaptive Monte Carlo Localization은 입자(Particle)를 사용하여 로봇의 위치를 파악하는 방식이며, 이 입자들은 실제 로봇처럼 주어진 가중치와 함께 그들만의 좌표와 방향 값을 가지고 있게 됩니다.\n로봇이 주어진 환경에서 이동하여 새 센서 데이터를 제공할 때마다 입자가 다시 샘플링되며, 각 샘플링에서 가중치가 작은 입자는 소멸되고 가중치가 큰 입자는 더 커지면서 생존합니다.\nAMCL 알고리즘을 여러 번 반복하게 되면 입자들의 위치가 수렴하여 로봇 포즈의 근사치를 평가할 수 있고, 결국 이 로봇의 최종 방향과 위치를 추정하게 됩니다.\nNav2 Lifecycle Manager Map Server, AMCL과 같은 Nav2의 stack은 Nav2 Lifecycle Manager에 의해 관리됩니다.\nLifecycle이라는 것은 생성과 실행, 일시정지와 최종 종료와 같이 Node의 상태를 지칭합니다. image from : roscon2019\n기존 ROS 2도 lifecycle을 갖고 있지만, Nav 2는 전용 lifecycle_manager를 사용함으로 다른 node과 별도로 자율주행과 관련된 최적화된 시스템 설계가 가능해졌습니다. image from : navigation2\n하지만, ROS 2의 lifecycle이 아닌 독자적인 방식을 사용하게 됨으로 디버깅 툴 사용이 불가하다는 점이 문제점으로 대두됩니다. 이러한 이유로, nav2 개발 시에는 rqt console의 사용을 권장합니다.\nCostmap 2D 자율주행의 경로를 계산할 시, 일반적으로 구역을 나누고 장애물 여부, 충돌 가능 여부등을 점수화하여 구역별 costmap을 만듭니다.\nNav2에서도 로봇의 크기와 사용자의 정의에 따라 inflation을 적용한 costmap을 생성합니다.\nNav2의 costmap에서 각 셀의 cost는 unknown, free, occupied, inflated로 정의되고, controller, planner, recovery plugin등이 이를 사용하여 안전하고 효율적인 경로를 계산하게 됩니다. 이 costmap에는 두가지 종류가 있는데\nGlobal Costmap은 SLAM을 통해 얻은 정적 지도를 기반으로 생성되며, 벽, 가구와 같이 SLAM 당시 존재했던 장애물들에 대한 costmap입니다. Local Costmap은 로봇 주위 일정 범위에 로봇에 부착된 센서들을 기반으로 생성되며, 동적 장애물을 감지할 수 있습니다. 로봇이 이동함에 따라 매번 갱신되는 데이터입니다. 아래 사진에서 왼쪽은 Global costmap을, 오른쪽은 Local costmap을 보이고 있습니다.\ninflation의 변경에 따른 costmap의 차이는 아래와 같이 rviz 화면에서 확인할 수 있습니다. inflation을 줄이게 되면 경로 상 갈 수 있는 영역이 많아졌지만, 충돌 측면에서는 좀 더 위험해졌다고 말할 수 있습니다. 따라서, 로봇의 크기와 최대 속도, 제동거리를 고려하여 적절한 inflation radius를 설정해야 합니다.\nLocal Path와 Global Path 센서 데이터에서 장애물이 검출되었다면, local planner는 이를 회피하기 위해 기존 global planner와는 다른 별도의 경로를 따르도록 로봇에게 지시할 것입니다.\nNav2에서 물체 회피를 위해 수행되는 동작들은 다음과 같습니다.\nglobal planner가 지도를 기반으로 거시적인 경로를 계산하면 이 경로의 일부가 local planner에게 전달됩니다. local planner는 기본적으로 global Planner의 파편이지만, 현재 주행중인 환경과 센서 데이터를 입력으로 받아, 경로를 최신화합니다. global plan과 local plan은 엄연히 다른 알고리즘이 사용되는 분야입니다.\nimage from : Autonomous Wheeled Mobile Robot Control\nController local Path가 계산되었다면, 이제 로봇이 실제로 해당 경로를 주행할 차례입니다.\n로봇의 최대 선속도, 각속도와 후진 여부 등 매개변수에 따라 경로를 최적화해야 합니다. Nav2에서는 Controller가 이를 담당하고 있습니다.\nController는 그 이름과 같이 주어진 경로를 따르기 위해 로봇에게 실제 제어 신호를 전달하게 되며, 따라서 사용하는 로봇의 모델과 밀접한 관련이 있습니다. (제자리 회전, y축 이동 등)\nimage from : dwa_local_planner\nNav2 Behavior Tree 로봇의 일련의 행동들은 Tree 자료 구조로 표현될 수 있으며, Tree의 Node에 해당하는 작업을 구현해두고 이들을 조합하여 시나리오를 구성할 수 있습니다.\nex) A 위치에 도착한 뒤, 물건을 싣고, 다시 B 위치로 이동하여 새로운 물건을 싣고, 최종적으로 C지점으로 돌아와라. 만약 C 지점에 물건이 가득 차있다면 D 지점으로 이동하여 물건을 최종 이송해라\u0026hellip; image from : wikipedia\nNav2는 **BehaviorTree.CPP**를 사용하여 로봇의 자율주행 시나리오 기능을 제공합니다. Behavior Tree는 Nav2와는 별도의 오픈소스 프로그램인데, 시각화를 포함한 높은 완성도를 갖추고 있어 게임 및 로봇 도메인에서 많이 사용됩니다. https://robohub.org/introduction-to-behavior-trees/\nNav2 Core nav2_core 패키지는 custom 알고리즘을 적용한 플러그인을 구현할 수 있도록 인터페이스를 제공합니다. 연구실이나 기업에서는 자신만의 로직을 Plugin으로 구현해서 Nav2 시스템에 적용할 수 있으며, 이러한 방식으로 구현의 시간을 단축시킬 수 있습니다.\nGlobal Planner – global_planner.hpp Local Planner – local_planner.hpp Recovery behaviors – recovery.hpp Goal checker – goal_checker.hpp Exceptions – exceptions.hpp 여러분만의 plugin을 만들어보고 싶다면, 아래 링크를 참고하세요.\nhttps://navigation.ros.org/plugin_tutorials/index.html Nav2 실행 예시 지루한 이론을 듣느라 고생하셨습니다. 이제 src를 통해 자율 주행 예시를 함께 실행해보겠습니다. colcon build --packages-select src_nav source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo racecourse.launch.py use_rviz:=false # Terminal 2 ros2 launch src_nav bringup_launch.py rqt_graph를 확인해봅시다. 방금 우리가 실행한 launch file을 같이 살펴볼까요?\nLaunchDescription부터 살펴봅시다. 대부분 launch arguement의 선언이고 결국 실행과 관련된 것은 bringup_cmd_group 뿐입니다. # Set environment variables ld.add_action(stdout_linebuf_envvar) # Declare the launch options ld.add_action(declare_namespace_cmd) ld.add_action(declare_use_namespace_cmd) ld.add_action(declare_map_yaml_cmd) ld.add_action(declare_use_sim_time_cmd) ld.add_action(declare_slam_cmd) ld.add_action(declare_params_file_cmd) ld.add_action(declare_autostart_cmd) ld.add_action(declare_bt_xml_cmd) ld.add_action(declare_open_rviz_cmd) # Add the actions to launch all of the navigation nodes ld.add_action(bringup_cmd_group) return ld Launch file의 실행 시 GroupAction을 통해 관련된 실행 프로그램들을 한데 묶을 수 있습니다. 이렇게 하는 이유는, 여러 로봇의 실행을 대비한 것입니다. IncludeLaunchDescription을 통해 4개의 launch file들을 다시 추가하고 있습니다. # Specify the actions bringup_cmd_group = GroupAction([ PushRosNamespace( condition=IfCondition(use_namespace), namespace=namespace), IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;slam_launch.py\u0026#39;)), ... IncludeLaunchDescription( # Run Localization only when we don\u0026#39;t use SLAM PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;localization_launch.py\u0026#39;)), ... IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;navigation_launch.py\u0026#39;)), ... IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;rviz_view_foxy_launch.py\u0026#39;)), ... ]) 각각의 하위 launch file은 개별 실행될 수 있도록 구성되었습니다. nav2_lifecycle_manager가 위치하고 있는 점도 확인 가능하고 node를 전달하는 방법도 알 수 있습니다. Node( package=\u0026#39;nav2_lifecycle_manager\u0026#39;, executable=\u0026#39;lifecycle_manager\u0026#39;, name=\u0026#39;lifecycle_manager_localization\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[{\u0026#39;use_sim_time\u0026#39;: use_sim_time}, {\u0026#39;autostart\u0026#39;: autostart}, {\u0026#39;node_names\u0026#39;: lifecycle_nodes}]) ... lifecycle_nodes = [nav2, related, nodes] Nav2의 최적화를 위해서는 수많은 매개변수들과 씨름해야 합니다. yaml 파일을 통해 관리되며 지금까지 살펴본 내용들이 모두 녹아들어 있습니다. amcl: ros__parameters: bt_navigator: ros__parameters: controller_server: ros__parameters: controller_server_rclcpp_node: ros__parameters: use_sim_time: False local_costmap: local_costmap: global_costmap: global_costmap: map_server: ros__parameters: use_sim_time: False yaml_filename: \u0026#34;turtlebot3_world.yaml\u0026#34; map_saver: ros__parameters: planner_server: ros__parameters: planner_server_rclcpp_node: ros__parameters: use_sim_time: False recoveries_server: ros__parameters: robot_state_publisher: ros__parameters: use_sim_time: False 자율 주행 시 발생하는 상황들에 대처하기 위해 기본적으로 Behavior Tree 예시를 제공합니다. 구체적인 내용보다 Node를 작성하고 시나리오를 구성할 수 있다는 점에 집중합시다.\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture8/",
	"title": "Lecture8 - ROS 2 Action and Examples",
	"tags": [],
	"description": "",
	"content": " 지금까지 Topic, Service에 대해 모두 배워보았습니다. 마지막 통신 메커니즘인 Action에 대해서 배워봅시다.\nROS2 Action 개념 Action은 Service와 Topic의 특성을 모두 갖고 있으며, 실제로 가장 늦게 탄생한 통신 메커니즘입니다. 일전 Service의 단점을 상기시켜보면서 Action의 필요성에 대해 체감해봅시다.\nService의 중요한 특징 한 가지 추가하자면, 하나의 Service Server에 여러 Client가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지 못합니다.\nimage from : docs.ros.org Action은 바로 이러한 Service의 단점을 극복하기 위해 탄생한 통신 메커니즘입니다.\nAction의 특징 action client는 action server가 Result를 보내기 전까지 마냥 기다리지 않고, 다른 일을 할 수 있습니다. action client는 Result Response를 받기 전에도 지속적으로 Feedback을 받을 수 있습니다. 따라서, Feedback을 받고 있다가, 뭔가 잘못 돌아가고 있다는 것을 감지한 경우 cancel을 할 수도 있습니다. ⇒ 하지만, 여러 request를 동시에 작업하는 것이나, Feedback 중에 topic subscribe와 같은 작업은 본질적으로 불가합니다. 이에 대한 해결 방법도 후에 살펴보겠습니다.\nimage from : https://docs.ros.org/en/foxy/Tutorials/Understanding-ROS2-Actions.html\n사진과 같이 Action Client와 Server가 주고받는 내용은 크게 5가지가 있습니다.\nClient ⇒ Server, Goal Request (service request와 유사합니다.) server ⇒ client, Goal Response client ⇒ server, Result Request server ⇒ client, Feedback (topic과 유사합니다.) server ⇒ client, Result Response 만약 4번 도중 cancel이 발생하면 Action은 종료됩니다.\n이렇게 Action은 Topic, Service의 특징을 모두 갖고 있으며 Cancel이라는 추가 기능까지 갖추고 있는 복잡한 통신 메커니즘입니다.\nAction 커멘드 라인 툴 turtlesim을 실행시킨 뒤, 실습을 진행해봅시다. ros2 run turtlesim turtlesim_node 실행 중인 action은 다음과 같이 조회 가능합니다. $ ros2 action list /turtle1/rotate_absolute 특정 action의 정보를 조회하기 위해 ros2 action info를 사용합니다. $ ros2 action info /turtle1/rotate_absolute Action: /turtle1/rotate_absolute Action clients: 0 Action servers: 1 /turtlesim Action에서 사용되는 데이터 타입은 action이며 ros2 interface show를 통해 조회 가능합니다. $ ros2 interface show turtlesim/action/RotateAbsolute # The desired heading in radians float32 theta --- # The angular displacement in radians to the starting position float32 delta --- # The remaining rotation in radians float32 remaining 커멘드 라인에서 손쉽게 Action Goal을 보낼 수 있습니다. (feedback option을 제공합니다.) $ ros2 action send_goal \u0026lt;action_name\u0026gt; \u0026lt;action_type\u0026gt; \u0026lt;values\u0026gt; $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \u0026#34;{theta : 0.0}\u0026#34; --feedback 1657646954.088327 [0] ros2: using network interface enp7s0 (udp/166.104.135.89) selected arbitrarily from: enp7s0, docker0 Waiting for an action server to become available... Sending goal: theta: 0.0 Goal accepted with ID: d3ddca85948d4099a13dbeb8183e5ecc Result: delta: -0.7839995622634888 Goal finished with status: SUCCEEDED Action 프로그래밍 Action Client 작성하기 일전 거북이를 회전시키는 Action Server에 매칭되는 Action Client입니다. 거북이가 움직이기 원하는 각도를 입력하면 해당 각도록 회전하기 시작합니다. $ colcon build --packages-select py_action_tutorial $ source install/local_setup.bash $ ros2 run py_action_tutorial turtle_turning_client [INFO] [1672647544.783857088] [turtle_rotate_client]: === Turtle Rotate Action Client Started ==== Enter Target Angle : 3.14 [INFO] [1672647549.097662572] [turtle_rotate_client]: Goal accepted [INFO] [1672647549.193173672] [turtle_rotate_client]: Received feedback: 0.051996707916259766 [WARN] [1672647549.226111271] [turtle_rotate_client]: Action Done !! Result: -0.12800025939941406 Action Client를 생성하기 위해서는 ActionClient 패키지를 추가해야 합니다. import rclpy from rclpy.action import ActionClient from rclpy.node import Node 우리가 사용할 turtlesim/action/RotateAbsolute라는 action은 다음과 같은 구조를 갖습니다. # The desired heading in radians float32 theta --- # The angular displacement in radians to the starting position float32 delta --- # The remaining rotation in radians float32 remaining Action Client는 ActionClient 인스턴스입니다. Service Client와 매우 비슷하다는 것을 알 수 있습니다. # Create Action Client self.action_client = ActionClient(self, RotateAbsolute, \u0026#39;turtle1/rotate_absolute\u0026#39;) action type : Client가 사용할 action 데이터 타입 action name : Action Server 이름 wait_for_server를 통해 Action Server의 존재 여부를 우선 확인합니다. # Wait for server first if self.action_client.wait_for_server(10) is False: self.get_logger().error(\u0026#39;Server Not exists\u0026#39;) Action Client는 callback이 많아 각 함수에 대한 실행 시점을 잘 알아두셔야 합니다. # Send Goal then receive future self._send_goal_future = self.action_client.send_goal_async( goal_msg, feedback_callback=self.feedback_callback ) # Done callback Add self._send_goal_future.add_done_callback(self.goal_response_callback) send_goal : main 함수에서 호출되며, Goal request를 진행합니다. feedback_callback : Server로부터의 Feedback이 들어올 때마다 실행되는 Callback 입니다. goal_response_callback : Goal Accpet와 Reject 여부를 확인합니다. get_result_callback : 최종 result에 대한 Callback으로, Action의 제일 마지막에 실행됩니다. Action은 메커니즘 자체가 어렵기 때문에 일부러 쉬운 예제를 가져왔습니다. 코드의 로직은 간단하며, Action Client API 자체에 집중하며 따라와주세요.\ngoal_response_callback : goal은 그 자체로 Service라고 말할 수 있습니다. 따라서, goal 완료까지 대기한 뒤 get_result_callback을 연동합니다. def goal_response_callback(self, future): goal_handle = future.result() if not goal_handle.accepted: self.get_logger().info(\u0026#39;Goal rejected\u0026#39;) return self.get_logger().info(\u0026#39;Goal accepted\u0026#39;) # Add Result cb self._get_result_future = goal_handle.get_result_async() self._get_result_future.add_done_callback(self.get_result_callback) feedback_callback은 subscriber의 callback과 유사하게 매개변수로 feedback 데이터를 받습니다. get_result_callback은 goal_response_callback과 유사하게, future를 매개변수로 받습니다. 하지만 더이상 추가할 callback은 없고 result를 받으면서 마무리됩니다. def feedback_callback(self, feedback_msg): feedback = feedback_msg.feedback self.get_logger().info(f\u0026#39;Received feedback: {feedback.partial_sequence}\u0026#39;) def get_result_callback(self, future): result = future.result().result self.get_logger().warn(f\u0026#39;Action Done !! Result: {result.sequence}\u0026#39;) rclpy.shutdown() 이번 예시에 구현되어 있지는 않지만, goal_handle로부터 cancel handler를 생성할 수도 있습니다. 아래 코드를 예시에 적용한 다음, cancel도 실습해보세요. # Cancel the goal future = self.goal_handle.cancel_goal_async() future.add_done_callback(self.cancel_done) # Cancel the timer self.timer.cancel() def cancel_done(self, future): cancel_response = future.result() if len(cancel_response.goals_canceling) \u0026gt; 0: self.get_logger().info(\u0026#39;Goal successfully canceled\u0026#39;) else: self.get_logger().info(\u0026#39;Goal failed to cancel\u0026#39;) rclpy.shutdown() Action Server Example - Parking Master image from : 기호일보\n이번에는 재미있는 예시를 준비해 보았습니다. 아래 명령어을 입력해 주세요 cbp custom_interfaces cbp parking_action_server source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo wall_world.launch.py # Terminal 2 ros2 run py_action_tutorial parking_action_server [INFO] [1672654091.689062703] [parking_action_server]: Action Ready... [INFO] [1672654101.355609636] [parking_action_server]: Executing goal... [INFO] [1672654101.356973636] [parking_action_server]: Distance from forward obstacle : 100.0 ... # Terminal 3 ros2 action send_goal /src_parking custom_interfaces/action/Parking \u0026#34;start_flag: true\u0026#34; --feedback Waiting for an action server to become available... Sending goal: start_flag: true Goal accepted with ID: d7bcfec5a6e94bd4a349f4955cc495c8 Feedback: distance: 100.0 Feedback: distance: 1.7898634672164917 ... 벽에 인접하여 흰색 상자들이 주차 공간을 배정해줄 것입니다. rqt_robot_steering으로 로봇을 잘 제어하여 주어진 주차 공간에 알맞게 주차를 해보세요!\nFeedback을 통해 벽과의 거리를 확인할 수 있으며, 이 거리가 0.5m 이내가 되면 주차가 완료됩니다. 이 시점에서 좌우 공간이 얼마가 균형이 맞는지에 따라 다른 Result를 얻게 됩니다.\n올바른 주차 시 ⇒ Success! 잘못된 주차 시 ⇒ Fail Action Server 프로그래밍 프로그래밍을 시작하기 전, 필요한 통신 메커니즘들을 살펴봅시다.\nAction Server : Goal을 받으면, 정면 벽과의 거리를 feedback으로 전달합니다. 최종 Result는 String으로 성공 여부를 알려줍니다. LaserScan Sub : 주변 물체와의 스캔된 거리를 알 수 있습니다. Feedback Callback과 Subscription Callback 두 함수도 구현해야 할 것입니다.\n이번 예시를 위해 custom interface를 만들어 보았습니다. Action 데이터 타입은 세 종류의 데이터로 이루어져 있습니다. #goal definition bool start_flag --- #result definition string message --- #feedback definition float32 distance 이제 코드를 살펴봅시다. Action Server를 사용하기 위해서는 ActionServer 패키지를 import 해야 합니다. import rclpy from rclpy.node import Node from rclpy.action import ActionServer 코드 분석 전 살펴본 바와 같이 두 종류의 핸들러를 생성합니다. class ParkingActionServer(Node): def __init__(self): super().__init__(\u0026#39;parking_action_server\u0026#39;) self.laser_sub = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, 10 ) self.action_server = ActionServer( self, Parking, \u0026#39;src_parking\u0026#39;, self.execute_callback ) Action Server의 Callback입니다. 첫 인자는 goal handler로 feedback 전송이 이를 통해 이루어집니다. feedback msg에는 정면 물체와의 거리가 담깁니다. def execute_callback(self, goal_handle): self.is_sub = True self.get_logger().info(\u0026#39;Executing goal...\u0026#39;) feedback_msg = Parking.Feedback() while self.f_obs_distance \u0026gt; 0.5: feedback_msg.distance = self.f_obs_distance goal_handle.publish_feedback(feedback_msg) self.get_logger().info( f\u0026#34;Distance from forward obstacle : {self.f_obs_distance}\u0026#34; ) time.sleep(1) while loop를 벗어나게 되면 goal succed를 수행하고, Result를 리턴합니다. 현재의 로직은 좌우 물체와의 거리가 균일할 때 성공으로 판정짓습니다. goal_handle.succeed() result = Parking.Result() lr_diff = abs(self.r_obs_distance - self.l_obs_distance) print(lr_diff) if lr_diff \u0026lt; 0.15: result.message = \u0026#34;[Success!] Oh... Teach me how you did :0\u0026#34; else: result.message = \u0026#34;[Fail] Be careful, Poor Driver! \u0026#34; return result main문에서 특별한 점을 찾아볼 수 있습니다. MultiThreadedExecutor를 사용하고 있는데요. 이것이 하는 역할이 무엇일지 실습을 통해 살펴봅시다. try: parking_action_server = ParkingActionServer() # MultiThreadedExecutor ref # https://url.kr/x4kf2b executor = MultiThreadedExecutor() executor.add_node(parking_action_server) try: executor.spin() except KeyboardInterrupt: parking_action_server.get_logger().info(\u0026#39;Keyboard Interrupt (SIGINT)\u0026#39;) finally: executor.shutdown() parking_action_server.destroy_node() finally: rclpy.shutdown() main 문의 주석을 토글하고, sub_callback에 디버깅 메세지를 심은 다음, 다시 예제를 실행 시켜봅니다. 어떠한 결과를 얻으셨나요? def sub_callback(self, data): if self.is_sub: self.f_obs_distance = data.ranges[60] self.r_obs_distance = data.ranges[30] self.l_obs_distance = data.ranges[90] self.get_logger().info(\u0026#34;sub success\u0026#34;) ... # parking_action_server = ParkingActionServer() # rclpy.spin(parking_action_server) # parking_action_server.destroy_node() # rclpy.shutdown() 현재의 시스템은 두 종류의 callback을 갖고 있습니다. execute_callback이 실행되면서 while loop로 진입하면, 자원을 점유하여 sub_callback이 동작할 수 없는 구조가 됩니다. 이를 해결하기 위해 ROS 2에서는 rclpy단에서 멀티 스레딩을 구현해 두었습니다.\nimage from : docs.ros.org 이후 여러가지 구현을 하다 보면 지금처럼 다중 Subscribe를 해야하는 경우가 반드시 생깁니다. 혹은 하나의 프로세스에서 여러개의 Node를 실행시켜야 하는 경우가 발생합니다. 이때, Node Composition과 MultiThreadedExecutor를 적극 사용해보세요!\n참고자료\nhttps://docs.ros.org/en/foxy/Concepts/About-Executors.html "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture9/",
	"title": "Lecture9 - C++ Programming Again, Outro",
	"tags": [],
	"description": "",
	"content": "C++ Programming Again 실질적으로 C++을 통해 ROS 2 개발이 많이 이루어진다 이야기하였습니다. Topic Publish와 Subscriber의 C++코드들도 turtlesim 예제와 함꼐 간단하게 정리해보았습니다.\nTopic Publish 예제 - Random Movement Turtle 예제 실행 cbp cpp_topic_tutorial source install/local_setup.bash # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_topic_tutorial topic_pub_node ⇒ 거북이가 마구잡이로 움직이기 시작할 것입니다\n로봇을 움직이기 위해서는 geometry_msgs/msg/Twist 형식의 topic message type을 사용해야 함을 배운 바 있습니다. 이를 위해서 다음과 같이, 헤더를 include 하면 됩니다. #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; 단, 파이썬과 달리 c++ 헤더는 snake_case를 취하며, 코드 사용 시 CamelCase를 사용합니다.\nrclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr twist_publisher; ... twist_publisher = this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;turtle1/cmd_vel\u0026#34;, 10); publisher는 create_publisher 함수를 통해 생성할 수 있습니다.\n\u0026lt;\u0026gt; 안에는 message type을 적어주고 첫 번째 매개변수는 생성할 topic의 이름 두 번째 매개변수로 queue size를 전달합니다. geometry_msgs::msg::Twist와 같이 타입이 길기 때문에 using을 사용하여 축약하곤 합니다.\nTopic Publish 예제 - Random Movement Turtle turtlesim 상의 거북이의 위치를 Subscribe 받습니다. # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_topic_tutorial topic_sub_node [INFO] [1666434438.709117200] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 [INFO] [1666434438.725522800] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 [INFO] [1666434438.741218300] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 ... 로직 자체는 어렵지 않기에 API에 집중하여 분석해보겠습니다. TwistPubNode() : Node(\u0026#34;twist_pub_node\u0026#34;) { twist_publisher = this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;turtle1/cmd_vel\u0026#34;, 10); timer = this-\u0026gt;create_wall_timer( std::chrono::milliseconds(500), std::bind(\u0026amp;TwistPubNode::timer_callback, this) ); } subscriber는 create_subscription 함수를 통해 생성할 수 있습니다.\n\u0026lt;\u0026gt; 안에는 message type을 적어주고 첫 번째 매개변수는 subscribe topic의 이름 두 번째 매개변수로 queue size 세 번째 매개변수로는 std::bind를 통해 callback 함수를 전달합니다. callback의 매개변수가 1개이기에 이를 알려야 하며, std::placeholders::_1이 사용되었습니다.\nsub_callback의 첫번째 매개변수인 데이터는 SharedPtr 타입이 사용된다는 것에 주의하며, 때문에 레퍼런스를 사용할 수 없습니다.\nTopic Publish 예제 - Random Movement Turtle Service Client와 Server의 C++코드들도 분석해봅시다.\nTurtle Spawn 예제 - 영상과 같이 우리가 내린 명령대로 거북이가 등장한 모습을 볼 수 있습니다. cbp cpp_service_tutorial source install/local_setup.bash # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_service_tutorial turtle_spawn_client \u0026gt; Turtle X position : 5.0 \u0026gt; Turtle Y position : 5.0 \u0026gt; Turtle Angle : 0.0 \u0026gt; Turtle Name : my_turtle [INFO] [1666434554.012857700] [spawn_turtle_node]: Turtle Named : my_turtle Spawned Successfully. create_client는 다음과 같은 정보를 요합니다.\n사용하는 srv 타입 request할 service 이름 wait_for_service를 통해 Service Server의 존재 여부를 체크할 수 있습니다.\n... public: SpawnTurtle() : Node(\u0026#34;spawn_turtle_node\u0026#34;){ spawn_client = this-\u0026gt;create_client\u0026lt;Spawn\u0026gt;(\u0026#34;spawn\u0026#34;); while (!spawn_client-\u0026gt;wait_for_service(1s)) { if (!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(), \u0026#34;Interrupted while waiting for the service. Exiting.\u0026#34;); exit(0); } RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;service not available, waiting again...\u0026#34;); } } send_request를 호출함으로 Service call이 가능합니다. 이때, send_request의 반환값을 살펴보면, 비동기 실행을 하고 있음을 알 수 있습니다. auto send_request(){ get_user_input(\u0026#34;\u0026gt; Turtle X position : \u0026#34;, spawn_request-\u0026gt;x); get_user_input(\u0026#34;\u0026gt; Turtle Y position : \u0026#34;, spawn_request-\u0026gt;y); get_user_input(\u0026#34;\u0026gt; Turtle Angle : \u0026#34;, spawn_request-\u0026gt;theta); get_user_input(\u0026#34;\u0026gt; Turtle Name : \u0026#34;, spawn_request-\u0026gt;name); return spawn_client-\u0026gt;async_send_request(spawn_request); } spin_until_future_complete는 async_send_request의 비동기 promise를 받아 실행 완료까지 대기하게 됩니다. int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;SpawnTurtle\u0026gt;(); auto result = node-\u0026gt;send_request(); // Wait for the result. if (rclcpp::spin_until_future_complete(node, result) == rclcpp::FutureReturnCode::SUCCESS) { RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;Turtle Named : %s Spawned Successfully.\u0026#34;, result.get()-\u0026gt;name.c_str()); } else { RCLCPP_ERROR(node-\u0026gt;get_logger(), \u0026#34;Failed to call service add_two_ints\u0026#34;); } rclcpp::shutdown(); return 0; } promise의 반환 완료값은 enumerator type을 갖고 있으며, 공식 문서를 참고하였습니다. image from : docs.ros2.org\nService Server 예제 - Turtle Turn 거북이가 원을 그리며 돌기 시작하다가, 일정 시간이 지나면 움직임을 멈추게 됩니다. rqt의 Service Caller를 사용하며, turtle_turn service를 사용하시면 됩니다. # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_service_tutorial turtle_circle_server # Terminal 3 [INFO] [1666435009.330619900] [turtle_circle_server]: Turtle Turning Server Started, Waiting for Request... [INFO] [1666435026.497839300] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498143700] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498297800] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498427400] [turtle_circle_server]: 0.00 Seconds Passed ... 전체 코드 중 Service Server를 생성하는 핵심을 위주로 살펴봅시다. class TurtleCircleNode : public rclcpp::Node { private: rclcpp::Service\u0026lt;SetBool\u0026gt;::SharedPtr bool_server; void turtle_circle(){ ... } ... } void server_callback(const std::shared_ptr\u0026lt;SetBool::Request\u0026gt; request, const std::shared_ptr\u0026lt;SetBool::Response\u0026gt; response){ if (request-\u0026gt;data) { turtle_circle(); } response-\u0026gt;success = true; response-\u0026gt;message = \u0026#34;Turtle successfully drawed Circle\u0026#34;; } public: TurtleCircleNode() : Node(\u0026#34;turtle_circle_server\u0026#34;){ bool_server = this-\u0026gt;create_service\u0026lt;SetBool\u0026gt;( \u0026#34;turtle_circle\u0026#34;, std::bind(\u0026amp;TurtleCircleNode::server_callback, this, std::placeholders::_1, std::placeholders::_2) create_service는 다음과 같은 정보를 필요로 합니다.\n사용하는 srv 타입 - SetBool 생성할 service 이름 - turtle_circle request 시 실행될 callback - server_callback service callback은 request와 response 두 데이터를 매개변수로 받습니다. 때문에, std::placeholders::_1, _2가 명시된 것이 보입니다. 더불어, 거북이를 움직이기 위해 Publisher도 하나 생성하였습니다.\n이렇게 C++ 코드까지 살펴보았는데요, Action의 C++ 코드는 이번 강의에서는 넘어가도록 하겠으며, 링크를 남겨두겠습니다.\nhttps://docs.ros.org/en/foxy/Tutorials/Intermediate/Writing-an-Action-Server-Client/Cpp.html\nAbout Real Robot 지금까지 우리의 실습을 책임졌던 src 로봇이 어떻게 만들어졌는지 살펴보면서, 실제 로봇 제품의 개발 과정을 살펴봅시다.\n항상 로봇 시스템을 제작하기 전, 저는 부품의 수급부터 계획합니다.\n메인 PC - 라즈베리파이, 젯슨 나노, 라떼판다, 오드로이드, Mini PC, etc… MCU 보드 - 아두이노, ESP 시리즈, Teensy, Node MCU etc… Actuator - 서보/스텝 모터, BLDC 모터, (엔코더 장착 여부, 전압 고려) … Sensor - Lidar, Camera (Monocular, Stereo, RGB-D, 360도 카메라…), Lidar, Range Sensor, etc… 외관 - 알루미늄, 3D 프린팅, 절곡, 카본 플레이트, CNC 가공… 이러한 이유로 로봇 제작에는 일정 비용과 경험이 요구됩니다. 하지만 모두 피와 살이 되니 아낌없이 투자하시기 바랍니다.\nimage from : 로봇 신문 로봇 개발의 초기부터 너무 모든 것을 고려할 필요는 없습니다. 작은 사이즈의 테스트 베드를 구축하여 기능과 경험을 충분히 쌓은 뒤, 점차 하드웨어를 개선해 나가면서 업그레이드를 진행합니다.\n함께하는 개발은 언제나 즐겁습니다.\n개발을 진행하고 하드웨어를 업그레이드해가면서, CAD 파일도 함께 관리합니다. 비록 SRC는 금속 가공이 들어간 것은 아니라 비교적 간단하지만, 규모 있는 로봇 프로젝트에서는 반드시 거쳐야 하는 과정입니다. CAD 파일로부터 urdf를 추출하고, 움직이는 joint들에는 gazebo controller plugin을, 센서 joint에는 gazebo sensor plugin을 적용하여 시뮬레이션을 제작합니다. 시뮬레이션을 통해 제어기와 Odometry Driver, 자율 주행 로직의 검증이 완료되면, 실제 로봇에 이를 적용합니다. 적용과 검증을 반복하면서 로봇을 계속해서 개선해나갑니다.\n작은 팁을 이야기하자면, 발생하는 모든 기록들을 문서화하는 것을 추천드립니다. 하드웨어를 다루다보면, 방금까지 되던 기능이 갑자기 말썽을 일으켜서 하루를 날리는 날도 있습니다. 항상 모든 것을 기록합시다.\nimage from : 에누리닷컷 강의의 마지막으로, ROS / ROS 2에 대한 프로젝트들, 센서들, 도전해볼 수 있는 것들을 제시해보고자 합니다.\nTutorial \u0026amp; Courses\nawesome-ros2 : https://github.com/fkromer/awesome-ros2 ROS2 Packages on NVIDIA Jetson : https://nvidia-ai-iot.github.io/ros2_jetson/ros2-packages/ Stereo labs : Getting Started with ROS2 and ZED Micro ROS Tutorial : https://micro.ros.org/docs/tutorials/core/overview/ Self-Driving Cars with ROS 2 \u0026amp; Autoware : https://www.youtube.com/playlist?list=PLL57Sz4fhxLpCXgN0lvCF7aHAlRA5FoFr Certification\nGoogle Source of Code : https://summerofcode.withgoogle.com/ Jetson AI Ambassador : Jetson AI Courses and Certification - NVIDIA Developer Open Source Contribution\nNav2 : https://navigation.ros.org/contribute/index.html ROS 2 Control : https://control.ros.org/master/doc/project_ideas.html MoveIt : https://moveit.ros.org/documentation/contributing/ Gazebo : https://gazebosim.org/docs/all/contributing 지금까지 부족한 강의를 함께해주셔서 감사드리며, 재미있는 로봇 개발을 프로젝트를 시작하시거나, 기획하고 계신 분, 커피 한잔 하며 로봇 이야기를 나누고 싶으신 분, 언제나 환영합니다. 김수영 / Kim Soo Young\nTel : 010-8689-0259 Email : tge1375@hanyang.ac.kr / mr.swimmingkim@gmail.com https://ci3.googleusercontent.com/mail-sig/AIorK4zhIPutEJ2vFjpLGkkkYPMjIEWnB6PqcB454aZ3N5oecRcE1PO_egb7VAiIkA9YIDhaT4xJT_I\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture1/",
	"title": "Lecture1 - Introduction to ROS",
	"tags": [],
	"description": "",
	"content": "What is ROS? ROS란, 로봇 소프트웨어 개발에 사용되는 일종의 프레임워크입니다.\n프레임워크라는 말은, ROS 나름대로의 실행 시나리오를 갖고 있다는 뜻입니다.\n사용자인 우리들은, 이 시나리오를 사용하여 로봇을 다루는 우리만의 Application을 만들게 됩니다.\nimage from : wikimedia 그런데 왜 OS라는 이름이 붙게 되었을까요?\n로봇을 실행하기 위해서, 수많은 프로그램들이 실행되며, ROS는 이들 사이의 우선순위와, 프로그램 사이의 데이터 흐름을 책임집니다. 이 작업은 스케쥴링이라고 불리며, 이러한 동작을 수행하는 시스템을 Operating System이라고 부르기 때문에 ROS라는 이름을 갖게 되었습니다.\nimage from : tutorialspoint 로봇을 개발하기 위해서 어떠한 프로그램들이 필요할까요?\n로봇이 수행하는 임무들을 크게 3가지로 분류하면 인지, 판단, 제어의 3가지로 나뉩니다.\n인지란, 센서들을 통한 물체 인지, 자기 자신의 위치와 방향 인지, 상황 인지 등 로봇에게 있어 환경과 상호작용하는 과정에 해당합니다. 판단이란, 앞/뒤로 움직일지, 로봇 팔을 뻗을지와 같이 인지를 기반으로 얻은 데이터를 통해 결정을 내리는 작업들이 해당할 것입니다. 제어는 로봇에서 빼놓을 수 없는 영역으로, 로봇은 실제 세상에서 움직이기 때문에, 얼마나 움직일지, 어느정도의 속도로 힘은 얼마나 강하게 줄지 등 물리적인 임무를 포함합니다. 이렇게 로봇 시스템은 무척 복잡하며, 이뿐만 아니라 회로, 설계, 재료, 에너지 등을 고려해야 하는 완성품 로봇은 현대 공학의 집합 그 자체라고 말할 수 있습니다.\nAbout this lecture 이 강의에서 다루고자 하는 부분을 정확히하자면, 인지도 판단도 제어도 아닌, 시스템입니다.\n로봇의 센서, 구동부, 알고리즘이 모두 준비되어 있는 상황에서, 이들을 하나의 시스템으로 엮어주는 역할을 하는 것이 바로 ROS입니다.\nimage from : ROS Industrial ROS라는 시스템의 특성상 정해진 코드와 방법으로 소프트웨어를 개발해야 하며, 대부분 ROS를 다루는 강의라고 하면 이를 지칭합니다. 우리가 배우고자 하는 주된 내용도 바로 이 부분이라고 말할 수 있습니다.\nROS 개념 ROS 커멘드 다루기 ROS 프로그래밍 - Topic, Service, Action etc… 하지만, 여기서 그치지 않고, 저는 좀 더 실질적인 로봇 개발을 이야기하고자 합니다.\n리눅스 시스템 Docker 사용하기 로봇 시뮬레이션 라이브 코딩과 에러 디버깅 학교를 다니다 보면 아무리 많은 이론을 공부하고 머릿속에 집어넣어도, 시험을 치고 나면 모두 사라지곤 합니다. 머리 속에 남는 공부를 위해서는 직접 코딩을 해보고, 프로젝트를 진행해봐야 합니다.\n강의를 수강하기 위해 필요한 선수지식 본 강의는 최대한 많은 분들이 끝까지 이해할 수 있도록 설계되었습니다. 따라서, 최대한 쉽고, 프로그래밍 실력이 출중하지 않아도 모두 완강할 수 있게 진행합니다. 하지만 그럼에도, 아래 코드를 이해할 수 있을 정도의 배경지식은 필요합니다. class OOPNode: def __init__(self): self.counter_ = 0 def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; print(hello_du) self.counter_ += 1 def my_first_oop_node(): oop_node = OOPNode() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except Exception as e: print(e) 파이썬 클래스, 메소드와 인스턴스 for, while, if/else 등 기본 문법 강의 코드와 강의 노트 사용법 강의 도중 사용되는 코드들은 Github Repository를 통해 배포되어 있습니다. 코드 강의 중 지속해서 링크를 해드리며, 강의 시작 전 미리 살펴보시면 더욱 좋습니다.\nhttps://github.com/RB2023ROS/du2023-ros1 강의 노트의 주소는 https://rb2023ros.github.io/kr/ 입니다. 코드와 명령어 등 필요한 리소스를 모두 담고 있으므로 복사/붙여넣기를 활용하여 강의 청취 시간을 절약하시기 바랍니다.\n참고로 해당 노트는 hugo를 사용하여 제작된 웹 페이지임을 밝힙니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture2/",
	"title": "Lecture2 - Dev Env Setup",
	"tags": [],
	"description": "",
	"content": "Develpoment Environment Setup 프로젝트 기반의 강의인 만큼, 개발 환경이 구축되지 않으면 앞으로의 실습을 진행할 수 없습니다. 따라서 이번 파트에 많은 시간을 배정하였고, 힘들 수 있지만 끝까지 따라와주시면 감사합니다.\n준비한 환경은 다음과 같습니다.\nUbuntu Linux 설치와 ROS 설정 wsl2를 기반으로 한 Windows 내 ROS 설정 Docker 기반의 ROS 설정 1,2,3 순서로 추천하는 설정입니다. 1번을 진행하시다가 도저히 못하겠으면 2번으로, 그래도 안되면 3번으로 진행해 주시면 됩니다.\nUbuntu Linux 설치와 ROS 설정 Linux라고 함은 사실 OS 자체라기보다 OS의 기초가 되는 코어 소프트웨어에 가깝습니다. 이 코어를 사용하여 여러 버전의 OS가 개발되었으며 이를 Liunx 배포판 이라고 지칭합니다.\nUbuntu Linux는 리눅스 배포판 중 가장 널리 알려진 배포판으로, 영국의 Software회사인 Canonical과 우분투 재단에서 개발, 유지보수 및 배포를 하고 있습니다.\nimage from : omdriod.com 기존의 Windows 노트북을 사용하고 있었다면 듀얼 부팅이라는 것을 통해 Ubuntu + Windows를 모두 사용 가능합니다. 듀얼 부팅에 방법에 대해선 잘 설명한 영상들이 많으므로 링크로 대체하겠습니다.\nHow to Dual Boot Ubuntu 20.04 LTS and Windows 10 How to Dual Boot Ubuntu and Windows 11 Ubuntu 20.04 설치를 확인 하셨다면 터미널을 실행한 뒤 아래의 명령어들을 실행합니다.\nterminator 설치 sudo apt update sudo apt install terminator -y terminator 화면 분할 예시\nctrl + alt + t : 터미널 실행 ctrl + shift + e : 세로 분할 ctrl + shift + o : 가로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 ROS / ROS 2 한줄 설치 cd ~/ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; … Do you want to install ROS automatically? (y/N): y 다음으로, 시뮬레이션 프로그램인 Gazebo를 설치합니다. Gazebo는 ROS를 관리하는 조직인 OSRF에서 공식 지원하는 로봇 시뮬레이터입니다.\nsudo sh -c \u0026#39;echo \u0026#34;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\u0026#34; /etc/apt/sources.list.d/gazebo-stable.list\u0026#39; wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt update sudo apt install gazebo11 libgazebo11-dev -y sudo apt install ros-foxy-gazebo-ros-pkgs -y 그림와 같이 Gazebo의 화면이 어둡고, 그림자가 보이지 않는다면 호환되는 그래픽 드라이버를 설치해야 합니다.\nsudo ubuntu-drivers autoinstall sudo reboot # 장착된 장치 확인 ubuntu-drivers devices 마지막으로, catkin build system을 사용하기 위해 아래 커멘드 명령어를 실행합니다.\nsudo apt-get install python3-catkin-tools Windows + WSL2 설정 WSL(Windows Subsystem for Linux) 이란, 리눅스용 윈도우 하위 시스템의 약자로, 윈도우 10에서 네이티브로 리눅스 실행 파일(ELF)을 실행하기 위한 호환성 계층입니다.\nWindows10부터 WSL을 지원하며, Windows 2004(20H1) version부터 WLS2를 지원하고 있습니다.\n최신 Windows 업데이트 적용 (\u0026ldquo;Windows Key ⇒ 업데이트\u0026quot;로 이동하여 최신 업데이트를 적용합니다.) powershell을 관리자 권한으로 실행한 뒤, 설치 되어있는 WSL 2를 활성화시킵니다. \u0026gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. \u0026gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. MS Store로 이동하여 windows terminal을 설치합니다. windows terminal 화면 분할 예시 alt + shift + - : 가로 분할 alt + shift + + : 세로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 다음 링크를 통해 프로그램을 다운받고 WSL 2 Linux 커널 업데이트를 설치/진행 후 재부팅합니다.\n커널 업데이트를 마친 다음, powershell에 아래 커맨드 라인을 입력하여 WSL 2를 기본 사용하도록 설정합니다.\n\u0026gt; wsl --set-default-version 2 WSL 2와의 주요 차이점에 대한 자세한 내용은 https://aka.ms/wsl2를 참조하세요 작업을 완료했습니다. 이 시점에서 발생할 수 있는 문제들을 한차례 살펴보고 가겠습니다.\nwsl --set-default-version 2 에서 작업 완료 메세지가 등장하지 않는 경우 ⇒ 제일 처음 명령어부터 제가 보여드린 예시와 동일한 결과를 얻었는지 확인해보세요\nLinux용 Windows 하위 시스템 설정 여부도 확인합니다.\n지금까지 진행한 작업들이 제대로 설정 되어있는지 확인해봅시다. \u0026gt; wsl -l -v NAME STATE VERSION * Ubuntu-20.04 Running 2 문제가 없다면 MS Store 진입 후, Ubuntu 20.04 버전을 설치합니다. 설치 이후, 열기 버튼을 눌러 초기 실행을 하고 username, password를 설정합니다.\n이 시점에서 발생할 수 있는 문제들도 다시 한차례 살펴보고 가겠습니다.\n‘The WSL Optional Component is not Enabled. Please Enable it and Try again’ 오류가 발생하는 경우 \u0026gt; Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 0x80370102 에러가 발생한 경우 ⇒ 부팅 BIOS에서 가상화 기능을 활성화해줍니다.\n0xc03a001a 에러가 발생한 경우 ⇒ 다음 블로그 포스팅을 참고합니다.\n설치 이후에는 windows terminal에서 Ubuntu Terminal을 선택하여 실행 및 진입이 가능합니다. 설정 탭을 통해 Ubuntu 20.04를 기본 터미널로 설정 후 저장합시다.\nROS / ROS 2를 한줄 설치합니다. $ cd ~/ $ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; Installing Neuron Startup Menu... Cloning into \u0026#39;/home/kimsooyoung/ros_menu\u0026#39;... remote: Enumerating objects: 583, done. remote: Counting objects: 100% (290/290), done. remote: Compressing objects: 100% (193/193), done. remote: Total 583 (delta 179), reused 173 (delta 93), pack-reused 293 Receiving objects: 100% (583/583), 154.50 KiB | 3.22 MiB/s, done. Resolving deltas: 100% (340/340), done. Do you want to install ROS automatically? (y/N): y 설치가 완료되었다면, 앞으로 터미널을 새로 등장시킬 때마다 다음과 같이 사용할 ROS 버전을 묻게 됩니다. GUI 인터페이스 설정 링크를 통해 VcXsrv를 설치합니다. ⇒ https://sourceforge.net/projects/vcxsrv/ 설치 이후, XLaunch를 실행하고, 사진과 같은 설정을 진행합니다. 앞으로 재부팅 시마다 이 설정을 반복해줘야 하며, 종종 Gazebo의 Memory Leak로 인해 화면이 종료되지 않는 경우가 있는데, 이런 경우 XLaunch를 강제 종료해주면 됩니다.\n설정이 잘 되었는지 Gazebo를 실행해봅시다. export GAZEBO_IP=127.0.0.1 export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 export LIBGL_ALWAYS_INDIRECT=0 gazebo 마지막입니다! ~/.bashrc를 수정합니다. echo \u0026#39;export GAZEBO_IP=127.0.0.1\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 \u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export LIBGL_ALWAYS_INDIRECT=0\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 발생할 수 있는 오류 상황들을 살펴보고 가겠습니다.\ngazebo 실행 시 symbol error $ gazebo gazebo: symbol lookup error: /usr/lib/x86_64-linux-gnu/libgazebo_common.so.9: undefined symbol: _ZN8ignition10fuel_tools12ClientConfig12SetUserAgentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE 해결 방법 ⇒ sudo apt upgrade -y libignition-math2\nGazebo 자체가 실행되지 않는 경우\nPC 재시작 후 백신 프로그램을 종료시킵니다. 제어판 ⇒ 시스템 및 보안 ⇒ Windows 방화벽 ⇒ 고급 설정 ⇒ 인바운드 규칙 ⇒ VcXsrv 사용 허용\nGazebo는 실행되지만, Grid (실선)이 등장하지 않는 경우\n안타깝지만 그래픽 드라이버 문제일 가능성이 큽니다. (Window ⇒ 업데이트 확인 진입 후 가장 최신 버전으로 모두 업그레이드를 실행해줍니다.)\nDocker 기반의 ROS 설정 이전 설치 모두 실패하신 경우 사용할 수 있는 최후의 방법이자. MacOS 사용자들을 위한 설정입니다.\ndocker desktop for windows를 설치합니다. ⇒ https://docs.docker.com/desktop/windows/install/ # 설치 확인 \u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 설치 확인 이후 동일한 명령 프롬프트에서 다음 커멘드 라인을 입력하여 도커 이미지를 다운받습니다. (해당 docker image는 강의에 필요한 작업을 제가 미리 준비해둔 것입니다.) docker pull tge1375/du_ros_noetic:0.0.0 docker 이미지를 최초 실행 시, 방금의 명령 프롬프트에서 아래와 같은 커멘드 라인을 입력해 주세요. docker run -it -p 6080:80 --name ros_noetic tge1375/du_ros_noetic:0.0.0 입력 후 링크를 통해 로컬 VNC 서버로 접속이 가능합니다. 첫 실행 시 방화벽 보안 경고가 등장하며, 이때 반드시 엑세스를 허용해줍니다. ⇒ (http://127.0.0.1:6080/) 위와 같은 화면이 등장했다면 noVNC에 접속이 성공한 것입니다.\n최초 명령 프롬프트에서 실행한 이후 다시 실행시키고 싶은 경우, 혹은 중지시키고 싶은 경우 docker desktop을 사용하면 매우 편리하게 작업이 가능합니다. VScode 셋업 VNC내에서의 개발은 매우 불편하기 때문에, VScode를 통해 코드 개발을 하고자 합니다. 다음과 같은 extension들을 설치합시다.\nDocker Docker Explorer Remote Development 설치 이후, cmd + p를 통해 Remote-Containers를 입력하면, 현재 실행 중인 컨테이너의 목록을 조회할 수 있습니다.\n이들 중 원하는 컨테이터를 선택하면, 새로운 vscode가 새로이 실행되며 작업 폴더를 설정하게 됩니다.\nLinux Commands 셋팅한 환경은 모두 리눅스를 기반으로 합니다.\n때문에 최소한의 리눅스 커멘드 지식이 필요하며, 짚고 넘어가겠습니다.\n리눅스 필수 명령어\ncd \u0026lt;디렉토리\u0026gt; : 해당 디렉토리로 이동하기 (절대 경로와 상대 경로, ../ 와 ~/) pwd : 현재 위치한 절대 경로 ls : 현재 디렉토리에 위치하는 모든 파일들 (ls -al 옵션) touch \u0026lt;파일 이름\u0026gt; : 해당 이름을 가진 파일 생성 source : 쉘 스크립트 실행하기 (source ~/.bashrc) 강의를 위해 알아야 할 추가 명령어들\nsudo : root 권한으로 실행하기 apt install / remove / purge : 리눅스 배포 패키지 설치 apt update : apt의 상태를 최신화, 설치된 패키지들을 최신화하는 과정을 포함함 그 외 알아두면 좋은 것들\ntop / htop : 리눅스의 작업 관리자 ps aux : 실행 중인 프로세스 출력 (ps aux | grep ros) tee \u0026lt;파일 이름\u0026gt; : 터미널 로그를 기록하기 xdg-open . : 현재 위치에서 파일 탐색기 열기 강의 중 설정된 Alias 설명\neb : edit bashrc의 약자로 ~/.bashrc 파일을 gedit을 통해 수정할 수 있습니다. sb : source bashrc의 약자로 수정된 ~/.bashrc 파일을 반영시킵니다. killg : 실행중인 Gazebo관련 모든 프로그램을 종료시킵니다. 유용한 프로그램들 설치하기\nsudo apt install gedit sudo apt install terminator -y 코드 에디터와 IDE 추천\nVSCode - https://code.visualstudio.com/ PyCharm - https://www.jetbrains.com/ko-kr/pycharm/download CLion - https://www.jetbrains.com/ko-kr/clion/ 참고자료\nhttps://www.youtube.com/watch?v=DW7l9LHdK5c https://www.lainyzine.com/ko/article/how-to-install-wsl2-and-use-linux-on-windows-10/ https://github.com/Tiryoh/docker-ros2-desktop-vnc https://89douner.tistory.com/123 "
},
{
	"uri": "/kr/ros_basic_noetic/lecture3/",
	"title": "Lecture3 - Core of ROS",
	"tags": [],
	"description": "",
	"content": " 지난 시간 개발환경 세팅을 잘 진행하였는지 확인을 해보면서 강의를 시작해보겠습니다.\n터미널 프로그램을 실행한 뒤, gazebo를 실행해 봅시다.\ngazebo 위 사진과 같은 화면이 나오지 않았다면 설치가 제대로 되지 않은 것입니다.\n다음으로, ROS 설치는 잘 되었는지도 확인해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun rospy_tutorials talker 모든 확인이 끝났다면, 예제 프로그램을 실행시켜보겠습니다.\nHusky Gazebo 예제 패키지 설치 sudo apt-get update sudo apt-get install ros-noetic-husky-desktop sudo apt-get install ros-noetic-husky-simulator 예제 프로그램 실행 # Terminal 1 roslaunch husky_gazebo husky_empty_world.launch # Terminal 2 roslaunch husky_viz view_robot.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py cmd_vel:=/husky_velocity_controller/cmd_vel Terminal 1에서 발생하는 아래 오류는 무시해도 좋습니다.\n모든 실행이 정상 동작하였다면, Terminal 3에서 키보드를 통해 Husky를 제어할 수 있습니다. 로봇이 움직임에 따라 두번째 터미널 결과였던 Rviz에 아래와 같은 변화가 생깁니다. 다음으로, 새로운 터미널에서 아래 커멘드 라인을 실행시켜 봅시다. rosrun rqt_graph rqt_graph 위 그림은 방금 전 실행한 예제 내부적으로 어떠한 동작들이 이루어지고 있었는지를 보여주는 것으로, 강의를 마칠 때면 여러분들은 위 그림이 어떠한 의미를 갖는지 모두 이해하실 수 있을 것입니다.\n다음으로, 터미널을 새로 실행시켜 rosnode list와 rostopic list를 실행시켜 봅시다.\nrosnode list $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rostopic list $ rostopic list /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state /gazebo/set_model_state ... 앞으로의 강의들에서, 위 명령어들이 어떠한 의미를 갖는지 하나하나씩 함께 살펴보겠습니다.\nROS Node ROS는 각 프로세스들을 Node라는 단위로 관리합니다.\n로봇을 움직이는 Node, 센서와 통신하는 Node, 시각화 Node 등 다양한 Node들이 얽혀 로봇 시스템을 구성하게 됩니다. Node들 사이에는 데이터의 송수신이 필요합니다. 이를 담당하는 ROS의 통신 메커니즘들이 있으며 각기 다른 특성을 갖고 있습니다. Node들끼리 데이터를 주고받기 위해서는 어떤 노드가 존재하는지, id는 몇번인지 등의 정보가 공유되어야 할 것입니다. 아래 그림의 ROS Master가 이를 관리해주는 것이라고 이해하시면 됩니다. image from : clearpathrobotics 그렇다면, 방금 우리가 실행한 예시에서도 ROS Master와 Node들이 실행되었겠군요!\n실행되는 Node를 확인하는 방법은 크게 두 가지가 있습니다.\nrosnode command $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rqt_graph rosrun rqt_graph rqt_graph rqt graph를 살펴보면, 동그란 Node와 Node들 사이의 데이터 송수신이 화살표로 표현된 것을 알 수 있습니다. 키보드를 통해 제어 데이터를 송신하는 teleop_twist_keyboard는 gazebo node로 데이터를 보내고 있으며, 따라서 gazebo는 이 데이터를 통해 실제 로봇을 움직이게 되는 것입니다.\n특정 Node에 대해서 더 자세한 정보를 얻고 싶다면, rosnode info 커맨드를 사용합니다. $ rosnode info /base_controller_spawner -------------------------------------------------------------------------------- Node [/base_controller_spawner] Publications: * /rosout [rosgraph_msgs/Log] Subscriptions: * /clock [rosgraph_msgs/Clock] Services: * /base_controller_spawner/get_loggers * /base_controller_spawner/set_logger_level contacting node http://192.168.55.236:33811/ ... Pid: 63764 Connections: * topic: /rosout * to: /rosout * direction: outbound (43329 - 192.168.55.236:34456) [10] * transport: TCPROS * topic: /clock * to: /gazebo (http://192.168.55.236:33853/) * direction: inbound * transport: TCPROS 이전 예제들은 일단 종료시킨 뒤, 간단한 새로운 예시를 실행해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener # Terminal 4 rqt_graph rqt_graph를 보면 talker ⇒ listener로 데이터가 전송되는 것을 알 수 있습니다.\n이제, rqt_graph를 보는 것은 익숙해졌지요?\n첫번째 Gazebo 예시와 다른 점으로 roscore라는 것을 실행해주었습니다.\nroscore는 ROS Master를 실행시키는 명령어로 모든 ROS Node들은 Master에 의해 관리되기 때문에 roscore를 통해 실행시키거나, roslaunch를 사용해야 합니다. ROS Master가 실행되고 있지 않다면, 아래와 같이 오류가 발생합니다. ETH Super Mega Bot \u0026amp; ROS Workspace ROS는 catkin이라는 빌드 시스템을 사용합니다. 기존 c/c++ cross-platform 개발을 경험하셨다면 cmake에 익숙하실텐데, 이와 매우 비슷합니다. catkin을 통해 실행 가능한 프로그램 (C/C++의 빌드), 라이브러리, 인터페이스들을 만들 수 있으며, catkin 시스템을 사용하기 위해서는 workspace라는 특별한 폴더가 필요합니다. ROS 개발을 하다 보면 여러 프로젝트를 동시에 진행하는 경우가 생깁니다. 새로운 작업은 새로운 폴더를 만들어 작업하듯이 ROS 에서도 새로운 프로젝트는 새로운 WorkSpace에서 작업을 수행하는 것이 일반적입니다. 새로운 WS로 이동하게 되면 ROS에게 이러한 변화를 알려줘야 하며 이 명령어가 source devel/setup.bash 입니다. 이번 강의용 WS를 만들어보고, 이후 여러분들만의 WS도 만들어 작업해보세요! 일반적으로 ROS의 workspace는 name_ws라는 이름을 갖는 것이 일반적이며, 우리는 catkin_ws라는 workspace를 만들어보고자 합니다.\n아래 커멘드 라인들을 따라해주세요 cd ~/ mkdir -p catkin_ws/src cd catkin_ws catkin config --init catkin build 다음과 같이 build, devel, src, log 폴더가 만들어집니다. ROS 코드들은 모두 src 폴더 안에 위치하게 됩니다. src 폴더 내부에서 코드 개발 ⇒ catkin을 사용한 빌드 ⇒ build 폴더 내부에 실행 가능한 프로그램 생성의 순서로 개발이 이루어집니다. 실습을 통해 개발 프로세스에 익숙해져봅시다.\n아래 폴더를 catkin_ws/src 안에 압축 해제합니다. Example Packages smb_common.zip (2 ) 터미널 프로그램을 실행시키고 아래 커멘드 라인을 따라합니다. catkin build smb_description catkin build smb_gazebo catkin build smb_control source devel/setup.bash source로 시작하는 마지막 라인은 새로운 빌드 후에 항상 실행해줘야 합니다. 1강을 잘 따라했다면 sds라는 단축어로 사용이 가능합니다.\n예제 프로그램을 실행시킵니다. roslaunch smb_gazebo smb_gazebo.launch 실행 시 붉은 에러 메세지가 나오지만 동작만 된다면 문제 없습니다.\n이 로봇을 한번 움직여 볼까요? - teleop 실행 rosrun teleop_twist_keyboard teleop_twist_keyboard.py 파일 구조 관점에서, ROS Application은 여러 Package들로 이루어집니다. 이들 Package가 소스 파일을 담고 있고, catkin이 이들을 빌드하여 실행 프로그램들을 만들었습니다. 제가 공유한 압축 파일 안에도 3개의 Package가 포함되어있던 것이며, ROS 개발자들은 자신들의 로봇 Package를 개발하고 공유합니다. Package 생성 실습 Package를 생성하는 방법은 다음과 같습니다.\ncd \u0026lt;your-ws\u0026gt;/src catkin_create_pkg \u0026lt;package_name\u0026gt; [depend1] [depend2] [depend3] my_first_package라는 package를 시험삼아 생성해봅시다.\n# exameple $ catkin_create_pkg my_first_package rospy std_msgs Created file my_first_package/package.xml Created file my_first_package/CMakeLists.txt Created folder my_first_package/src Successfully created files in /home/kimsooyoung/catkin_ws/src/my_first_package. Please adjust the values in package.xml. depend에는 해당 패키지의 의존성 패키지들이 나열되며, rospy는 파이썬을 통해 ROS를 사용하기 위한 의존성입니다.\n미리 제공되었던 Package, smb_gazebo를 살펴봅시다.\nGazebo 실행에 필요한 모델 파일과 환경 파일 등 기능별 정리된 모습을 볼 수 있습니다.\n이렇게 Package를 잘 구성해두면 이후 코드의 관리에도 편리하다는 장점이 있습니다.\n참고자료\nhttp://wiki.ros.org/ko/ROS/Tutorials/CreatingPackage https://rsl.ethz.ch/education-students/lectures/ros.html https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture4/",
	"title": "Lecture4 - ROS Launch, RViz",
	"tags": [],
	"description": "",
	"content": "ROS Launch 일전 예시 실행에서 다음과 같은 커멘드 라인을 사용했었습니다.\nroslaunch smb_gazebo smb_gazebo.launch roslaunch란, 다수의 ROS Node들을 한번에 실행할 수 있도록 해주는 툴 입니다.\nroslaunch를 사용하기 위해서는 xml이라는 포멧을 사용하는 launch file이 있어야 하며, 이는 보통 패키지의 launch 폴더에 위치하고 있습니다.\nlaunch file의 구조를 파악해봅시다.\nlaunch파일은 xml이라는 문법을 사용합니다. html을 사용해보셨다면 아시겠지만, \u0026lt;\u0026gt;를 이용하여 라인을 구분하는 포멧입니다. 한 라인에서 끝나는 경우 /\u0026gt;로 맺을 수 있지만, 여러 라인이 필요한 경우에는 여는 태그와 닫는 태그를 사용하여 구분합니다. \u0026lt;tag /\u0026gt; or \u0026lt;tag (value)\u0026gt; ... \u0026lt;/tag\u0026gt; launch file은 시작과 끝, 태그로 감싸집니다.\nnode 태그는 실행되는 ROS Node를 지칭합니다. name 태그는 node를 실행할 때의 이름을 설정하는 부분으로 자유롭게 지정 가능합니다. pkg 태그에는 해당 node가 속해있는 package를 적습니다. type 태그에는 실행가능한 파일, 혹은 프로그램을 적게 되며, c++의 경우 빌드된 프로그램, 파이썬의 경우 파이썬 파일이 됩니다. output 태그는 로그가 출력되는 위치를 지정하며 screen일 시 터미널에 출력됩니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;listener\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;listener.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;talker\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;talker.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 이번에는 smb_gazebo.launch를 살펴봅시다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- GAZEBO ARGUMENTS --\u0026gt; \u0026lt;!-- Run Gazebo headless --\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;model_path\u0026#34; default=\u0026#34;$(find smb_gazebo)/\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_namespace\u0026#34; default=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_model_name\u0026#34; default=\u0026#34;smb\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;enable_ekf\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; ... \u0026lt;!-- Load Gazebo world --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; arg란, argument의 약자이며 launch 파일에서 인자로 작용하는 일종의 변수입니다.\narg 태그를 통해 argument를 선언하고 default를 통해 초기값을 정할 수 있습니다. argument의 선언 후 사용은 $(arg \u0026ldquo;argument name\u0026rdquo;) 입니다. roslaunch 시 argument를 바꿔 실행이 가능합니다. 예를 들어, smb_gazebo.launch 실행 시. world를 바꾸어 아래와 같이 사용이 가능합니다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school 초기 실행 시 시간이 다소 걸릴 수 있습니다.\n현재 예시에서 제공되는 world는 다음 3가지 입니다.\nroslaunch smb_gazebo smb_gazebo.launch 제작한 launch file을 다시 다른 launch file에서 불러오는 경우가 더러 있습니다.\n이때, include 태그를 사용하며, 패키지 단위를 기반으로 파일의 경로를 가져오게 됩니다.\ninclude하는 launch file의 내부에도 여러 argument들이 있을 것입니다. 이들은 arg 태그를 통해 접근할 수 있습니다.\n\u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; html과 마찬가지로 \u0026lt;!-- --\u0026gt; 사이에 오는 코드는 주석으로 무시됩니다.\n단, 주의사항 하나 있습니다. launch 파일을 사용하다보면 --가 종종 쓰이곤 하는데요. 이 경우 주석에 오류가 나니 주의하시기 바랍니다.\nLaunch File을 다루는 연습을 해봅시다.\nsmb_gazebo.launch를 다음과 같이 수정합니다.\nworld를 big_map_summer_school로 수정합니다. 로봇이 등장하는 위치를 다음과 같이 수정합니다. xyz : (-0.5, -1.0, 0.4) yaw angle : 90도 (3.1415를 1 radian으로 잡습니다.) launch file에 rospy_tutorials Package에 있는 talker Node를 추가합니다. Rqt와 RViz ROS에는 로봇의 다양한 센서 데이터들을 시각화해주는 3D 툴이 있으며, 이는 RViz라고 불립니다.\nRviz의 사용법을 알아봅시다.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 rviz 사진과 같이 Gazebo와 RViz가 잘 실행된 상황에서 강의를 따라합니다.\nrviz에서 센서 데이터를 시각화하기 전, 우선 어떤 좌표계를 기준으로 시각화할지 설정해주어야 합니다.\n같은 센서라도 원점 좌표계에서 본 모습과, 센서 좌표계에서 본 모습이 다르기 때문입니다.\nimg from : mathworks 이는 RViz의 Fixed Frame에서 설정 가능합니다. (odom으로 설정해보겠습니다.)\n이제 다양한 시각화 기능들을 사용해보려 합니다.\n기본적으로 데이터의 추가는 왼쪽 하단 Add 버튼으로 실행합니다. tf 시각화 odometry 시각화 point cloud 시각화 이렇게 잘 설정해둔 RViz는 config 포멧으로 추출하여 이후에 다시 사용할 수 있습니다.\nFile ⇒ Save Config를 통해 config를 저장하고, Open Config를 통해 저장한 config를 불러올 수 있습니다.\n아래와 같이 다양한 Plugin을 통해 여러 센서, 로봇 데이터를 시각화할 수 있으며, 자신만의 Plugin을 제작할 수도 있습니다.\n지금까지 여러분들이 만든 RViz 설정을 저장해보고, launch file에 통합해봅시다.\nRViz의 좌측 상단 File 옵션을 사용하여 config file을 저장합니다. 저장 위치는 smb_gazebo/rviz로 지정하겠습니다. (새롭게 폴더를 만들어주었습니다.) 이제, launch file을 수정합시다. 파일 하단 launch 태그가 닫히기 전 부분에 아래와 같은 라인을 추가합니다. \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find smb_gazebo)/rviz/my_config.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 이제, 다시 Gazebo launch를 해봅시다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school Rqt Tools 지금까지 사용한 ROS 툴은 rqt_graph와 RViz가 있었습니다.\n사실 ROS에는 수많은 추가 툴들이 존재하며 이들을 묶어 rqt tools라고 부릅니다.\nrqt image view image from : wiki.ros.org\nrqt multiplot image from : project march\nrqt console image from : wiki.ros.org\nrqt robot steering rqt tf tree image from : rqt tf tree\n이러한 수많은 툴들이 있어 ROS 개발을 편리하게 해주고 있으며, 함께 ROS를 공부하면서 하나씩 같이 살펴보고 사용해보려 합니다.\n참고자료\nhttp://wiki.ros.org/roslaunch https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html https://rsl.ethz.ch/education-students/lectures/ros.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture5/",
	"title": "Lecture5 - First Programming, ROS Topic",
	"tags": [],
	"description": "",
	"content": "이번 강의부터, 본격적인 프로그래밍이 시작됩니다. 첫번째로 Node의 프로그래밍을 살펴보고자 하며, 시작 전 간단한 복습을 진행하고 시작하겠습니다.\nimage from : clearpathrobotics\nWorkspace와 패키지 # WS 생성 mkdir -p catkin_ws/src cd catkin_ws catkin config --init # Package 생성 catkin_create_pkg \u0026lt;pkg-name\u0026gt; \u0026lt;depend1\u0026gt; \u0026lt;depend2\u0026gt; ... ROS Node Programming C++ 코드는 src 폴더 안에, 파이썬 코드는 scripts라는 폴더 안에 위치시키는 것이 일반적입니다. cd \u0026lt;pkg-name\u0026gt; mkdir scripts 지금부터, 직접 명령어를 한줄씩 따라치면서 실습하셔도 좋고, 제가 미리 준비해둔 Package를 사용하셔도 좋습니다.\n다음으로, 파이썬 코드를 작성하고 패키지를 빌드해봅시다.\ncd scripts # my_first_node.py 생성 첫번째 프로그래밍 코드는 Node의 기본입니다.\n모든 소스코드는 github repo에서 확인 가능합니다.\nmy_first_node.py #!/usr/bin/env python3 import rospy from std_msgs.msg import String def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # ROS safe timer rate = rospy.Rate(10) # 10hz # Loop control Example while not rospy.is_shutdown(): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. rate.sleep() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드를 새로 작성한 다음에는 습관적으로 패키지를 빌드하고 실행합니다. 파이썬 코드의 경우 파일의 실행 권한이 주어져 있어야 합니다. cd scripts chmod +x * cd ~/catkin_ws catkin build my_first_pkg 작성한 node를 실행해봅시다. 반복해서 터미널 로그가 남을 것입니다. # Terminal 1 roscore # Terminal 2 rosrun my_first_package my_first_node.py 코드 분석 첫 코드인 만큼 자세하게 분석하고 넘어가보려 합니다.\nROS Noetic은 Python 3를 사용합니다. 가상환경의 파이썬, 직접 설치한 파이썬 등 여러 버전이 설치되어 있을 것입니다. 공식 문서에서는 이러한 혼란을 방지하기 위해 코드의 제일 처음 아래 라인을 추가하는 것을 추천하고 있습니다. #!/usr/bin/env python3 Python을 사용하여 ROS를 다루기 위해 사용되는 패키지는 rospy입니다. import를 사용해도 좋고 from / import를 통해 특정 클래스만 가져올 수도 있습니다. import rospy from std_msgs.msg import String 당장 사용하지는 않지만 Test Code를 작성해야 하는 경우가 있습니다. 이러한 상황에 대비하기 위해 main 함수를 따로 두고 아래와 같이 프로그램을 시작하기를 권장합니다. if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 이제, my_first_node를 분석해 보겠습니다. Node의 실행을 위해 Master에 등록하고, 초기화하는 작업이 필요하며, 이를 위해 별도로 init_node라는 메소드를 실행해주어야 합니다. def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) ROS 시스템은 기본적으로 무한 Loop입니다. 이 Loop가 한차례 반복되는 주기를 설정하는 부분입니다. ROS의 시간 체계에 대해서는 이후 한번 더 다루겠습니다. # ROS safe timer rate = rospy.Rate(10) # 10hz rospy를 통해 실행 중인 Node의 상태를 확인할 수 있으며, is_shutdown()은 예기치 못한 에러가 발생하거나 사용자의 종료를 인지할 수 있습니다. 10Hz를 맞추기 위해 Loop마다 sleep을 걸어주고 있습니다. # Loop control Example while not rospy.is_shutdown(): ... rate.sleep() ROS에서 콘솔 로그를 얻는 방법으로 print 보다 rospy.log를 사용하기를 추천합니다. hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. ROS Timer ROS는 기본적으로 무한 Loop를 하나의 프로세스 안에서 동작시키는 프로그램입니다. Timer를 통해 일정 시간마다 동작하는 코드를 구현할 수 있습니다.\ncd my_first_pkg/scripts # spin_node.py 생성 spin_node.py #!/usr/bin/env python3 import rospy # callback method requires event, which is TimerEvent def hello_du(event=None): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) def my_first_node(): rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # Timer Class is kind of Thread. # It\u0026#39;s rule is execute sleep in certain period with given event. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드의 실행 결과는 이전과 같기 때문에 Timer와 spin에 대해서만 짚고 넘어가겠습니다.\nTimer는 크게 두가지 매개변수를 받습니다. 실행 주기와 Callback 함수입니다. 해당 주기마다 Callback 함수를 실행시킵니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) 앞으로 여러분들은 직접 while loop를 구현하기보다 rospy.spin()을 더 많이 사용하시게 될 겁니다. Timer를 선언한 이후, 하나의 Thread에서 막혀버리는 것을 방지하는 역할을 수행합니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() image from : python tutorial\nOOP Node Programming my_first_oop_node.py #!/usr/bin/env python3 import rospy class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except rospy.ROSInterruptException: pass 이후의 실습들을 위해 한가지 예시만 더 살펴보고자 합니다. 객체 지향을 사용한 ROS Node 작성방법입니다. 파이썬에서 OOP를 사용하기 위해 Class 키워드를 사용하며, self등 OOP와 관련된 내용은 모두 알고 있다는 상태에서 진행하겠습니다.\nOOP를 사용하면 main 메소드가 매우 간편해진다는 장점이 있습니다. 클래스를 생성하고, spin을 하기만 하면 됩니다. def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() OOP로 전환되면서 변경된 구현에 주목합시다. Timer의 Callback 함수로 클래스 메소드가 사용되었으며, 클래스 변수인 counter를 사용하여 구현한 점에 주목합니다. class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 앞으로, 대부분의 코드는 OOP 기반으로 작성됩니다. 파이썬의 클래스에 대해 숙지가 되어있지 않다면 꼭 복습하고 다음 강의를 청취하세요!\nROS Topic 다시 개념 학습으로 돌아와보았습니다. 아래 그림은 지난 강의의 rqt_graph입니다.\n위 그림에서 동그라미는 Node를 뜻하고, 화살표는 topic을 뜻합니다.\n이번 시간에는 이 Topic이 무엇인지 배워보고자 합니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름입니다. image from : docs.ros.org 그림에서와 같이 ROS Topic은\nPublisher(발행자) Subscriber(구독자)로 나누어 Topic의 송신, 수신자를 구분합니다. Publisher, Subscriber는 Node안에서 생성되며 별도로 사용할 수는 없습니다. Pub/Sub 사이에 Message가 전달되며, 이 길의 이름이 Topic인 것입니다. 주의할 점은, Publisher, Subscriber는 오로지 Topic의 이름으로 소통한다는 것입니다. 어떤 Node에 publish 할지 Publisher는 전혀 모르며 오로지 Topic이 같은 Subscriber가 데이터를 받게 됩니다. 더불어, Topic은 여러 Node들로 부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. ⇒ Topic의 중요한 속성이니 꼭 알아두셨으면 좋겠습니다.\nimage from : docs.ros.org Node와 Topic의 개념을 다시 한 번 다잡고 갑시다.\nNode는 실행되는 프로그램이며, ROS Master에 등록하고 관리됩니다. Node들 사이의 통신 메커니즘 중 Topic이라는 것이 있으며, 이는 Publisher와 Subscriber라는 개념을 갖고 있습니다. Publisher와 Subscriber 사이의 오가는 데이터는 특정한 타입을 갖습니다. 이를 Message라고 부릅니다. Topic Message 로봇 프로그래밍 시에는 다양한 센서 데이터들이 다뤄집니다. 센서 뿐만 아니라, 제어 데이터도 주고 받아야 합니다. ROS에서는 주로 사용되는 이러한 데이터 형식을 Message라는 이름으로 지칭하며, 여러 기본 형태를 제공합니다. 더불어 사용자가 직접 Message를 커스터마이징할 수도 있습니다.\n일전 예시의 분석을 통해 Topic과 Message에 대해 다시 한 번 살펴봅시다. # Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener 두 프로그램이 실행되고 있는 상태를 유지하면서, 아래 내용을 따라와주세요\nrostopic list를 통해 사용중인 topic들을 모두 조회 가능합니다. $ rostopic list /chatter /rosout /rosout_agg 특정 topic에 대한 자세한 정보를 알고 싶다면 rostopic info를 사용합니다. talker와 listener가 조회된 모습도 보입니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /talker_215337_1671763968667 (http://192.168.55.236:37863/) Subscribers: * /listener_215355_1671763970127 (http://192.168.55.236:44969/) 해당 topic이 사용중인 Message를 조회하기 위해 rostopic type을 사용합니다. $ rostopic type /chatter std_msgs/String rosmsg show를 통해 Message의 원형을 확인할 수 있습니다. $ rosmsg show std_msgs/String string data topic 데이터를 엿볼 수 있는 rostopic echo입니다. $ rostopic echo /chatter data: \u0026#34;hello world 1671764088.1913402\u0026#34; --- data: \u0026#34;hello world 1671764088.2913551\u0026#34; --- ... rostopic hz로 topic의 pub/sub 주기를 분석할 수 있습니다. $ rostopic hz /chatter subscribed to [/chatter] average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00014s window: 10 average rate: 9.999 min: 0.099s max: 0.100s std dev: 0.00023s window: 20 마지막으로 rqt_graph를 다시 한 번 살펴봅시다.\nrqt_graph 방금 살펴본 커멘드 라인들을 충분히 숙지하시기 바랍니다. 그러한 의미에서, 이번에는 Gazebo 예시를 분석해볼까 합니다.\n# Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun teleop_twist_keyboard teleop_twist_keyboard.py rostopic list 결과 $ rostopic list /clicked_point /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state ... 우리가 집중하고자 하는 topic은 로봇을 제어하는 /cmd_vel입니다.\nrostopic info 결과 $ rostopic info /cmd_vel Type: geometry_msgs/Twist Publishers: * /teleop_twist_keyboard (http://192.168.55.236:33903/) Subscribers: * /twist_mux (http://192.168.55.236:38201/) * /gazebo (http://192.168.55.236:33033/) rostopic type 결과 $ rostopic type /cmd_vel geometry_msgs/Twist geometry_msgs/Twist의 rosmsg show 결과 $ rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z /scan의 rostopic echo 결과 $ rostopic echo /scan header: seq: 0 stamp: secs: 204 nsecs: 678000000 frame_id: \u0026#34;rslidar\u0026#34; angle_min: -1.5707999467849731 angle_max: 1.5707999467849731 angle_increment: 0.008700000122189522 time_increment: 0.0 scan_time: 0.033330000936985016 range_min: 0.44999998807907104 range_max: 50.0 ranges: [inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, ... /scan의 rostopic hz결과 $ rostopic hz /scan subscribed to [/scan] WARNING: may be using simulated time average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 8 average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 17 rqt_graph에서 /cmd_vel을 찾아볼까요?\nrqt_graph Publisher 프로그래밍 이번 시간 사용할 Package는 py_topic_pkg 입니다. 실습 전 실행부터 해보겠습니다.\nPackage Build cd ~/catkin_ws catkin build py_topic_pkg source devel/setup.bash 예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg cmd_vel_pub.py 로봇이 아래와 같이 원을 그리며 움직일 것입니다.\ncmd_vel_pub.py #!/usr/bin/env python3 import rospy from geometry_msgs.msg import Twist class CmdVelPubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. topic queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) self.twist_ = Twist() def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) def cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: cmd_vel_node() except rospy.ROSInterruptException: pass 파이썬 ros 프로그래밍을 위한 rospy, 로봇의 속도 제어에 필요한 Message type인 Twist를 import 하고 있습니다. import rospy from geometry_msgs.msg import Twist rospy.Publisher를 통해 publisher를 생성할 수 있습니다. 이는 최소 3개의 매개변수를 필요로 합니다. topic 이름 topic type queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10)= 우리는 로봇의 제어 신호를 주기적으로 전송하고자 합니다. 따라서 Timer도 선언하였습니다. self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) 다음으로, Message Type인 geometry_msgs/Twist 값을 채웁니다. 현재 우리 로봇은 2차원 평면에서 움직이며, 로봇 형태 때문에 앞뒤 선속도와 각속도를 갖게 됩니다. ... self.twist_ = Twist() def pub_msg(self, event=None): self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 Message의 종류는 매우 많습니다. 구글을 통해 검색하면서 코딩하는 습관을 들여봅시다.\nfrom : http://docs.ros.org/ linear의 단위는 m/s 이며, angular의 단위는 rad/s 입니다. pi = 3.14\n마지막, 가장 중요한 topic publish는 생성한 Publisher의 publish() 메소드를 사용합니다. 미리 준비해둔 topic message를 사용합시다. def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) 이 Node를 실행하면, 우리의 ROS가 일정 주기에 맞추어 알맞게 topic publish를 실행시켜줄 것입니다. 우리는 정해진 구현에 맞추어 코드만 작성하면 되는 것이지요 😊\ndef cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() Subscriber 프로그래밍 이번 예시에는 로봇에 장착된 라이다 센서를 사용해보려 합니다. 예시를 실행해보겠습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg laser_scan_sub.py 실행 이후, 영상과 같이 박스를 로봇의 전방에 배치해봅시다. 터미널에 등장하는 문구에 집중해보세요. 박스가 추가되면서 출력창에 어떠한 변화가 생기나요?\n로봇에 부착된 라이다 센서는 전방 180도 사방으로 360개의 레이저를 흩뿌립니다.\n레이저의 특성상 물체를 맞고 되돌아오게 되며, 이 시간을 통해 물체와의 거리를 알 수 있습니다.\n예시의 프로그램은 로봇에 부착된 레이저에서 publish되는 데이터를 subscribe한 것입니다. 이를 프로그래밍하면서 python으로 subscriber를 다루는 방법에 대해 배워봅시다.\nlaser_scan_sub.py #!/usr/bin/env python3 import rospy from sensor_msgs.msg import LaserScan class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) def laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: laser_sub_node() except rospy.ROSInterruptException: pass 이번에 사용하는 topic message는 sensor_msgs/LaserScan입니다. import rospy from sensor_msgs.msg import LaserScan subscriber는 publisher와 달리 Timer가 필요하지 않습니다. publish되는 데이터가 없으면 아무 동작을 할 수 없으며, publish 주기에 맞추어 subscribe할 수밖에 없는 것이지요.\nsubscriber는 rospy.Subscriber로 생성하며 최소 3개의 매개변수를 요구합니다. topic 이름 topic message 이름 subscribe 마다 실행되는 callback 메소드 class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) 이 callback 메소드에서 주의해야 할 점은, 항상 callback method의 매개변수가 subscribe된 데이터라는 점입니다. 지금의 경우 LaserScan 타입의 데이터일 것입니다. # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) ... 마지막으로, 깔끔한 터미널 출력을 위해 print 함수를 사용하였습니다. print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) Subscriber 실행 시에는 항상 rospy.spin()을 잊지 말도록 합니다. spin 되지 않는다면 특정 쓰레드가 자원을 점유하기 때문에 subscriber의 상태를 갱신할 수 없습니다.\ndef laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() 과제 - 물체 회피하기 pub/sub의 개념을 잘 이해하였는지 알아볼 수 있는 과제를 준비해보았습니다. 정답이 따로 있는 것은 아니기에 부담 없이 해보시고, 저의 답안도 한번 살펴보세요.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Ternimal 2 rosrun py_topic_pkg collision_aviod.py Gazebo 예제를 실행하였다면, 로봇의 전방에 장애물을 놓아 진로를 막아봅니다. 여러분께서 구현해야 하는 것은, 라이다 센서를 사용하여 로봇이 회피 주행을 하도록 만드는 것입니다. 일종의 템플렛 코드를 첨부하였으며, my_collision_aviod.py라는 이름의 코드입니다.\n해당 코드의 TODO 부분을 작성하여 여러분만의 회피 알고리즘을 만들어 보세요!\n로봇의 라이다 데이터인 LaserScan을 Subscribe하여 Twist Type을 사용하는 scan topic으로 publish를 하게 됩니다. class CollisionAvoidNode: def __init__(self): self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.twist_ = Twist() def laser_cb(self, data): # TODO: Prevent robot from collision # make your own logic to do that return None 제가 작성한 예시를 수정하여 더욱 똑똑한 로봇을 구현하셔도 좋고, 자유롭게 실습해보시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/msg "
},
{
	"uri": "/kr/ros_basic_noetic/lecture6/",
	"title": "Lecture6 - ROS Service, Parameter",
	"tags": [],
	"description": "",
	"content": " 지난 시간 마지막 예시였던 장애물 회피 코드부터 간단하게 리뷰해보고자 합니다.\n제가 작성한 로직은 다음과 같습니다.\n과제를 해보셨다면 아시겠지만, 측정 범위를 벗어나게 되면 data.ranges는 inf 값을 갖게 됩니다. 이를 걸러내는 코드가 아래 부분입니다. for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: 저의 로직은, 정면을 기점으로 왼쪽과 오른쪽 각각 inf가 아닌 데이터의 개수를 카운팅합니다. 전체 데이터가 362개이고 마지막 데이터는 사용하기 않는 값이기 때문에, 180을 기점으로 잡았습니다. left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 이제, 제어 데이터를 만들어줍니다. ROS를 비롯하여 로봇 시스템에서는 대부분 오른손 좌표계를 사용합니다. 따라서 위에서 보았을 rospy.loginfo(hello_du)때 오른손이 감기는 반시계 방향이 + 부호를 갖게 됩니다. 이를 고려하여 각속도를 정했습니다. 180은 magic number, 일종의 변환 상수입니다. image from : 오로카\ndef laser_cb(self, data): left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 self.twist_.linear.x = 0.3 self.twist_.angular.z = (right_side_count - left_side_count) / 100 self.cmd_vel_pub_.publish(self.twist_) 지난 강의에서 이야기한 것과 같이 이 문제의 정답은 없습니다.\n다만, Topic의 Pub / Sub을 모두 사용할 수 있는지 스스로 점검해볼 수 있을 것입니다.\nROS Parameter 앞선 저의 예시에서 마지막 속도로 변환하는 부분 수식에 나누기 100이 있었던 것을 기억하시나요? 이런 상수를 직접 코드에 적는 것은 사실 추천되지 않습니다. 개발 이후 해당 상수를 변경하고자 하였을 시, 직접 코드를 수정하고 다시 실행해야 하기 때문에 불편을 야기합니다.\n이러한 문제의 해결 방법으로 ROS의 매개변수, parameter를 다루는 방법을 알아보겠습니다.\npy_param_pkg/scripts/various_params.py #!/usr/bin/env python3 import rospy class ParamNode: def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) rospy.loginfo(f\u0026#34;\u0026#34;\u0026#34; self.str_param_ = {self.str_param_} self.int_param_ = {self.int_param_} self.double_param_ = {self.double_param_} self.bool_param_ = {self.bool_param_} self.list_of_float_param_ = {self.list_of_float_param_} \u0026#34;\u0026#34;\u0026#34;) def param_node(): rospy.init_node(\u0026#39;param_node\u0026#39;, anonymous=True) param_node = ParamNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: param_node() except rospy.ROSInterruptException: pa 실행 결과는 다음과 같습니다. $ rosrun py_param_pkg various_params.py [INFO] [1672014267.630578]: self.str_param_ = hello_world self.int_param_ = 2023 self.double_param_ = 3.14 self.bool_param_ = True self.list_of_float_param_ = [1.0, 2.0, 3.0, 4.0] 매개변수를 선언하고 기본값을 지정하는 방법은 rospy.get_param을 사용하는 것입니다. 두번째 기본값을 잘 보면 어떤 타입을 사용하는지 알 수 있습니다. def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) parameter 앞에 붙는 물결 표시 (~)는 private parameter를 의미합니다. 이에 대해 궁금하다면 아래의 추가 자료를 학습해보세요. global_name = rospy.get_param(\u0026#34;/global_name\u0026#34;) relative_name = rospy.get_param(\u0026#34;relative_name\u0026#34;) private_param = rospy.get_param(\u0026#39;~private_name\u0026#39;) default_param = rospy.get_param(\u0026#39;default_param\u0026#39;, \u0026#39;default_value\u0026#39;) 추가 자료 : wiki.ros\n매개변수를 변경하는 가장 보변적인 방법은 launch file을 사용하는 것입니다. launch file의 param 태그를 사용하여 Node에 원하는 parameter를 전달할 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; ROS 프로그래밍을 하다 보면 매개변수가 아주 많이 필요한 경우가 있습니다. 이럴 때마다 launch file에 param 태그 라인을 추가하는 것은 매우 귀찮은 일입니다.\nyaml이라는 형식의 파일로 매개변수를 한번에 관리할 수 있습니다.\npy_param_pkg/param/config.yaml str_param: \u0026#34;yaml string\u0026#34; int_param: 9 double_param: 2.71828 bool_param: \u0026#34;false\u0026#34; list_of_float_param: [3., 2., 1.] py_param_pkg/launch/param_with_yaml.launch \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;rosparam command=\u0026#34;load\u0026#34; file=\u0026#34;$(find py_param_pkg)/param/config.yaml\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; launch file에 rosparam 태그를 추가하고, load command를 사용하며 사용하는 yaml 파일의 위치를 file 옵션을 통해 전달합니다.\nROS parameter Commands rostopic, rosnode와 같이 parameter 또한 터미널 명령어를 갖고 있습니다.\n접근 가능한 모든 parameter들을 나열합니다. rosparam list 특정 paramter의 값을 얻고자하면 아래 키워드를 사용합니다. rosparam get \u0026lt;parameter_name\u0026gt; 선언되어 있는 parameter의 값을 변경하고 싶은 경우 아래 키워드를 사용합니다. rosparam set \u0026lt;parameter_name\u0026gt; \u0026lt;value\u0026gt; 여러분들이 작성한 회피 프로그램에도 매개변수로 작용하는 상수들이 있을 것입니다. 이를 parameter로 변경하여 launch file과 yaml file로 업데이트하는 작업을 해보세요\nROS Service Topic에 이어 ROS의 통신 메커니즘 두번째로 Service를 배워보겠습니다.\nService가 동작하는 방식은 아래와 같습니다.\n그림과 같이 Client Node가 Server Node로 request를 주면, 해당 request에 대응하는 적절한 response가 다시 Client에게로 전달됩니다. 이 과정을 Service Call이라고 부릅니다.\nimage from : docs.ros.org\n하나의 Service Server에는 여러 Client Node가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지는 못합니다. 두 Node에서 동시에 request가 왔다면, 조금이라도 먼저 통신한 Node의 작업을 우선 진행하고, 그동안 다른 Node는 기다리고 있어야 합니다. image from : https://docs.ros.org/en/foxy/Tutorials/Services/Understanding-ROS2-Services.html\nTopic과 비교하여 Service의 특징을 알아봅시다.\n1:1 통신 : Topic publish를 하면 여러 Node가 Subscribe 가능합니다. 반면, Service는 request가 온 대상에게만 response를 줍니다. 순차적 통신 : Service Server는 동시에 여러 request를 처리할 수 없습니다. 현재 작업중인 request가 처리될 때 까지 다른 request는 기다리고 있어야 합니다. 단발성 : Topic은 대부분 지속적으로 publish를 진행하는 반면, Service는 1회성 통신입니다. 실제 로봇 프로그램에서 Service는 어떻게 사용될 수 있을지, 예시를 통해 살펴봅시다.\n예제 패키지 빌드 cd ~/catkin_ws catkin build py_service_pkg source devel/setup.bash Service Client 예제 실행 - 아르키메데스 나선 # Terminal 1 roslaunch py_service_pkg empty_gazebo.launch # Terminal 2 rosrun py_service_pkg spawn_model_client.py 방금 실행한 예시는 Gazebo에게 box를 등장시켜달라고 하는 Service Client를 포함하고 있습니다.\nBox가 등장하는 위치를 아래 사진과 같은 수식에 맞추어 설정한 것 뿐입니다.\n그럼, 코드를 분석해 볼까요?\n필요한 파이썬 패키지들을 import 합니다. import math import rospy import rospkg from geometry_msgs.msg import Pose from gazebo_msgs.srv import SpawnModel 여기서 중요한 점은 msg와 srv 부분입니다. topic에서 사용되는 데이터 타입이 Message였고, 프로그래밍 시에는 msg로 사용하였습니다.\nService에서는 msg가 아니라 srv라는 데이터 타입을 사용합니다. image from : rsl.eth\n이 srv는 msg와 다른 점이 있는데, request와 response로 나뉘어 있다는 점입니다. \u0026mdash; 표시를 기점으로 위쪽은 Server에게 전달하는 request, 아래쪽은 Server가 다시 회답하는 response 부분입니다. 이번 예시에서 사용한 gazebo_msgs/SpawnModel도 아래와 같은 구조를 갖습니다. image from : docs.ros.org\ngazebo_msgs/SpawnModel를 살펴보면 파란 글자로 geometry_msgs/Pose라는 부분이 있습니다. 이와 같이 srv는 다른 msg를 품을 수도 있고, 이렇게 만든 srv를 또다시 다른 srv에 포함시킬 수도 있습니다.\n코드 구현 관점에서, geometry_msgs/Pose는 Model을 등장시킬 초기 위치를 지정하는데 사용됩니다.\n# initial_pose initial_pose = Pose() initial_pose.position.x = 0.0 initial_pose.position.y = -1 initial_pose.position.z = 0.2 # z rotation -pi/2 to Quaternion initial_pose.orientation.z = -0.707 initial_pose.orientation.w = 0.707 Service Client의 생성과 사용은 아래와 같습니다. spawn_model_prox = rospy.ServiceProxy(\u0026#34;gazebo/spawn_urdf_model\u0026#34;, SpawnModel) ... result = spawn_model_prox( entity_name, model_xml, robot_namespace, initial_pose, reference_frame ) rospy.ServiceProxy()는 2개의 매개변수를 필요로 합니다.\nservice 이름 service 데이터 타입 (srv) 생성한 client로 request를 하기 위해서는 생성한 인스턴스에 매개변수를 전달하기만 하면 됩니다. 마치 함수 호출처럼 말이지요. 이는 ServiceProxy 내부적으로 call 메소드가 구현되어있기 때문입니다.\nservice call의 결과로 result가 반환되며, 예시에서는 성공 여부를 반환하도록 되어 있습니다.\n추가적으로, model을 불러오는 부분을 간단하게 설명하고자 합니다. # model_xml rospack = rospkg.RosPack() model_path = rospack.get_path(\u0026#34;py_service_pkg\u0026#34;) + \u0026#34;/urdf/\u0026#34; with open(model_path + model_name + \u0026#34;.urdf\u0026#34;, \u0026#34;r\u0026#34;) as xml_file: model_xml = xml_file.read().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) Gazebo는 urdf라는 파일을 전달하면 해당 파일을 기반으로 시뮬레이션에 물체를 등장시켜줍니다. 이 urdf라는 것은 로봇을 표현하기 위한 일종의 약속된 파일 확장명입니다.\nimage from : spart\n세상 모든 로봇들은 joint와 link로 표현 가능합니다. 이러한 개념을 바탕으로 로봇의 특성을 텍스트 파일로 표현하는 형식이 바로 urdf이며, 아래와 같이 여러 태그와 속성을 사용하여 작성 가능합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;link name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!-- Inertia values were calculated to be consistent with the mass and geometry size, assuming a uniform density. --\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0108\u0026#34; ixy=\u0026#34;0\u0026#34; ixz=\u0026#34;0\u0026#34; iyy=\u0026#34;0.0083\u0026#34; iyz=\u0026#34;0\u0026#34; izz=\u0026#34;0.0042\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; ROS Service Commands gazebo/spawn_urdf_model과 같은 service는 gazebo_ros를 사용할 때 자동으로 함께 실행됩니다. 이렇게 현재 어떠한 service가 존재하며, 또 구체적인 정보는 어떻게 조회하는지 알아봅시다.\n현재 사용 가능한 모든 service를 조회해봅시다. $ rosservice list /delete_entity /gazebo/describe_parameters /gazebo/get_parameter_types /gazebo/get_parameters /gazebo/list_parameters /gazebo/set_parameters ... 리눅스의 grep 명령어를 함께 사용해 보세요.\n특정 service가 어떤 srv 타입을 사용하는지 검색하고 싶다면 다음 커멘드 라인을 사용합니다. $ rosservice type /gazebo/spawn_urdf_model gazebo_msgs/SpawnModel 이렇게 검색된 srv는 rossrv show와 결합할 때 더욱 진가를 발휘합니다. $ rossrv show `rosservice type /gazebo/spawn_urdf_model` string model_name string model_xml string robot_namespace geometry_msgs/Pose initial_pose geometry_msgs/Point position float64 x float64 y float64 z geometry_msgs/Quaternion orientation float64 x float64 y float64 z float64 w string reference_frame --- bool success string status_message 특정 srv 타입에 대한 자세한 정보는 다음과 같이 조회할 수 있습니다. $ rosservice info /gazebo/spawn_urdf_model Node: /gazebo URI: rosrpc://192.168.55.236:55405 Type: gazebo_msgs/SpawnModel Args: model_name model_xml robot_namespace initial_pose reference_frame gazebo_ros에서 제공하는 다양한 service들이 있습니다. rosservice 커멘드를 사용하여 조회해보고 여러분들만의 Application을 생각해 보세요.\nService Server 예제 실행 - 긴급 정지 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_service_pkg emergency_stop.py # Terminal 3 rqt 두번째 Node 실행 시, 로봇이 원을 그리며 움직이기 시작합니다. 세번째 명령어를 통해 등장하는 rqt는 아래와 같이 사용 가능합니다. 로봇에게 긴급 정지 명령을 내려보겠습니다. 실제 로봇 개발시에도 Service는 이렇게 단발성이고, 빠르게 실행되어야 하는 동작에 주로 사용됩니다. 더불어, 지금 실행한 예시가 Service Server임을 다시 한 번 상기시켜드립니다.\nimage from : rsl.eth\n코드를 분석해 봅시다.\npy_service_pkg/scripts/emergency_stop.py from geometry_msgs.msg import Twist from std_srvs.srv import SetBool, SetBoolResponse 이번에 사용하는 데이터 타입은 크게 2 종류입니다.\n로봇 제어 topic에 사용되는 Twist 긴급 정지 service에 사용될 SetBool image from : docs.ros.org\nSetBoolResponse이라는 것은 SetBool srv 중 response 부분에 해당합니다. 기본 데이터 타입 이름 + Response를 붙여주기만 하면 사용 가능합니다.\nROS의 msg, srv는 다양한 언어와 상황을 고려하도록 만들어져 있으며, ROS 2에서는 IDL이라는 이름으로 더욱 발전하였습니다. 이후의 커스텀 데이터 타입 제작을 통해 이 과정을 다시 살펴봅시다.\n다음으로 통신 메커니즘을 생성합니다. class EmergencyStopNode(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;emergency_stop\u0026#34;, SetBool, self.stop_cb) 로봇 제어를 위한 topic publisher와 service server를 생성합니다.\nrospy.Service()를 통해 Service Server를 생성할 수 있으며 다음과 같은 매개변수를 필요로합니다.\nService 이름 srv 타입 Client로부터 request가 올 시 실행되는 callback 함수 callback 함수는 일전 subscriber에서 살펴본 바 있습니다. service server의 callback 함수는 항상 매개변수로 request srv를 받습니다. 그리고 return 값은 항상 response가 됩니다.\ndef stop_cb(self, request): ... return self.response_ request 데이터 중 boolean 값을 갖는 data의 true / false 여부에 따라 로봇의 정지 여부가 결정됩니다. if request.data is True: self.twist_msg_.linear.x = 0.0 self.twist_msg_.angular.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) self.response_.success = True self.response_.message = \u0026#34;Successfully Stopped\u0026#34; else: self.response_.success = False self.response_.message = \u0026#34;Stop Failed\u0026#34; 마지막에 사용한 rqt의 service caller는 별도의 프로그래밍이나 복잡한 터미널 명령어 없이도 손쉽게 service를 다룰 수 있게 해주는 ROS의 툴입니다.\n지금까지 ROS Service에 대해 배워보았습니다. Topic과 더불어 많이 사용되는 통신 메커니즘이므로 잘 숙지하고 복습하시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ko.wikipedia.org/wiki/아르키메데스_와선 https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/Services "
},
{
	"uri": "/kr/ros_basic_noetic/lecture7/",
	"title": "Lecture7 - Rqt Tools and rosbag, ROS Time",
	"tags": [],
	"description": "",
	"content": " 강의 초반, 다양한 rqt tool들을 살펴본 바 있습니다. 이제는 Topic과 Service에 모두 익숙해졌기 때문에, rqt의 많은 기능들을 사용할 수 있습니다. 다시 한 번 rqt를 살펴보면서 편리한 툴들의 사용법을 익혀봅시다.\nMessage Publisher \u0026amp; Topic Monitor 강의자를 따라 다음과 같이 화면을 구성합니다.\nplugins ⇒ topics ⇒ Message Publisher pulgins ⇒ topics ⇒ Topic Monitor message publisher를 사용하면 코딩 없이 cmd_vel을 publish가 가능합니다. Topic Msg에 원하는 데이터를 채워넣은 뒤, 주기를 선택한 후 체크박스를 클릭하면 로봇이 움직이기 시작합니다. Topic Monitor를 사용하면, 여러 데이터들을 효과적으로 모니터링 가능합니다. Topic Publisher와 동일하게 체크박스를 눌러 topic을 선택한 뒤, 변하는 데이터를 확인해봅시다. 코딩 없이 간단히 값의 확인과 동작 여부를 확인할 수 있는 툴들이었습니다.\nRQT Multiplot 수치 데이터를 그래프로 보고싶은 경우 rqt의 multiplot이 유용하게 사용됩니다.\nrosrun rqt_multiplot rqt_multiplot /odom topic의 X,Y position을 기준으로 그래프를 그려보도록 하겠습니다. 아래의 gif를 통해 모든 과정을 기록하였으니 차근차근 따라와주세요.\nRQT Console 지금까지 ROS의 콘솔 로그를 위해 rospy.loginfo()를 사용하였습니다. 사실 ROS에는 loginfo말고도 다양한 level의 logger level이 존재합니다. 실습을 통해 살펴봅시다.\nrospy logger level # Terminal 1 roscore # Terminal 2 rosrun my_first_package logger_level.py 코드의 내용과 함께 예시를 살펴봅시다. def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.logdebug(hello_du) rospy.loginfo(hello_du) rospy.logwarn(hello_du) rospy.logerr(hello_du) rospy.logfatal(hello_du) self.counter_ += 1 ROS는 총 5가지의 logger level을 갖추고 있으며, Debug 부터 Fatal로 갈수록 더 높은 level을 갖는다고 보시면 됩니다. Info level 부터 콘솔 출력이 이루어지며, Python의 stdout를 사용합니다.\nimage from : 51CTO 상황에 따라 각기 다른 level의 log를 사용하도록 하면, 실제 로봇 개발시에도 큰 도움이 됩니다.\nrqt에는 이러한 다양한 level을 갖는 ros의 log를 필터링하는 rqt console이라는 툴이 있습니다. 사용 방법을 함께 알아봅시다.\n그 밖에도 수많은 rqt 도구들이 있지만, 모두 살펴보는 대신 링크로 대체하겠습니다. \u0026gt; ROS Wiki\nROS Bags rqt 툴에 속하지는 않지만, 개발 시 매우 유용한 ROS의 기능을 하나 더 소개시켜드리고자 합니다.\nrosbag은 프로그램 동작 중 발생하는 message 데이터를 기록하고 복기할 수 있게 해주는 툴입니다. 로봇 알고리즘을 개발할 때, 같은 상황에 대해 성능을 비교하는 경우, 혹은 교육 목적으로 데이터셋을 제공하는 경우 등에 매우 유용하게 사용할 수 있습니다.\nrosbag 사용법을 함께 실습해보겠습니다.\nsmb gazebo를 실행합니다. roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school rosbag의 사용 시 여러 옵션들이 있습니다. -o 옵션으로 rosbag의 이름을 지정합니다. -a 옵션 사용 시 모든 topic을 저장합니다. rosbag의 종료는 ctrl + c를 사용합니다. rosbag record -o first_rosbag /scan /tf /tf_static /tf와 /tf_static은 왜 저장하는 것일까요? 생각해봅시다.\nrosbag info를 통해 저장을 마친 rosbag의 정보를 조회할 수 있습니다. $ rosbag info first_rosbag_\u0026lt;time-format-sth\u0026gt;.bag path: first_rosbag_2022-12-27-15-51-55.bag version: 2.0 duration: 4.8s start: Jan 01 1970 09:07:35.31 (455.31) end: Jan 01 1970 09:07:40.12 (460.12) size: 83.8 KB messages: 49 compression: none [1/1 chunks] types: sensor_msgs/LaserScan [90c7ef2dc6895d81024acba2ac42f369] topics: /scan 49 msgs : sensor_msgs/LaserScan 저장 완료된 rosbag을 다시 복기해봅시다. $ rosbag play first_rosbag_2022-12-27-15-56-23.bag [ INFO] [1672124296.822088842]: Opening first_rosbag_2022-12-27-15-56-23.bag Waiting 0.2 seconds after advertising topics... done. ... rviz를 통해 시각화까지 해봅시다. rosbag은 기본적으로 topic을 저장합니다.\nrviz 화면을 살펴보면 아래와 같은 Warning이 발생할 것입니다. 그런데 이 문구, 익숙하지 않나요?\n[ WARN] [1672124550.336965013]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336981403]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336991753]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.337003964]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.356035553]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame base_link at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356945321]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356960231]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356970561]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.076000 according to authority unknown_publisher ROS Time 일전 강의에서 언급한 바와 같이, 이번 강의에 ROS의 시간 체계에 대해서 다잡고 가고자 합니다.\nrospy.loginfo를 통해 콘솔에 출력되는 시간과 같이 ROS에서 기본적으로 사용되는 시간의 기준은 PC의 Clock입니다. (이를 wall timer라고 부릅니다.) ROS 프로그램은 일정 주기를 갖고 무한히 반복되는 상황이 잦습니다. 이때 사용하는 주기가 정확해야 할 것입니다. 우리는 2023년 00월 00일이라는 시간체계를 사용하지만, Gazebo와 같은 시뮬레이션 툴은 시작되는 시점이 곧 0분 0초가 됩니다. 이러한 시간의 차이로 인해 warning과 error가 빈번하게 발생합니다. 그럼, 실질적으로 ROS에서 시각과 주기, 시간은 어떻게 다루는지 예시와 함께 python 코드를 살펴봅시다.\nros_time.py $ rosrun my_first_package ros_time.py [INFO] [1672127477.793024]: Current time 1672127477 792964935 [INFO] [1672127477.793593]: Current time to_sec 1672127477 [INFO] [1672127477.794082]: Past time 1672127477 292964935 [INFO] [1672127477.893132]: Current time 1672127477 893082141 [INFO] [1672127477.893684]: Current time to_sec 1672127477 [INFO] [1672127477.894148]: Past time 1672127477 393082141 ... 코드는 다음 위치에서 확인이 가능합니다. \u0026gt; https://github.com/RB2023ROS/du2023-ros1/blob/main/my_first_package/scripts/ros_time.py\nrospy Time instance rospy에서는 Time이라는 클래스로 시간을 표현합니다. 가장 많이 사용되는 현재 시간은 rospy.Time.now() 로 파악할 수 있으며, 이는 sec와 nsec등의 클래스 변수를 갖고 있습니다.\ndef hello_du(self, event=None): now = rospy.Time.now() seconds = now.to_sec() rospy.loginfo(\u0026#34;Current time %i %i\u0026#34;, now.secs, now.nsecs) rospy.loginfo(\u0026#34;Current time to_sec %i\u0026#34;, seconds) rospy Time Duration 시간 간격을 나타내는 클래스로 Duration이 사용되며, Time 인스턴스와 +,- 연산이 가능합니다.\ndelta = rospy.Duration(0.5) past = now - delta rospy.loginfo(\u0026#34;Past time %i %i\u0026#34;, past.secs, past.nsecs) rospy Rate while loop와 Rate를 사용하여 일정 주기다마 반복되는 구현이 가능합니다. 이때 사용되는 시간 기준은 PC의 Clock입니다.\nr = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): time_ex.hello_du() r.sleep() Topic vs Service and Action 지금까지 ROS의 통신 메커니즘으로 Topic과 Service에 대해 배워보았습니다. 그런데, 사실 ROS의 통신 메커니즘에는 Action이라는 한가지가 더 있습니다.\nAction은 Topic과 Service 모두의 특징을 갖고 있는 진보된 통신 메커니즘입니다. Action은 Feedback이라는 것으로 Goal Request 이후 계속적인 데이터 송수신이 가능합니다. Action은 ROS 2 강의에서 살펴볼 예정으로 어떻게 사용될 수 있을지 한번 고민해보세요.\nimage from : docs.rog.org 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://docs.ros.org/en/foxy/index.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture8/",
	"title": "Lecture8 - Deal with Open Source Projects, Custom Interfaces",
	"tags": [],
	"description": "",
	"content": "Deal with Open Source Projects 이번 시간에는 오픈 소스 프로젝트를 사용하는 방법에 대해 배워보겠습니다. 보다 실질적인 사용 방법을 보여드리기 위해 저 또한 여러분들과 같은 상황에서 처음부터 하나씩 같이 해보겠습니다.\n오늘 데모하고자 하는 로봇 소프트웨어는 드론 시뮬레이션입니다. 지금까지 지상을 움직이는 바퀴 로봇만을 다루었기 때문에 새로운 플렛폼을 동작시켜보고자 합니다.\n항상 시작은 구글링부터!! 검색 결과 원하는 패키지를 찾은 것 같습니다. \u0026gt; https://github.com/RAFALAMAO/hector-quadrotor-noetic 목적에 부합하는 오픈소스를 찾기 위해서 아래와 같은 기본적인 내용을 고려해야 합니다.\n버전 호환성 구체적인 목표에 부합하는지 Star, Fork를 통해 검증된 소스코드임을 확인 Issue를 통해 사용 중 문제가 있지는 않은지 Readme를 따라 package build를 진행하고 최초 실행을 해보겠습니다.\n# Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun hector_ui ui_hector_quad.py 동작에는 문제가 없어보입니다. 그럼 이 프로젝트가 내부적으로 어떻게 구현되어있는지 분석해봅시다.\nrqt_graph 로봇의 위치를 알려주는 topic인 /ground_truth/state와 /ground_truth_to_tf/pose를 파악할 수 있습니다. gazebo에서 물체의 절대적인 위치를 알려주기 때문에 이를 ground truth라고 부르고 있습니다.\n이번에는 조종 프로그램의 소스코드를 확인해봅시다. (hector_quadrotor_noetic/hector_ui/src에 위치하고 있습니다.) #Callback de pose y orientacion simulador def pose_callback(data): x_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.x)) y_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.y)) z_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.z)) def rot_callback(data): z_o.set(\u0026#34;{0:.2f}\u0026#34;.format( math.degrees(quaterionToRads(data)) )) rospy.init_node(\u0026#39;HectorQ_GUI\u0026#39;, anonymous=False) #Subscribers posicionLider_sub = rospy.Subscriber(\u0026#34;/ground_truth/state\u0026#34;, Odometry , pose_callback) orientaLider_sub = rospy.Subscriber(\u0026#34;/ground_truth_to_tf/pose\u0026#34;, PoseStamped , rot_callback) 두 종류의 subscriber가 존재하며 각각 UI의 상태를 업데이트하는 것 같이 보입니다.\n이번에는 launch file을 분석해봅시다 - hector_quadrotor/hector_quadrotor_gazebo/launch/quadrotor_empty_world.launch \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; gazebo_ros의 empty_world.launch, hector_quadrotor_gazebo의 spawn_quadrotor.launch가 실행되며, model이라는 argument를 갖습니다.\nspawn_quadrotor.launch에는 다음과 같은 node들이 실행됩니다.\nspawn_model robot_state_publisher ground_truth_to_tf controller.launch ⇒ controller_spawner 이렇게 rqt 툴들과 코드의 구조를 파헤치면서 전체 구조를 파악할 수 있으며 원하는 부분만을 고치면서 Package를 발전시켜나가는 것입니다.\nlaunch file의 응용을 실습해봅시다. 일전 배워본 husky gazebo와 hector gazebo를 함께 사용해보는 것입니다.\nhusky gazebo 는 다음과 같은 내용을 담고 있었습니다. gazebo_ros를 실행시키고 husky model을 spawn하는 또다른 launch file을 include 하였습니다. \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; default=\u0026#34;worlds/empty.world\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_name)\u0026#34;/\u0026gt; \u0026lt;!-- world_name is wrt GAZEBO_RESOURCE_PATH environment variable --\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/spawn_husky.launch\u0026#34;\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/launch\u0026gt; 그럼, 겹치는 부분을 제외하고 quadrotor_empty_world.launch의 내용을 추가하여 새로운 launch file을 만들어 봅시다. (hetero_spawn.launch 생성) \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 아래와 같은 오류가 발생하네요, 이는 robot_state_publisher node가 중복되기 때문에 발생하는 문제입니다. RLException: roslaunch file contains multiple nodes named [/robot_state_publisher]. Please check all \u0026lt;node\u0026gt; \u0026#39;name\u0026#39; attributes to make sure they are unique. Also check that $(anon id) use different ids. The traceback for the exception was written to the log file 이를 해결하기 위해서, 저는 다른 launch file(spawn_two_quadrotors.launch)을 참고해보았습니다. group 태그를 사용하면 같은 로봇의 중복 선언을 namespace를 통해 구분할 수 있게됩니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;group ns=\u0026#34;uav2\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 이제, hetero_spawn.launch를 최종 수정해봅시다. \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;name\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;tf_prefix\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(arg model)\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;z\u0026#34; value=\u0026#34;1.0\u0026#34; /\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 실행 후 topic을 조회해보면, 아래와 같이 quadrotor의 topic 앞에 namespace가 추가되어 있는 모습이 확인 가능합니다. 여러 로봇을 사용하게 되면 /cmd_vel, /scan등 사용하는 topic의 이름이 중복될 수 있어 namespace를 추가 설정하는 것이 일반적입니다.\n$ rostopic list /clock /cmd_vel /husky_velocity_controller/cmd_vel /husky_velocity_controller/odom /husky_velocity_controller/parameter_descriptions /husky_velocity_controller/parameter_updates /imu/data /odometry/filtered ... /uav1/aerodynamics/wrench /uav1/cmd_vel /uav1/command/motor /uav1/command/twist /uav1/command/wrench /uav1/fix_velocity ... 마지막으로, 로봇을 제어해보면서 이번 세션을 마무리해보겠습니다. gazebo의 world를 바꾸거나, husky가 아닌 smb로 모델을 바꾸는 등 응용 예시들을 직접 해보면서 launch file의 사용에 익숙해지시기 바랍니다.\n# husky 제어 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # quadrotor 제어 rosrun hector_ui ui_hector_quad_leader.py ROS Custom Interfaces ROS에서 기본 제공되는 msg와 srv도 훌륭하지만, 상황에 따라 나만의 custom msg/srv를 사용해야 하는 경우가 있습니다. 이번 시간에는 custom interface를 만들어보고, 사용해보겠습니다.\n드론의 이착륙을 제어하는 srv를 만들어보고자 합니다.\n이륙/착륙을 구분하는 string이 필요할 것이며, 기준은 시간을 사용하고자 합니다. ( ex - 2초간 이륙 ) service request는 성공 여부인 bool type으로 해보겠습니다. custom interface를 만들기 위해 저는 별도의 package를 생성하였습니다. cd ~/catkin_ws/src/du2023-ros1 catkin_create_pkg custom_interfaces package 내부에 msg 혹은 srv라는 폴더를 만들고, custom interface를 정의하는것이 추천됩니다. cd custom_interfaces mkdir srv # QuadrotorControl.srv 생성 string command uint8 seconds --- bool success custom_interfaces package의 package.xml을 수정합니다. \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt; custom_interfaces package의 CMakeLists.txt를 수정합니다. # 1. find_package 수정 find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) # 2. catkin_package 주석 해제 후 수정 catkin_package( ... CATKIN_DEPENDS message_runtime ... ...) # 3. add_service_files에 파일 반영 add_service_files( FILES QuadrotorControl.srv ) # 4. generate_messages 주석 해제 후 수정 generate_messages( DEPENDENCIES std_msgs # Or other packages containing msgs ) custom interface를 빌드하고 생성을 확인해봅시다. $ catkin build custom_interfaces $ rossrv show custom_interfaces/QuadrotorControl string command uint8 seconds --- bool success 지금 생성한 QuadrotorControl은 catkin_ws에서만 사용 가능한 srv라는 점에 유의합니다. 다른 workspace에서는 QuadrotorControl에 대해 알 길이 없습니다.\nCustom Interfaces 사용해보기 작성한 QuadrotorControl를 사용하여 Service Server를 만들어봅시다! 정해진 시간동안 takeoff와 land 움직임을 수행하는 Service입니다. # Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun py_service_pkg quadrotor_custom_srv.py # Terminal 3 rqt 소스 코드는 이 링크에서 확인이 가능합니다.\ncustom_interfaces package에서 QuadrotorControl srv를 import 하며, 로봇의 제어를 위해 Twist msg도 import 하였습니다. import rospy from geometry_msgs.msg import Twist from custom_interfaces.srv import QuadrotorControl, QuadrotorControlResponse Service Server와 Topic Publisher를 생성합시다. class QuadRotorUpDown(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;up_down\u0026#34;, QuadrotorControl, self.up_down_cb) self.twist_msg_ = Twist() self.response_ = QuadrotorControlResponse() rospy.loginfo(\u0026#34;Quadrotor Up-Down Server Started\u0026#34;) callback 함수인 up_down_cb입니다. command가 land/takeoff일 때의 경우를 나누고, 그 이외의 입력은 오류로 판명합니다. def up_down_cb(self, request): if request.command == \u0026#34;land\u0026#34;: self.twist_msg_.linear.z = -0.5 self.response_.success = True elif request.command == \u0026#34;takeoff\u0026#34;: self.twist_msg_.linear.z = 0.5 self.response_.success = True else: rospy.logwarn(\u0026#34;Unknown Command\u0026#34;) self.response_.success = False return self.response_ request의 seconds 시간동안 로봇이 움직여야 할 것이며, 이를 위해 now를 갱신하며 지나간 시간을 계속해서 tracking 합니다. start = rospy.Time.now() now = rospy.Time.now() while (now - start).secs \u0026lt; request.seconds: now = rospy.Time.now() self.cmd_vel_pub_.publish(self.twist_msg_) 모든 동작이 완료된 이후에는 로봇을 다시 정지시킵니다. rospy.loginfo(f\u0026#34;{request.command} done, quadrotor stop\u0026#34;) self.twist_msg_.linear.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) return self.response_ 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://github.com/RAFALAMAO/hector-quadrotor-noetic https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv "
},
{
	"uri": "/kr/ros_basic_noetic/lecture9/",
	"title": "Lecture9 - ROS TF and Examples",
	"tags": [],
	"description": "",
	"content": " 대부분의 로보틱스 과정들에서 가장 먼저 다루는 것이 바로 좌표계 변환(Transformation) 입니다. 로봇은 수많은 joint와 link로 이루어져 있기 때문에 좌표계를 다루는 일이 매우 빈번합니다.\nROS에서는 TF라는 특수한 형태로 이 좌표계와 시간을 함께 다루고 있습니다. 예시와 설명을 통해 ROS의 TF에 대해 배워봅시다 😊\nimage from : eth robot dynamics lecture notes ROS는 오픈소스이니만큼 사용자들이 원하는 기능들에 맞추어 변화가 빠릅니다. 하지만 이것이 단점이 되는 경우도 있는데, 이전 버전과 최신 버전의 호환성 문제가 종종 발생합니다.\ntf 또한 tf2로 개편되면서 코드의 수정이 있었으며, 이번 강의에서는 tf2를 중심으로 살펴보겠습니다.\nimage from : wiki.ros 예시를 먼저 살펴봅시다.\ntf broadcaster # setup example catkin build py_tf2_tutorial source devel/setup.bash roscore # Terminal 1 rosrun turtlesim turtlesim_node # Terminal 2 rosrun py_tf2_tutorial turtle_tf2_broadcaster.py # Terminal 3 rosrun turtlesim turtle_teleop_key # Terminal 4 rviz rviz를 실행한 뒤 아래와 같이 설정합니다. rviz에서 보이는 세가지 색상의 막대가 바로 tf 입니다.\nx,y,z의 각 축을 각기 다른 색으로 표현하였으며, 연관된 좌표계끼리는 노란 선을 통해 연결한 모습이 보입니다.\nTerminal 1에서 실행시킨 프로그램은 turtlesim이라는 것으로, 2차원 평면에서 거북이 형태의 로봇을 시뮬레이션한 프로그램입니다. 이제, Terminal 3에 커서를 두고 거북이를 움직이면서, rviz와 turtlesim의 변화를 살펴보세요. 거북이를 조종함에 따라 변화하는 rviz 화면을 확인할 수 있습니다.\n전체 코드는 아래 링크에서 확인할 수 있으며, 지금은 필요한 부분만 집중적으로 분석해보겠습니다.\nhttps://github.com/RB2023ROS/du2023-ros1/blob/main/py_tf2_tutorial/scripts/turtle_tf2_broadcaster.py\ntf 또한 하나의 Package입니다. 이에 따라 관련된 python import가 필요합니다. import rospy # Because of transformations import tf_conversions import tf2_ros import geometry_msgs.msg import turtlesim.msg tf의 데이터 송출은 broadcast라고 부릅니다. topic의 publisher와 같이 tf에서는 TransformBroadcaster를 사용하며 sendTransform이라는 메소드를 사용합니다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() ... br.sendTransform(t) TransformBroadcaster가 사용하는 데이터 타입은 geometry_msgs.msg.TransformStamped입니다. 해당 데이터 타입에는 3차원 좌표계에서의 위치, 방향, 그리고 시간이 포함되어 있습니다. image from : docs.ros.org\n해당 데이터 타입에 적절한 값을 채워넣어준 다음, 최종 broadcast가 진행됩니다. 주의할 점으로 쿼터니언 각도 체계를 사용했다는 점입니다. # prepare tf msg t = geometry_msgs.msg.TransformStamped() t.header.stamp = rospy.Time.now() t.header.frame_id = \u0026#34;world\u0026#34; t.child_frame_id = turtlename t.transform.translation.x = msg.x t.transform.translation.y = msg.y t.transform.translation.z = 0.0 q = tf_conversions.transformations.quaternion_from_euler(0, 0, msg.theta) t.transform.rotation.x = q[0] t.transform.rotation.y = q[1] t.transform.rotation.z = q[2] t.transform.rotation.w = q[3] 쿼터니언은 직관적으로 이해하기는 힘든 각도 체계입니다. 계산의 편의를 위해 다음과 같은 사이트를 사용할 수 있습니다. \u0026gt; 3D Rotation Converter\ntf의 사용 시 주의해야 할 점을 언급하고자 합니다.\nturtle_tf2_broadcaster.py 수정 - Experiment라고 되어 있는 부분을 주석 해제한 다음 다시 실행해봅시다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() # prepare tf msg t = geometry_msgs.msg.TransformStamped() # t.header.stamp = rospy.Time.now() # Experiment, Late tf2 t.header.stamp = rospy.Time.now() - rospy.Duration(60) t.header.frame_id = \u0026#34;world\u0026#34; rviz를 실행시킨 터미널에서 아래와 같은 에러가 발생합니다. [ WARN] [1671940248.738235698]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame turtle1 at time 1671940148.738096 according to authority unknown_publisher tf에는 시간 데이터가 포함되어 있습니다. 따라서 현재 시간과 tf에 담기 시간의 차이가 크다면 ROS는 이를 안정적이지 못한 것으로 판단해 무시합니다. (위 에러는 아마 로봇 개발을 하면서 마주치게 되는 Warning Top3안에 들지 않을까 싶습니다.)\n이번 예시에는 터미널이 4개나 필요하였습니다. 예시의 빠른 실행을 위해 launch file을 만들 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find py_tf2_tutorial)/rviz/turtlesim_tf.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; tf listener tf broadcaster의 다음으로 tf listener에 대해 배워봅시다.\nturtlesim follow demo roslaunch py_tf2_tutorial follow_demo.launch 사진과 같이 우리가 조종하는 첫번째 거북이를 두번째 거북이가 따라오게 됩니다. rviz를 통해 tf들 사이에 어떠한 변화가 있는지도 직접 확인해보세요 launch 파일은 다음과 같은 내용을 포함하고 있습니다.\n\u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;turtle2_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle2\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_listener.py\u0026#34; name=\u0026#34;listener\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; turtlesim 실행 teleop key 실행 turtle1의 tf broadcaster turtle2의 tf broadcaster tf listener 이번 예제에서 살펴보고자 하는 것은 tf listener입니다.\nTransformListener 클래스는 생성되는 순간부터 /tf topic에 귀기울이기 시작합니다. Buffer는 정해진 사이즈만큼 tf 데이터를 품게 되며, TransformListener에 전달하게 되면, tf topic data를 받아 Buffer에 쌓아두는 것입니다. if __name__ == \u0026#39;__main__\u0026#39;: rospy.init_node(\u0026#39;tf2_turtle_listener\u0026#39;) tfBuffer = tf2_ros.Buffer() listener = tf2_ros.TransformListener(tfBuffer) Buffer의 lookup_transform 메소드는 두 frame 사이의 translation, rotation 변환을 계산해줍니다. while not rospy.is_shutdown(): try: # calculate transformation btw two dynamic tfs # those tfs were broadcasted from TransformBroadcaster trans = tfBuffer.lookup_transform(turtle_name, \u0026#39;turtle1\u0026#39;, rospy.Time(), rospy.Duration(1.0)) except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException): rate.sleep() continue lookup_transform 메소드의 원형은 다음과 같습니다. image from : docs.ros2.org lookup_transform의 계산 결과를 직접 살펴보고자 print 문을 추가하였으며, 캡쳐 사진을 통해 간단히 함께 살펴봅시다.\ntranslation은 두 거북이의 frame사이 수평 거리를 보여주며 rotation은 두 frame사이 회전을 쿼터니언으로 보여줍니다. 기준이 되는 frame과 목표 frame은 id로 구분하며, 현재 turtle1, turtle2로 구분하고 있습니다. 현 상황을 그림으로 간단히 정리하자면 다음과 같습니다.\nlookup_transform의 계산 결과는 target frame인 turtle2의 위치가 source frame인 turtle1 기준에서는 어떠한 좌표를 갖는지를 포함합니다.\nimage from : CMU Qatar 로보틱스에서 이러한 좌표 변환은 매우 자주 사용되며, 일반적으로 Homogeneous Matrix의 형태로 표현합니다.\nfrom : eth robotics lecture notes 그 밖에, 코드에서 구현된 기능을 간단히 살펴보며 마무리하겠습니다.\n두번째 거북이를 등장시키는 service client # Spawn second turtle rospy.wait_for_service(\u0026#39;spawn\u0026#39;) spawner = rospy.ServiceProxy(\u0026#39;spawn\u0026#39;, turtlesim.srv.Spawn) turtle_name = rospy.get_param(\u0026#39;turtle\u0026#39;, \u0026#39;turtle2\u0026#39;) spawner(4, 2, 0, turtle_name) 거북이를 제어하기 위한 Twist msg topic publisher # turtle2 controller turtle_vel = rospy.Publisher(\u0026#39;%s/cmd_vel\u0026#39; % turtle_name, geometry_msgs.msg.Twist, queue_size=1) rate = rospy.Rate(50.0) while not rospy.is_shutdown(): ... turtle_vel.publish(msg) rate.sleep() 이렇게 tf에 대해서 turtlesim 예시와 함께 살펴보았습니다. 로보틱스에서 자주 사용되는 좌표계와 그들 사이의 변환을 시간 데이터와 함께 표현하는 것이 ROS의 tf2입니다.\n다음 강의에 계속 이어집니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture10/",
	"title": "Lecture10 - TF2 Examples, Outro",
	"tags": [],
	"description": "",
	"content": "tf2 사례 제가 강조해서 자꾸 좌표계가 tf가 중요하다고 말하고 있는데, 그 이유를 예시와 함께 좀 더 자세히 살펴보고자 합니다.\nhusky slam # 예시 종속성 설치 sudo apt install ros-noetic-slam-gmapping # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 roslaunch py_tf2_tutorial slam_gmapping.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # [option] rviz (이전 예시에서 rviz를 추가하였다면 넘어가셔도 좋습니다.) rviz rviz를 다음과 같이 세팅합니다. 이제 teleop을 통해 로봇을 이동시키면서, rviz 화면의 변화를 확인해봅시다. 로봇이 움직이면서 자신의 위치를 파악함과 동시에 지도를 생성하는 예시입니다.\n마지막으로, rqt를 실행하여 tf tree를 실행시킵니다. tf tree는 tf 관련 상태를 시각화하여 한번에 볼 수 있게 해주는 고마운 툴입니다. tree를 확대해서 살펴보자면, slam_gmapping은 map → odom으로의 tf broadcast를 담당하고 있습니다. 더불어 map은 모든 tf의 최상단에 존재하고 있습니다. 이러한 이유로 rviz에서 fixed frame을 map으로 설정한 것입니다. 퀴즈: 만약 tf tree가 온전히 연결되어 있지 않다면 어떤 일이 발생할까요?\nimage from : answers.ros.org 센서 입장에서도 tf는 매우 중요합니다.\n같은 데이터라도 그 기준이 어딘지에 따라서 전혀 다른 의미를 가질 수 있기 때문입니다.\n예를 들어, 라이다의 tf를 180도 반대로 설정해버리면 후방에 있는 장애물을 전방 장애물로 잘못 인식할 수 있습니다.\nimage from : answers.ros.org 더불어, 로봇 팔과 같은 관절로봇에게도 tf는 무척 중요한 의미를 갖습니다. 각 joint의 상태를 통해 tf를 계산하고 이를 통해 최종적으로 로봇 팔의 끝점이 어디에 위치하는지 계산할 수 있습니다.\nMoveIt! 실습해보기 이번 시간에는 조금 쉬어가는 느낌으로 유용한 ROS Package를 소개해드리고자 합니다.\nimage from : moveit github MoveIt은 다관절 로봇의 모션 제어를 위한 프레임워크입니다. 이름만 들어서는 감이 잘 오지 않지요? 간단한 예시를 통해 살펴봅시다.\n우리 인간은 팔을 이용하여 물건을 잡는 것이 매우 쉽고 간단하지만, 사실 이는 기구학적으로, 동역학적으로, 에너지 차원에서 매우 최적화된 움직임입니다. 로봇 팔의 경우 장착된 모터의 방향각이 제한된 경우도 있고, 자기 자신과 얽혀버리는 문제도 발생할 수 있으며, 같은 목표를 갖더라고 다양한 경로로 움직일 수 있기 때문에 최적의 경로에 대한 기준도 고려해야 합니다. image from : mecademic 로봇 팔의 주요 구성 Base : 고정된 지지부 Arm : 실질적인 로봇 팔 End Effector : Arm 끝에 부착되는 기구의 통칭, 일반적으로 물체를 잡고 놓는 동작을 수행 MoveIt은 관절 로봇의 기본 구성과 Mass Matrix, 각 모터의 제한과 원하는 움직임을 지정해주면 이에 따라 각 관절의 위치, 속도, 가속도 경로를 최적화(Planning) 해주는 프레임워크이며, 그 밖에도, 물체 인지, 장애물 회피, End Effector에 가해지는 힘까지 고려 가능한 거대한 오픈소스 프로젝트입니다.\nMoveIt Motion Planning Framework\n이번 예제로 저와 함께 MoveIt의 가장 기본적인 데모를 함께 실행해보겠습니다. 예시에 사용되는 로봇은 FRANKA EMIKA의 PANDA라는 로봇입니다. FRANKA EMIKA - PANDA\n아래 커멘드 라인을 함께 따라와주세요.\napt 패키지 설치 sudo apt install ros-noetic-moveit-setup-assistant sudo apt install ros-noetic-moveit sudo apt install ros-noetic-gazebo-ros-control joint-state-publisher sudo apt install ros-noetic-controller-manager sudo apt install ros-noetic-ros-controllers sudo apt install ros-noetic-ros-control sudo apt install ros-noetic-robot-state-publisher 예제 패키지 Clone cd ~/catkin_ws git clone https://github.com/ros-planning/moveit_tutorials.git -b master git clone https://github.com/ros-planning/panda_moveit_config.git -b noetic-devel 관련 종속성 설치 - rosdep 추가 설명 cd ~/catkin_ws/src rosdep install -y --from-paths . --ignore-src --rosdistro noetic 패키지 빌드 cd ~/catkin_ws catkin build source devel/setup.bash 데모 실행 roslaunch panda_moveit_config demo_gazebo.launch 여기까지 잘 따라오셨나요? 그렇다면 강의자의 설명에 따라 RViz Motion Planning Plugin을 사용해봅니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ros-planning.github.io/moveit_tutorials/ http://wiki.ros.org/tf/Tutorials "
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]