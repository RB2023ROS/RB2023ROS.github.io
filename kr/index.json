[
{
	"uri": "/kr/ros_basic_noetic/",
	"title": "ROS Basics",
	"tags": [],
	"description": "",
	"content": " Lecture1. Introduction to ROS, Prior Basics Lecture2. Lecture3. Lecture4. Lecture5. Lecture6. Lecture7. Lecture8. Lecture9. Lecture10. "
},
{
	"uri": "/kr/ros2_basic_foxy/",
	"title": "ROS 2 Basics",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "/kr/",
	"title": "2023 Road Balance ROS Lecture Note",
	"tags": [],
	"description": "",
	"content": "2023 ROAD BALANCE ROS LECTURE NOTE 본 사이트는 2023년 Road Balance의 ROS/ROS 2 강의에 사용되는 강의 노트입니다.\n현재까지 정리된 강의는 다음과 같습니다.\nCurrently Organized Lectures\u0026hellip;\nLecture 1. Course Introduction \u0026amp; Java Basics Lecture 2. Classes and Objects, Static, Types Lecture 3. Defining \u0026amp; Instantiating, Static vs Non-static, Managing - Complexity, Primitive Types Lecture 4. Unit Testing Lecture 5. Linked List (IntList \u0026amp; SLList), PUBLIC VS PRIVATE, Nested Classes, List \u0026amp; Array Lecture 6. Doubly Linked List, Generic Lists, AList Lecture 7. Inheritance and Interface, Overriding and Overloading Lecture 8. Java Built in Interfaces, Set, Exception, Iteration and Useful Class Methods "
},
{
	"uri": "/kr/ros_basic_noetic/lecture1/",
	"title": "Lecture1",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/ros_basic_noetic/lecture2/",
	"title": "Lecture2 - Core of ROS",
	"tags": [],
	"description": "",
	"content": " 지난 시간 개발환경 세팅을 잘 진행하였는지 확인을 해보면서 강의를 시작해보겠습니다.\n터미널 프로그램을 실행한 뒤, gazebo를 실행해 봅시다.\ngazebo 위 사진과 같은 화면이 나오지 않았다면 설치가 제대로 되지 않은 것입니다.\n다음으로, ROS 설치는 잘 되었는지도 확인해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun rospy_tutorials talker 모든 확인이 끝났다면, 예제 프로그램을 실행시켜보겠습니다.\nHusky Gazebo 예제 패키지 설치 sudo apt-get update sudo apt-get install ros-noetic-husky-desktop sudo apt-get install ros-noetic-husky-simulator 예제 프로그램 실행 # Terminal 1 roslaunch husky_gazebo husky_empty_world.launch # Terminal 2 roslaunch husky_viz view_robot.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py cmd_vel:=/husky_velocity_controller/cmd_vel Terminal 1에서 발생하는 아래 오류는 무시해도 좋습니다.\n모든 실행이 정상 동작하였다면, Terminal 3에서 키보드를 통해 Husky를 제어할 수 있습니다. 로봇이 움직임에 따라 두번째 터미널 결과였던 Rviz에 아래와 같은 변화가 생깁니다. 다음으로, 새로운 터미널에서 아래 커멘드 라인을 실행시켜 봅시다. rosrun rqt_graph rqt_graph 위 그림은 방금 전 실행한 예제 내부적으로 어떠한 동작들이 이루어지고 있었는지를 보여주는 것으로, 강의를 마칠 때면 여러분들은 위 그림이 어떠한 의미를 갖는지 모두 이해하실 수 있을 것입니다.\n다음으로, 터미널을 새로 실행시켜 rosnode list와 rostopic list를 실행시켜 봅시다.\nrosnode list $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rostopic list $ rostopic list /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state /gazebo/set_model_state ... 앞으로의 강의들에서, 위 명령어들이 어떠한 의미를 갖는지 하나하나씩 함께 살펴보겠습니다.\nROS Node ROS는 각 프로세스들을 Node라는 단위로 관리합니다.\n로봇을 움직이는 Node, 센서와 통신하는 Node, 시각화 Node 등 다양한 Node들이 얽혀 로봇 시스템을 구성하게 됩니다. Node들 사이에는 데이터의 송수신이 필요합니다. 이를 담당하는 ROS의 통신 메커니즘들이 있으며 각기 다른 특성을 갖고 있습니다. Node들끼리 데이터를 주고받기 위해서는 어떤 노드가 존재하는지, id는 몇번인지 등의 정보가 공유되어야 할 것입니다. 아래 그림의 ROS Master가 이를 관리해주는 것이라고 이해하시면 됩니다. image from : clearpathrobotics 그렇다면, 방금 우리가 실행한 예시에서도 ROS Master와 Node들이 실행되었겠군요!\n실행되는 Node를 확인하는 방법은 크게 두 가지가 있습니다.\nrosnode command $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rqt_graph rosrun rqt_graph rqt_graph rqt graph를 살펴보면, 동그란 Node와 Node들 사이의 데이터 송수신이 화살표로 표현된 것을 알 수 있습니다. 키보드를 통해 제어 데이터를 송신하는 teleop_twist_keyboard는 gazebo node로 데이터를 보내고 있으며, 따라서 gazebo는 이 데이터를 통해 실제 로봇을 움직이게 되는 것입니다.\n특정 Node에 대해서 더 자세한 정보를 얻고 싶다면, rosnode info 커맨드를 사용합니다. $ rosnode info /base_controller_spawner -------------------------------------------------------------------------------- Node [/base_controller_spawner] Publications: * /rosout [rosgraph_msgs/Log] Subscriptions: * /clock [rosgraph_msgs/Clock] Services: * /base_controller_spawner/get_loggers * /base_controller_spawner/set_logger_level contacting node http://192.168.55.236:33811/ ... Pid: 63764 Connections: * topic: /rosout * to: /rosout * direction: outbound (43329 - 192.168.55.236:34456) [10] * transport: TCPROS * topic: /clock * to: /gazebo (http://192.168.55.236:33853/) * direction: inbound * transport: TCPROS 이전 예제들은 일단 종료시킨 뒤, 간단한 새로운 예시를 실행해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener # Terminal 4 rqt_graph rqt_graph를 보면 talker ⇒ listener로 데이터가 전송되는 것을 알 수 있습니다.\n이제, rqt_graph를 보는 것은 익숙해졌지요?\n첫번째 Gazebo 예시와 다른 점으로 roscore라는 것을 실행해주었습니다.\nroscore는 ROS Master를 실행시키는 명령어로 모든 ROS Node들은 Master에 의해 관리되기 때문에 roscore를 통해 실행시키거나, roslaunch를 사용해야 합니다. ROS Master가 실행되고 있지 않다면, 아래와 같이 오류가 발생합니다. ETH Super Mega Bot \u0026amp; ROS Workspace ROS는 catkin이라는 빌드 시스템을 사용합니다. 기존 c/c++ cross-platform 개발을 경험하셨다면 cmake에 익숙하실텐데, 이와 매우 비슷합니다. catkin을 통해 실행 가능한 프로그램 (C/C++의 빌드), 라이브러리, 인터페이스들을 만들 수 있으며, catkin 시스템을 사용하기 위해서는 workspace라는 특별한 폴더가 필요합니다. ROS 개발을 하다 보면 여러 프로젝트를 동시에 진행하는 경우가 생깁니다. 새로운 작업은 새로운 폴더를 만들어 작업하듯이 ROS 에서도 새로운 프로젝트는 새로운 WorkSpace에서 작업을 수행하는 것이 일반적입니다. 새로운 WS로 이동하게 되면 ROS에게 이러한 변화를 알려줘야 하며 이 명령어가 source devel/setup.bash 입니다. 이번 강의용 WS를 만들어보고, 이후 여러분들만의 WS도 만들어 작업해보세요! 일반적으로 ROS의 workspace는 name_ws라는 이름을 갖는 것이 일반적이며, 우리는 catkin_ws라는 workspace를 만들어보고자 합니다.\n아래 커멘드 라인들을 따라해주세요 cd ~/ mkdir -p catkin_ws/src cd catkin_ws catkin config --init catkin build 다음과 같이 build, devel, src, log 폴더가 만들어집니다. ROS 코드들은 모두 src 폴더 안에 위치하게 됩니다. src 폴더 내부에서 코드 개발 ⇒ catkin을 사용한 빌드 ⇒ build 폴더 내부에 실행 가능한 프로그램 생성의 순서로 개발이 이루어집니다. 실습을 통해 개발 프로세스에 익숙해져봅시다.\n아래 폴더를 catkin_ws/src 안에 압축 해제합니다. Example Packages smb_common.zip (2 ) 터미널 프로그램을 실행시키고 아래 커멘드 라인을 따라합니다. catkin build smb_description catkin build smb_gazebo catkin build smb_control source devel/setup.bash source로 시작하는 마지막 라인은 새로운 빌드 후에 항상 실행해줘야 합니다. 1강을 잘 따라했다면 sds라는 단축어로 사용이 가능합니다.\n예제 프로그램을 실행시킵니다. roslaunch smb_gazebo smb_gazebo.launch 실행 시 붉은 에러 메세지가 나오지만 동작만 된다면 문제 없습니다.\n이 로봇을 한번 움직여 볼까요? - teleop 실행 rosrun teleop_twist_keyboard teleop_twist_keyboard.py 파일 구조 관점에서, ROS Application은 여러 Package들로 이루어집니다. 이들 Package가 소스 파일을 담고 있고, catkin이 이들을 빌드하여 실행 프로그램들을 만들었습니다. 제가 공유한 압축 파일 안에도 3개의 Package가 포함되어있던 것이며, ROS 개발자들은 자신들의 로봇 Package를 개발하고 공유합니다. Package 생성 실습 Package를 생성하는 방법은 다음과 같습니다.\ncd \u0026lt;your-ws\u0026gt;/src catkin_create_pkg \u0026lt;package_name\u0026gt; [depend1] [depend2] [depend3] my_first_package라는 package를 시험삼아 생성해봅시다.\n# exameple $ catkin_create_pkg my_first_package rospy std_msgs Created file my_first_package/package.xml Created file my_first_package/CMakeLists.txt Created folder my_first_package/src Successfully created files in /home/kimsooyoung/catkin_ws/src/my_first_package. Please adjust the values in package.xml. depend에는 해당 패키지의 의존성 패키지들이 나열되며, rospy는 파이썬을 통해 ROS를 사용하기 위한 의존성입니다.\n미리 제공되었던 Package, smb_gazebo를 살펴봅시다.\nGazebo 실행에 필요한 모델 파일과 환경 파일 등 기능별 정리된 모습을 볼 수 있습니다.\n이렇게 Package를 잘 구성해두면 이후 코드의 관리에도 편리하다는 장점이 있습니다.\n참고자료\nhttp://wiki.ros.org/ko/ROS/Tutorials/CreatingPackage https://rsl.ethz.ch/education-students/lectures/ros.html https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture3/",
	"title": "Lecture3 - ROS Launch, RViz",
	"tags": [],
	"description": "",
	"content": "ROS Launch 일전 예시 실행에서 다음과 같은 커멘드 라인을 사용했었습니다.\nroslaunch smb_gazebo smb_gazebo.launch roslaunch란, 다수의 ROS Node들을 한번에 실행할 수 있도록 해주는 툴 입니다.\nroslaunch를 사용하기 위해서는 xml이라는 포멧을 사용하는 launch file이 있어야 하며, 이는 보통 패키지의 launch 폴더에 위치하고 있습니다.\nlaunch file의 구조를 파악해봅시다.\nlaunch파일은 xml이라는 문법을 사용합니다. html을 사용해보셨다면 아시겠지만, \u0026lt;\u0026gt;를 이용하여 라인을 구분하는 포멧입니다. 한 라인에서 끝나는 경우 /\u0026gt;로 맺을 수 있지만, 여러 라인이 필요한 경우에는 여는 태그와 닫는 태그를 사용하여 구분합니다. \u0026lt;tag /\u0026gt; or \u0026lt;tag (value)\u0026gt; ... \u0026lt;/tag\u0026gt; launch file은 시작과 끝, 태그로 감싸집니다.\nnode 태그는 실행되는 ROS Node를 지칭합니다. name 태그는 node를 실행할 때의 이름을 설정하는 부분으로 자유롭게 지정 가능합니다. pkg 태그에는 해당 node가 속해있는 package를 적습니다. type 태그에는 실행가능한 파일, 혹은 프로그램을 적게 되며, c++의 경우 빌드된 프로그램, 파이썬의 경우 파이썬 파일이 됩니다. output 태그는 로그가 출력되는 위치를 지정하며 screen일 시 터미널에 출력됩니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;listener\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;listener.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;talker\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;talker.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 이번에는 smb_gazebo.launch를 살펴봅시다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- GAZEBO ARGUMENTS --\u0026gt; \u0026lt;!-- Run Gazebo headless --\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;model_path\u0026#34; default=\u0026#34;$(find smb_gazebo)/\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_namespace\u0026#34; default=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_model_name\u0026#34; default=\u0026#34;smb\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;enable_ekf\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; ... \u0026lt;!-- Load Gazebo world --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; arg란, argument의 약자이며 launch 파일에서 인자로 작용하는 일종의 변수입니다.\narg 태그를 통해 argument를 선언하고 default를 통해 초기값을 정할 수 있습니다. argument의 선언 후 사용은 **$(arg )**입니다. roslaunch 시 argument를 바꿔 실행이 가능합니다. 예를 들어, smb_gazebo.launch 실행 시. world를 바꾸어 아래와 같이 사용이 가능합니다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school 초기 실행 시 시간이 다소 걸릴 수 있습니다.\n현재 예시에서 제공되는 world는 다음 3가지 입니다.\nroslaunch smb_gazebo smb_gazebo.launch 제작한 launch file을 다시 다른 launch file에서 불러오는 경우가 더러 있습니다.\n이때, include 태그를 사용하며, 패키지 단위를 기반으로 파일의 경로를 가져오게 됩니다.\ninclude하는 launch file의 내부에도 여러 argument들이 있을 것입니다. 이들은 arg 태그를 통해 접근할 수 있습니다.\n\u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; html과 마찬가지로 \u0026lt;!-- --\u0026gt; 사이에 오는 코드는 주석으로 무시됩니다.\n단, 주의사항 하나 있습니다. launch 파일을 사용하다보면 --가 종종 쓰이곤 하는데요. 이 경우 주석에 오류가 나니 주의하시기 바랍니다.\nLaunch File을 다루는 연습을 해봅시다.\nsmb_gazebo.launch를 다음과 같이 수정합니다.\nworld를 big_map_summer_school로 수정합니다. 로봇이 등장하는 위치를 다음과 같이 수정합니다. xyz : (-0.5, -1.0, 0.4) yaw angle : 90도 (3.1415를 1 radian으로 잡습니다.) launch file에 rospy_tutorials Package에 있는 talker Node를 추가합니다. Rqt와 RViz ROS에는 로봇의 다양한 센서 데이터들을 시각화해주는 3D 툴이 있으며, 이는 RViz라고 불립니다.\nRviz의 사용법을 알아봅시다.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 rviz 사진과 같이 Gazebo와 RViz가 잘 실행된 상황에서 강의를 따라합니다.\nrviz에서 센서 데이터를 시각화하기 전, 우선 어떤 좌표계를 기준으로 시각화할지 설정해주어야 합니다.\n같은 센서라도 원점 좌표계에서 본 모습과, 센서 좌표계에서 본 모습이 다르기 때문입니다.\nimg from : mathworks 이는 RViz의 Fixed Frame에서 설정 가능합니다. (odom으로 설정해보겠습니다.)\n이제 다양한 시각화 기능들을 사용해보려 합니다.\n기본적으로 데이터의 추가는 왼쪽 하단 Add 버튼으로 실행합니다. tf 시각화 odometry 시각화 point cloud 시각화 이렇게 잘 설정해둔 RViz는 config 포멧으로 추출하여 이후에 다시 사용할 수 있습니다.\nFile ⇒ Save Config를 통해 config를 저장하고, Open Config를 통해 저장한 config를 불러올 수 있습니다.\n아래와 같이 다양한 Plugin을 통해 여러 센서, 로봇 데이터를 시각화할 수 있으며, 자신만의 Plugin을 제작할 수도 있습니다.\n지금까지 여러분들이 만든 RViz 설정을 저장해보고, launch file에 통합해봅시다.\nRViz의 좌측 상단 File 옵션을 사용하여 config file을 저장합니다. 저장 위치는 smb_gazebo/rviz로 지정하겠습니다. (새롭게 폴더를 만들어주었습니다.) 이제, launch file을 수정합시다. 파일 하단 launch 태그가 닫히기 전 부분에 아래와 같은 라인을 추가합니다. \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find smb_gazebo)/rviz/my_config.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 이제, 다시 Gazebo launch를 해봅시다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school Rqt Tools 지금까지 사용한 ROS 툴은 rqt_graph와 RViz가 있었습니다.\n사실 ROS에는 수많은 추가 툴들이 존재하며 이들을 묶어 rqt tools라고 부릅니다.\nrqt image view image from : wiki.ros.org\nrqt multiplot image from : project march\nrqt console image from : wiki.ros.org\nrqt robot steering rqt tf tree image from : rqt tf tree\n이러한 수많은 툴들이 있어 ROS 개발을 편리하게 해주고 있으며, 함께 ROS를 공부하면서 하나씩 같이 살펴보고 사용해보려 합니다.\n참고자료\nhttp://wiki.ros.org/roslaunch https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html https://rsl.ethz.ch/education-students/lectures/ros.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture4/",
	"title": "Lecture4 - Node Programming, Topic Pub,Sub and Message",
	"tags": [],
	"description": "",
	"content": "이번 강의부터, 본격적인 프로그래밍이 시작됩니다. 첫번째로 Node의 프로그래밍을 살펴보고자 하며, 시작 전 간단한 복습을 진행하고 시작하겠습니다.\nimage from : clearpathrobotics\nWorkspace와 패키지 # WS 생성 mkdir -p catkin_ws/src cd catkin_ws catkin config --init # Package 생성 catkin_create_pkg \u0026lt;pkg-name\u0026gt; \u0026lt;depend1\u0026gt; \u0026lt;depend2\u0026gt; ... ROS Node Programming C++ 코드는 src 폴더 안에, 파이썬 코드는 scripts라는 폴더 안에 위치시키는 것이 일반적입니다. cd \u0026lt;pkg-name\u0026gt; mkdir scripts 지금부터, 직접 명령어를 한줄씩 따라치면서 실습하셔도 좋고, 제가 미리 준비해둔 Package를 사용하셔도 좋습니다.\n다음으로, 파이썬 코드를 작성하고 패키지를 빌드해봅시다.\ncd scripts # my_first_node.py 생성 첫번째 프로그래밍 코드는 Node의 기본입니다.\n모든 소스코드는 github repo에서 확인 가능합니다.\nmy_first_node.py #!/usr/bin/env python3 import rospy from std_msgs.msg import String def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # ROS safe timer rate = rospy.Rate(10) # 10hz # Loop control Example while not rospy.is_shutdown(): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. rate.sleep() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드를 새로 작성한 다음에는 습관적으로 패키지를 빌드하고 실행합니다. 파이썬 코드의 경우 파일의 실행 권한이 주어져 있어야 합니다. cd scripts chmod +x * cd ~/catkin_ws catkin build my_first_pkg 작성한 node를 실행해봅시다. 반복해서 터미널 로그가 남을 것입니다. # Terminal 1 roscore # Terminal 2 rosrun my_first_package my_first_node.py 코드 분석 첫 코드인 만큼 자세하게 분석하고 넘어가보려 합니다.\nROS Noetic은 Python 3를 사용합니다. 가상환경의 파이썬, 직접 설치한 파이썬 등 여러 버전이 설치되어 있을 것입니다. 공식 문서에서는 이러한 혼란을 방지하기 위해 코드의 제일 처음 아래 라인을 추가하는 것을 추천하고 있습니다. #!/usr/bin/env python3 Python을 사용하여 ROS를 다루기 위해 사용되는 패키지는 rospy입니다. import를 사용해도 좋고 from / import를 통해 특정 클래스만 가져올 수도 있습니다. import rospy from std_msgs.msg import String 당장 사용하지는 않지만 Test Code를 작성해야 하는 경우가 있습니다. 이러한 상황에 대비하기 위해 main 함수를 따로 두고 아래와 같이 프로그램을 시작하기를 권장합니다. if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 이제, my_first_node를 분석해 보겠습니다. Node의 실행을 위해 Master에 등록하고, 초기화하는 작업이 필요하며, 이를 위해 별도로 init_node라는 메소드를 실행해주어야 합니다. def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) ROS 시스템은 기본적으로 무한 Loop입니다. 이 Loop가 한차례 반복되는 주기를 설정하는 부분입니다. ROS의 시간 체계에 대해서는 이후 한번 더 다루겠습니다. # ROS safe timer rate = rospy.Rate(10) # 10hz rospy를 통해 실행 중인 Node의 상태를 확인할 수 있으며, is_shutdown()은 예기치 못한 에러가 발생하거나 사용자의 종료를 인지할 수 있습니다. 10Hz를 맞추기 위해 Loop마다 sleep을 걸어주고 있습니다. # Loop control Example while not rospy.is_shutdown(): ... rate.sleep() ROS에서 콘솔 로그를 얻는 방법으로 print 보다 rospy.log를 사용하기를 추천합니다. hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. ROS Timer ROS는 기본적으로 무한 Loop를 하나의 프로세스 안에서 동작시키는 프로그램입니다. Timer를 통해 일정 시간마다 동작하는 코드를 구현할 수 있습니다.\ncd my_first_pkg/scripts # spin_node.py 생성 spin_node.py #!/usr/bin/env python3 import rospy # callback method requires event, which is TimerEvent def hello_du(event=None): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) def my_first_node(): rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # Timer Class is kind of Thread. # It\u0026#39;s rule is execute sleep in certain period with given event. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드의 실행 결과는 이전과 같기 때문에 Timer와 spin에 대해서만 짚고 넘어가겠습니다.\nTimer는 크게 두가지 매개변수를 받습니다. 실행 주기와 Callback 함수입니다. 해당 주기마다 Callback 함수를 실행시킵니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) 앞으로 여러분들은 직접 while loop를 구현하기보다 rospy.spin()을 더 많이 사용하시게 될 겁니다. Timer를 선언한 이후, 하나의 Thread에서 막혀버리는 것을 방지하는 역할을 수행합니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() image from : python tutorial\nOOP Node Programming my_first_oop_node.py #!/usr/bin/env python3 import rospy class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except rospy.ROSInterruptException: pass 이후의 실습들을 위해 한가지 예시만 더 살펴보고자 합니다. 객체 지향을 사용한 ROS Node 작성방법입니다. 파이썬에서 OOP를 사용하기 위해 Class 키워드를 사용하며, self등 OOP와 관련된 내용은 모두 알고 있다는 상태에서 진행하겠습니다.\nOOP를 사용하면 main 메소드가 매우 간편해진다는 장점이 있습니다. 클래스를 생성하고, spin을 하기만 하면 됩니다. def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() OOP로 전환되면서 변경된 구현에 주목합시다. Timer의 Callback 함수로 클래스 메소드가 사용되었으며, 클래스 변수인 counter를 사용하여 구현한 점에 주목합니다. class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 앞으로, 대부분의 코드는 OOP 기반으로 작성됩니다. 파이썬의 클래스에 대해 숙지가 되어있지 않다면 꼭 복습하고 다음 강의를 청취하세요!\nROS Topic 다시 개념 학습으로 돌아와보았습니다. 아래 그림은 지난 강의의 rqt_graph입니다.\n위 그림에서 동그라미는 Node를 뜻하고, 화살표는 topic을 뜻합니다.\n이번 시간에는 이 Topic이 무엇인지 배워보고자 합니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름입니다. image from : docs.ros.org 그림에서와 같이 ROS Topic은\nPublisher(발행자) Subscriber(구독자)로 나누어 Topic의 송신, 수신자를 구분합니다. Publisher, Subscriber는 Node안에서 생성되며 별도로 사용할 수는 없습니다. Pub/Sub 사이에 Message가 전달되며, 이 길의 이름이 Topic인 것입니다. 주의할 점은, Publisher, Subscriber는 오로지 Topic의 이름으로 소통한다는 것입니다. 어떤 Node에 publish 할지 Publisher는 전혀 모르며 오로지 Topic이 같은 Subscriber가 데이터를 받게 됩니다. 더불어, Topic은 여러 Node들로 부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. ⇒ Topic의 중요한 속성이니 꼭 알아두셨으면 좋겠습니다.\nimage from : docs.ros.org Node와 Topic의 개념을 다시 한 번 다잡고 갑시다.\nNode는 실행되는 프로그램이며, ROS Master에 등록하고 관리됩니다. Node들 사이의 통신 메커니즘 중 Topic이라는 것이 있으며, 이는 Publisher와 Subscriber라는 개념을 갖고 있습니다. Publisher와 Subscriber 사이의 오가는 데이터는 특정한 타입을 갖습니다. 이를 Message라고 부릅니다. Topic Message 로봇 프로그래밍 시에는 다양한 센서 데이터들이 다뤄집니다. 센서 뿐만 아니라, 제어 데이터도 주고 받아야 합니다. ROS에서는 주로 사용되는 이러한 데이터 형식을 Message라는 이름으로 지칭하며, 여러 기본 형태를 제공합니다. 더불어 사용자가 직접 Message를 커스터마이징할 수도 있습니다.\n일전 예시의 분석을 통해 Topic과 Message에 대해 다시 한 번 살펴봅시다. # Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener 두 프로그램이 실행되고 있는 상태를 유지하면서, 아래 내용을 따라와주세요\nrostopic list를 통해 사용중인 topic들을 모두 조회 가능합니다. $ rostopic list /chatter /rosout /rosout_agg 특정 topic에 대한 자세한 정보를 알고 싶다면 rostopic info를 사용합니다. talker와 listener가 조회된 모습도 보입니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /talker_215337_1671763968667 (http://192.168.55.236:37863/) Subscribers: * /listener_215355_1671763970127 (http://192.168.55.236:44969/) 해당 topic이 사용중인 Message를 조회하기 위해 rostopic type을 사용합니다. $ rostopic type /chatter std_msgs/String rosmsg show를 통해 Message의 원형을 확인할 수 있습니다. $ rosmsg show std_msgs/String string data topic 데이터를 엿볼 수 있는 rostopic echo입니다. $ rostopic echo /chatter data: \u0026#34;hello world 1671764088.1913402\u0026#34; --- data: \u0026#34;hello world 1671764088.2913551\u0026#34; --- ... rostopic hz로 topic의 pub/sub 주기를 분석할 수 있습니다. $ rostopic hz /chatter subscribed to [/chatter] average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00014s window: 10 average rate: 9.999 min: 0.099s max: 0.100s std dev: 0.00023s window: 20 마지막으로 rqt_graph를 다시 한 번 살펴봅시다.\nrqt_graph 방금 살펴본 커멘드 라인들을 충분히 숙지하시기 바랍니다. 그러한 의미에서, 이번에는 Gazebo 예시를 분석해볼까 합니다.\n# Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun teleop_twist_keyboard teleop_twist_keyboard.py rostopic list 결과 $ rostopicist /clicked_point /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state ... 우리가 집중하고자 하는 topic은 로봇을 제어하는 /cmd_vel입니다.\nrostopic info 결과 $ rostopic info /cmd_vel Type: geometry_msgs/Twist Publishers: * /teleop_twist_keyboard (http://192.168.55.236:33903/) Subscribers: * /twist_mux (http://192.168.55.236:38201/) * /gazebo (http://192.168.55.236:33033/) rostopic type 결과 $ rostopic type /cmd_vel geometry_msgs/Twist geometry_msgs/Twist의 rosmsg show 결과 $ rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z /scan의 rostopic echo 결과 $ rostopic echo /scan header: seq: 0 stamp: secs: 204 nsecs: 678000000 frame_id: \u0026#34;rslidar\u0026#34; angle_min: -1.5707999467849731 angle_max: 1.5707999467849731 angle_increment: 0.008700000122189522 time_increment: 0.0 scan_time: 0.033330000936985016 range_min: 0.44999998807907104 range_max: 50.0 ranges: [inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, ... /scan의 rostopic hz결과 $ rostopic hz /scan subscribed to [/scan] WARNING: may be using simulated time average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 8 average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 17 rqt_graph에서 /cmd_vel을 찾아볼까요?\nrqt_graph Publisher 프로그래밍 이번 시간 사용할 Package는 py_topic_pkg 입니다. 실습 전 실행부터 해보겠습니다.\nPackage Build cd ~/catkin_ws catkin build py_topic_pkg source devel/setup.bash 예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg cmd_vel_pub.py 로봇이 아래와 같이 원을 그리며 움직일 것입니다.\ncmd_vel_pub.py #!/usr/bin/env python3 import rospy from geometry_msgs.msg import Twist class CmdVelPubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. topic queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) self.twist_ = Twist() def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) def cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: cmd_vel_node() except rospy.ROSInterruptException: pass 파이썬 ros 프로그래밍을 위한 rospy, 로봇의 속도 제어에 필요한 Message type인 Twist를 import 하고 있습니다. import rospy from geometry_msgs.msg import Twist rospy.Publisher를 통해 publisher를 생성할 수 있습니다. 이는 최소 3개의 매개변수를 필요로 합니다. topic 이름 topic type queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10)= 우리는 로봇의 제어 신호를 주기적으로 전송하고자 합니다. 따라서 Timer도 선언하였습니다. self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) 다음으로, Message Type인 geometry_msgs/Twist 값을 채웁니다. 현재 우리 로봇은 2차원 평면에서 움직이며, 로봇 형태 때문에 앞뒤 선속도와 각속도를 갖게 됩니다. ... self.twist_ = Twist() def pub_msg(self, event=None): self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 Message의 종류는 매우 많습니다. 구글을 통해 검색하면서 코딩하는 습관을 들여봅시다.\nfrom : http://docs.ros.org/ linear의 단위는 m/s 이며, angular의 단위는 rad/s 입니다. pi = 3.14\n마지막, 가장 중요한 topic publish는 생성한 Publisher의 publish() 메소드를 사용합니다. 미리 준비해둔 topic message를 사용합시다. def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) 이 Node를 실행하면, 우리의 ROS가 일정 주기에 맞추어 알맞게 topic publish를 실행시켜줄 것입니다. 우리는 정해진 구현에 맞추어 코드만 작성하면 되는 것이지요 😊\ndef cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() Subscriber 프로그래밍 이번 예시에는 로봇에 장착된 라이다 센서를 사용해보려 합니다. 예시를 실행해보겠습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg laser_scan_sub.py 실행 이후, 영상과 같이 박스를 로봇의 전방에 배치해봅시다. 터미널에 등장하는 문구에 집중해보세요. 박스가 추가되면서 출력창에 어떠한 변화가 생기나요?\n로봇에 부착된 라이다 센서는 전방 180도 사방으로 360개의 레이저를 흩뿌립니다.\n레이저의 특성상 물체를 맞고 되돌아오게 되며, 이 시간을 통해 물체와의 거리를 알 수 있습니다.\n예시의 프로그램은 로봇에 부착된 레이저에서 publish되는 데이터를 subscribe한 것입니다. 이를 프로그래밍하면서 python으로 subscriber를 다루는 방법에 대해 배워봅시다.\nlaser_scan_sub.py #!/usr/bin/env python3 import rospy from sensor_msgs.msg import LaserScan class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) def laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: laser_sub_node() except rospy.ROSInterruptException: pass 이번에 사용하는 topic message는 sensor_msgs/LaserScan입니다. import rospy from sensor_msgs.msg import LaserScan subscriber는 publisher와 달리 Timer가 필요하지 않습니다. publish되는 데이터가 없으면 아무 동작을 할 수 없으며, publish 주기에 맞추어 subscribe할 수밖에 없는 것이지요.\nsubscriber는 rospy.Subscriber로 생성하며 최소 3개의 매개변수를 요구합니다. topic 이름 topic message 이름 subscribe 마다 실행되는 callback 메소드 class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) 이 callback 메소드에서 주의해야 할 점은, 항상 callback method의 매개변수가 subscribe된 데이터라는 점입니다. 지금의 경우 LaserScan 타입의 데이터일 것입니다. # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) ... 마지막으로, 깔끔한 터미널 출력을 위해 print 함수를 사용하였습니다. print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) Subscriber 실행 시에는 항상 rospy.spin()을 잊지 말도록 합니다. spin 되지 않는다면 특정 쓰레드가 자원을 점유하기 때문에 subscriber의 상태를 갱신할 수 없습니다.\ndef laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() 과제 - 물체 회피하기 pub/sub의 개념을 잘 이해하였는지 알아볼 수 있는 과제를 준비해보았습니다. 정답이 따로 있는 것은 아니기에 부담 없이 해보시고, 저의 답안도 한번 살펴보세요.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Ternimal 2 rosrun py_topic_pkg collision_aviod.py Gazebo 예제를 실행하였다면, 로봇의 전방에 장애물을 놓아 진로를 막아봅니다. 여러분께서 구현해야 하는 것은, 라이다 센서를 사용하여 로봇이 회피 주행을 하도록 만드는 것입니다. 일종의 템플렛 코드를 첨부하였으며, my_collision_aviod.py라는 이름의 코드입니다.\n해당 코드의 TODO 부분을 작성하여 여러분만의 회피 알고리즘을 만들어 보세요!\n로봇의 라이다 데이터인 LaserScan을 Subscribe하여 Twist Type을 사용하는 scan topic으로 publish를 하게 됩니다. class CollisionAvoidNode: def __init__(self): self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.twist_ = Twist() def laser_cb(self, data): # TODO: Prevent robot from collision # make your own logic to do that return None 제가 작성한 예시를 수정하여 더욱 똑똑한 로봇을 구현하셔도 좋고, 자유롭게 실습해보시기 바랍니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture5/",
	"title": "Lecture5 - ROS Service, Parameter",
	"tags": [],
	"description": "",
	"content": " 지난 시간 마지막 예시였던 장애물 회피 코드부터 간단하게 리뷰해보고자 합니다.\n제가 작성한 로직은 다음과 같습니다.\n과제를 해보셨다면 아시겠지만, 측정 범위를 벗어나게 되면 data.ranges는 inf 값을 갖게 됩니다. 이를 걸러내는 코드가 아래 부분입니다. for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: 저의 로직은, 정면을 기점으로 왼쪽과 오른쪽 각각 inf가 아닌 데이터의 개수를 카운팅합니다. 전체 데이터가 362개이고 마지막 데이터는 사용하기 않는 값이기 때문에, 180을 기점으로 잡았습니다. left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 이제, 제어 데이터를 만들어줍니다. ROS를 비롯하여 로봇 시스템에서는 대부분 오른손 좌표계를 사용합니다. 따라서 위에서 보았을 rospy.loginfo(hello_du)때 오른손이 감기는 반시계 방향이 + 부호를 갖게 됩니다. 이를 고려하여 각속도를 정했습니다. 180은 magic number, 일종의 변환 상수입니다. image from : 오로카\ndef laser_cb(self, data): left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 self.twist_.linear.x = 0.3 self.twist_.angular.z = (right_side_count - left_side_count) / 100 self.cmd_vel_pub_.publish(self.twist_) 지난 강의에서 이야기한 것과 같이 이 문제의 정답은 없습니다.\n다만, Topic의 Pub / Sub을 모두 사용할 수 있는지 스스로 점검해볼 수 있을 것입니다.\nROS Parameter 앞선 저의 예시에서 마지막 속도로 변환하는 부분 수식에 나누기 100이 있었던 것을 기억하시나요? 이런 상수를 직접 코드에 적는 것은 사실 추천되지 않습니다. 개발 이후 해당 상수를 변경하고자 하였을 시, 직접 코드를 수정하고 다시 실행해야 하기 때문에 불편을 야기합니다.\n이러한 문제의 해결 방법으로 ROS의 매개변수, parameter를 다루는 방법을 알아보겠습니다.\npy_param_pkg/scripts/various_params.py #!/usr/bin/env python3 import rospy class ParamNode: def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) rospy.loginfo(f\u0026#34;\u0026#34;\u0026#34; self.str_param_ = {self.str_param_} self.int_param_ = {self.int_param_} self.double_param_ = {self.double_param_} self.bool_param_ = {self.bool_param_} self.list_of_float_param_ = {self.list_of_float_param_} \u0026#34;\u0026#34;\u0026#34;) def param_node(): rospy.init_node(\u0026#39;param_node\u0026#39;, anonymous=True) param_node = ParamNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: param_node() except rospy.ROSInterruptException: pa 실행 결과는 다음과 같습니다. $ rosrun py_param_pkg various_params.py [INFO] [1672014267.630578]: self.str_param_ = hello_world self.int_param_ = 2023 self.double_param_ = 3.14 self.bool_param_ = True self.list_of_float_param_ = [1.0, 2.0, 3.0, 4.0] 매개변수를 선언하고 기본값을 지정하는 방법은 **rospy.get_param()**을 사용하는 것입니다. 두번째 기본값을 잘 보면 어떤 타입을 사용하는지 알 수 있습니다. def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) parameter 앞에 붙는 물결 표시 (~)는 private parameter를 의미합니다. 이에 대해 궁금하다면 아래의 추가 자료를 학습해보세요. global_name = rospy.get_param(\u0026#34;/global_name\u0026#34;) relative_name = rospy.get_param(\u0026#34;relative_name\u0026#34;) private_param = rospy.get_param(\u0026#39;~private_name\u0026#39;) default_param = rospy.get_param(\u0026#39;default_param\u0026#39;, \u0026#39;default_value\u0026#39;) 추가 자료 : wiki.ros\n매개변수를 변경하는 가장 보변적인 방법은 launch file을 사용하는 것입니다. launch file의 param 태그를 사용하여 Node에 원하는 parameter를 전달할 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; ROS 프로그래밍을 하다 보면 매개변수가 아주 많이 필요한 경우가 있습니다. 이럴 때마다 launch file에 param 태그 라인을 추가하는 것은 매우 귀찮은 일입니다.\nyaml이라는 형식의 파일로 매개변수를 한번에 관리할 수 있습니다.\npy_param_pkg/param/config.yaml str_param: \u0026#34;yaml string\u0026#34; int_param: 9 double_param: 2.71828 bool_param: \u0026#34;false\u0026#34; list_of_float_param: [3., 2., 1.] py_param_pkg/launch/param_with_yaml.launch \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;rosparam command=\u0026#34;load\u0026#34; file=\u0026#34;$(find py_param_pkg)/param/config.yaml\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; launch file에 rosparam 태그를 추가하고, load command를 사용하며 사용하는 yaml 파일의 위치를 file 옵션을 통해 전달합니다.\nROS parameter Commands rostopic, rosnode와 같이 parameter 또한 터미널 명령어를 갖고 있습니다.\n접근 가능한 모든 parameter들을 나열합니다. rosparam list 특정 paramter의 값을 얻고자하면 아래 키워드를 사용합니다. rosparam get \u0026lt;parameter_name\u0026gt; 선언되어 있는 parameter의 값을 변경하고 싶은 경우 아래 키워드를 사용합니다. rosparam set \u0026lt;parameter_name\u0026gt; \u0026lt;value\u0026gt; 여러분들이 작성한 회피 프로그램에도 매개변수로 작용하는 상수들이 있을 것입니다. 이를 parameter로 변경하여 launch file과 yaml file로 업데이트하는 작업을 해보세요\nROS Service Topic에 이어 ROS의 통신 메커니즘 두번째로 Service를 배워보겠습니다.\nService가 동작하는 방식은 아래와 같습니다.\n그림과 같이 Client Node가 Server Node로 request를 주면, 해당 request에 대응하는 적절한 response가 다시 Client에게로 전달됩니다. 이 과정을 Service Call이라고 부릅니다.\nimage from : docs.ros.org\n하나의 Service Server에는 여러 Client Node가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지는 못합니다. 두 Node에서 동시에 request가 왔다면, 조금이라도 먼저 통신한 Node의 작업을 우선 진행하고, 그동안 다른 Node는 기다리고 있어야 합니다. image from : https://docs.ros.org/en/foxy/Tutorials/Services/Understanding-ROS2-Services.html\nTopic과 비교하여 Service의 특징을 알아봅시다.\n1:1 통신 : Topic publish를 하면 여러 Node가 Subscribe 가능합니다. 반면, Service는 request가 온 대상에게만 response를 줍니다. 순차적 통신 : Service Server는 동시에 여러 request를 처리할 수 없습니다. 현재 작업중인 request가 처리될 때 까지 다른 request는 기다리고 있어야 합니다. 단발성 : Topic은 대부분 지속적으로 publish를 진행하는 반면, Service는 1회성 통신입니다. 실제 로봇 프로그램에서 Service는 어떻게 사용될 수 있을지, 예시를 통해 살펴봅시다.\n예제 패키지 빌드 cd ~/catkin_ws catkin build py_service_pkg source devel/setup.bash Service Client 예제 실행 - 아르키메데스 나선 # Terminal 1 roslaunch py_service_pkg empty_gazebo.launch # Terminal 2 rosrun py_service_pkg spawn_model_client.py 방금 실행한 예시는 Gazebo에게 box를 등장시켜달라고 하는 Service Client를 포함하고 있습니다.\nBox가 등장하는 위치를 아래 사진과 같은 수식에 맞추어 설정한 것 뿐입니다.\n그럼, 코드를 분석해 볼까요?\n필요한 파이썬 패키지들을 import 합니다. import math import rospy import rospkg from geometry_msgs.msg import Pose from gazebo_msgs.srv import SpawnModel 여기서 중요한 점은 msg와 srv 부분입니다. topic에서 사용되는 데이터 타입이 Message였고, 프로그래밍 시에는 msg로 사용하였습니다.\nService에서는 msg가 아니라 srv라는 데이터 타입을 사용합니다. image from : rsl.eth\n이 srv는 msg와 다른 점이 있는데, request와 response로 나뉘어 있다는 점입니다. \u0026mdash; 표시를 기점으로 위쪽은 Server에게 전달하는 request, 아래쪽은 Server가 다시 회답하는 response 부분입니다. 이번 예시에서 사용한 gazebo_msgs/SpawnModel도 아래와 같은 구조를 갖습니다. image from : docs.ros.org\ngazebo_msgs/SpawnModel를 살펴보면 파란 글자로 geometry_msgs/Pose라는 부분이 있습니다. 이와 같이 srv는 다른 msg를 품을 수도 있고, 이렇게 만든 srv를 또다시 다른 srv에 포함시킬 수도 있습니다.\n코드 구현 관점에서, geometry_msgs/Pose는 Model을 등장시킬 초기 위치를 지정하는데 사용됩니다.\n# initial_pose initial_pose = Pose() initial_pose.position.x = 0.0 initial_pose.position.y = -1 initial_pose.position.z = 0.2 # z rotation -pi/2 to Quaternion initial_pose.orientation.z = -0.707 initial_pose.orientation.w = 0.707 Service Client의 생성과 사용은 아래와 같습니다. spawn_model_prox = rospy.ServiceProxy(\u0026#34;gazebo/spawn_urdf_model\u0026#34;, SpawnModel) ... result = spawn_model_prox( entity_name, model_xml, robot_namespace, initial_pose, reference_frame ) rospy.ServiceProxy()는 2개의 매개변수를 필요로 합니다.\nservice 이름 service 데이터 타입 (srv) 생성한 client로 request를 하기 위해서는 생성한 인스턴스에 매개변수를 전달하기만 하면 됩니다. 마치 함수 호출처럼 말이지요. 이는 ServiceProxy 내부적으로 call 메소드가 구현되어있기 때문입니다.\nservice call의 결과로 result가 반환되며, 예시에서는 성공 여부를 반환하도록 되어 있습니다.\n추가적으로, model을 불러오는 부분을 간단하게 설명하고자 합니다. # model_xml rospack = rospkg.RosPack() model_path = rospack.get_path(\u0026#34;py_service_pkg\u0026#34;) + \u0026#34;/urdf/\u0026#34; with open(model_path + model_name + \u0026#34;.urdf\u0026#34;, \u0026#34;r\u0026#34;) as xml_file: model_xml = xml_file.read().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) Gazebo는 urdf라는 파일을 전달하면 해당 파일을 기반으로 시뮬레이션에 물체를 등장시켜줍니다. 이 urdf라는 것은 로봇을 표현하기 위한 일종의 약속된 파일 확장명입니다.\nimage from : spart\n세상 모든 로봇들은 joint와 link로 표현 가능합니다. 이러한 개념을 바탕으로 로봇의 특성을 텍스트 파일로 표현하는 형식이 바로 urdf이며, 아래와 같이 여러 태그와 속성을 사용하여 작성 가능합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;link name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!-- Inertia values were calculated to be consistent with the mass and geometry size, assuming a uniform density. --\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0108\u0026#34; ixy=\u0026#34;0\u0026#34; ixz=\u0026#34;0\u0026#34; iyy=\u0026#34;0.0083\u0026#34; iyz=\u0026#34;0\u0026#34; izz=\u0026#34;0.0042\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; ROS Service Commands gazebo/spawn_urdf_model과 같은 service는 gazebo_ros를 사용할 때 자동으로 함께 실행됩니다. 이렇게 현재 어떠한 service가 존재하며, 또 구체적인 정보는 어떻게 조회하는지 알아봅시다.\n현재 사용 가능한 모든 service를 조회해봅시다. $ ros2 service list /delete_entity /gazebo/describe_parameters /gazebo/get_parameter_types /gazebo/get_parameters /gazebo/list_parameters /gazebo/set_parameters ... 리눅스의 grep 명령어를 함께 사용해 보세요.\n특정 service가 어떤 srv 타입을 사용하는지 검색하고 싶다면 다음 커멘드 라인을 사용합니다. $ rosservice type /gazebo/spawn_urdf_model **** 이렇게 검색된 srv는 rossrv show와 결합할 때 더욱 진가를 발휘합니다. $ rossrv show `rosservice type /gazebo/spawn_urdf_model` 특정 srv 타입에 대한 자세한 정보는 다음과 같이 조회할 수 있습니다. $ rosservice info /gazebo/spawn_urdf_model gazebo_ros에서 제공하는 다양한 service들이 있습니다. rosservice 커멘드를 사용하여 조회해보고 여러분들만의 Application을 생각해 보세요.\nService Server 예제 실행 - 긴급 정지 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_service_pkg emergency_stop.py # Terminal 3 rqt 두번째 Node 실행 시, 로봇이 원을 그리며 움직이기 시작합니다. 세번째 명령어를 통해 등장하는 rqt는 아래와 같이 사용 가능합니다. 로봇에게 긴급 정지 명령을 내려보겠습니다. 실제 로봇 개발시에도 Service는 이렇게 단발성이고, 빠르게 실행되어야 하는 동작에 주로 사용됩니다. 더불어, 지금 실행한 예시가 Service Server임을 다시 한 번 상기시켜드립니다.\nimage from : rsl.eth\n코드를 분석해 봅시다.\npy_service_pkg/scripts/emergency_stop.py from geometry_msgs.msg import Twist from std_srvs.srv import SetBool, SetBoolResponse 이번에 사용하는 데이터 타입은 크게 2 종류입니다.\n로봇 제어 topic에 사용되는 Twist 긴급 정지 service에 사용될 SetBool image from : docs.ros.org\nSetBoolResponse이라는 것은 SetBool srv 중 response 부분에 해당합니다. 기본 데이터 타입 이름 + Response를 붙여주기만 하면 사용 가능합니다.\nROS의 msg, srv는 다양한 언어와 상황을 고려하도록 만들어져 있으며, ROS 2에서는 IDL이라는 이름으로 더욱 발전하였습니다. 이후의 커스텀 데이터 타입 제작을 통해 이 과정을 다시 살펴봅시다.\n다음으로 통신 메커니즘을 생성합니다. class EmergencyStopNode(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;emergency_stop\u0026#34;, SetBool, self.stop_cb) 로봇 제어를 위한 topic publisher와 service server를 생성합니다.\nrospy.Service()를 통해 Service Server를 생성할 수 있으며 다음과 같은 매개변수를 필요로합니다.\nService 이름 srv 타입 Client로부터 request가 올 시 실행되는 callback 함수 callback 함수는 일전 subscriber에서 살펴본 바 있습니다. service server의 callback 함수는 항상 매개변수로 request srv를 받습니다. 그리고 return 값은 항상 response가 됩니다.\ndef stop_cb(self, request): ... return self.response_ request 데이터 중 boolean 값을 갖는 data의 true / false 여부에 따라 로봇의 정지 여부가 결정됩니다. if request.data is True: self.twist_msg_.linear.x = 0.0 self.twist_msg_.angular.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) self.response_.success = True self.response_.message = \u0026#34;Successfully Stopped\u0026#34; else: self.response_.success = False self.response_.message = \u0026#34;Stop Failed\u0026#34; 마지막에 사용한 rqt의 service caller는 별도의 프로그래밍이나 복잡한 터미널 명령어 없이도 손쉽게 service를 다룰 수 있게 해주는 ROS의 툴입니다.\n지금까지 ROS Service에 대해 배워보았습니다. Topic과 더불어 많이 사용되는 통신 메커니즘이므로 잘 숙지하고 복습하시기 바랍니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture6/",
	"title": "Lecture6 - ",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]