[
{
	"uri": "/kr/ros_basic_noetic/",
	"title": "ROS Basics",
	"tags": [],
	"description": "",
	"content": "\nLecture1. Lecture1 - Introduction to ROS Lecture2. Dev Env Setup Lecture3. Core of ROS Lecture4. ROS Launch, RViz Lecture5. First Programming, ROS Topic Lecture6. ROS Service, Parameter Lecture7. Rqt Tools and rosbag, ROS Time Lecture8. Deal with Open Source Projects, Custom Interfaces Lecture9. ROS TF and Examples Lecture10. TF2 Examples, Outro "
},
{
	"uri": "/kr/advanced_contents_ros1/",
	"title": "ROS",
	"tags": [],
	"description": "",
	"content": "\nLecture1 - ROSCPP Lecture2 - More About ROS System Lecture2 - SROS "
},
{
	"uri": "/kr/ros2_basic_foxy/",
	"title": "ROS 2 Basics",
	"tags": [],
	"description": "",
	"content": "\nLecture1. Lecture1 - Introduction to ROS 2 Lecture2. ROS 2 Node, Package Lecture3. ROS 2 Node Programming, ROS 2 Parameter Lecture4. ROS 2 Node C++ Programming Lecture5. ROS 2 Topic and Examples Lecture6. ROS 2 Service and Examples Lecture7. Useful ROS 2 Examples, Nav2 Lecture8. ROS 2 Action and Examples Lecture9. C++ Programming Again, Outro "
},
{
	"uri": "/kr/advanced_contents_ros2/",
	"title": "ROS 2",
	"tags": [],
	"description": "",
	"content": "\nLecture1 - About DDS Lecture2 - About DDS (2) Lecture2 - SROS2 "
},
{
	"uri": "/kr/ros_and_gazebo/",
	"title": "Gazebo and ROS",
	"tags": [],
	"description": "",
	"content": "\nLecture1 - Gazebo and ROS Lecture2 - Gazebo and ROS (2) "
},
{
	"uri": "/kr/",
	"title": "2023 Road Balance ROS Lecture Note",
	"tags": [],
	"description": "",
	"content": "2023 ROAD BALANCE ROS LECTURE NOTE 본 사이트는 2023년 Road Balance의 ROS/ROS 2 강의에 사용되는 강의 노트입니다.\nROS Noetic Lecture Lecture1. Lecture1 - Introduction to ROS Lecture2. Dev Env Setup Lecture3. Core of ROS Lecture4. ROS Launch, RViz Lecture5. First Programming, ROS Topic Lecture6. ROS Service, Parameter Lecture7. Rqt Tools and rosbag, ROS Time Lecture8. Deal with Open Source Projects, Custom Interfaces Lecture9. ROS TF and Examples Lecture10. TF2 Examples, Outro Lecture11 - ROSCPP Lecture12 - More About ROS System Lecture13 - SROS ROS 2 Foxy Lecture Lecture1. Lecture1 - Introduction to ROS 2 Lecture2. ROS 2 Node, Package Lecture3. ROS 2 Node Programming, ROS 2 Parameter Lecture4. ROS 2 Node C++ Programming Lecture5. ROS 2 Topic and Examples Lecture6. ROS 2 Service and Examples Lecture7. Useful ROS 2 Examples, Nav2 Lecture8. ROS 2 Action and Examples Lecture9. C++ Programming Again, Outro Lecture10 - About DDS Lecture11 - About DDS (2) Lecture12 - SROS2 Lecture13 - Gazebo and Robot(1) Lecture14 - Gazebo and Robot(2) Advanced Contents ROS Lecture1 - ROSCPP Lecture2 - More About ROS System Lecture2 - SROS ROS 2 Lecture1 - About DDS Lecture2 - About DDS (2) Lecture2 - SROS2 ROS and Simulations Gazebo Lecture1 - Gazebo and ROS Lecture2 - Gazebo and ROS (2) Issac Sim Ongoing \u0026hellip; "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture1/",
	"title": "Lecture1 - Introduction to ROS 2",
	"tags": [],
	"description": "",
	"content": "About ROS 2 image from : foxglove.dev ROS의 시작은 연구실이었습니다. 구글의 핵심 개발자였던 Scott Hassan은 2006년 Willow Garage를 설립하였고, 여기서 처음으로 ROS가 탄생하였습니다. 이후 Willow Garage는 여러 Spin-off를 거친 뒤 OSRF와 OSRC등으로 나뉘게 되었고, 현재 Gazebo와 ROS는 이들에 의해 관리되고 있습니다.\n2022년 12월 기준 구글의 자회사인 Alphabet의 Intrinsic이 OSRF를 품게 되었으며, Ubuntu Linux를 관리하는 Canonical에서 ROS의 공식 서포트를 약속하고, Jetson 보드와 Issac Sim들을 개발하고 있는 Nvidia에서도 ROS를 공식 지원하고 있습니다.\n이렇게 많은 기업들이 ROS에 거는 기대가 큰 만큼 로봇 시장의 성장성도 기대가 됩니다. 하지만, 로봇이 상용화되기 위해서는 여러 난관이 있습니다.\n보안 안정성 실시간성 개발 용이성 기술 지원 하드웨어 연동 etc… 연구용으로 설계된 기존 ROS를 통해서는 이러한 모든 조건을 충족할 수 없다는 결론을 내렸고, Open Robotics는 ROS 2를 새롭게 선보이게 됩니다.\nROS 1 vs ROS 2 기존 언급되었던 ROS 1의 모든 문제들이 ROS 2에서 해결되었다고 할 수는 없지만 적어도 해결을 고려하여 설계되었다고 말하고 싶습니다.\nROS 1과 비교하여 ROS 2의 장점들을 간단히 살펴봅시다.\nimage from : maker.pro 상용화를 고려한 가장 큰 변화로 패킷 통신에 TCPROS/UPDROS가 아닌 DDS(Data Distribution Service)를 도입하였다는 것입니다.\nimage from : omg.org 뿐만 아니라, 임베디드 시스템을 위한 micro-ros와 같은 멋진 프로젝트들도 ROS 2에서 새롭게 등장하였습니다.\nimage from : freertos 이렇게 멋진 ROS 2를 지금부터 함께 배워보겠습니다.\nAbout this lecture ROS 1 강의에서는 ROS Noetic 버전을 사용하였으며, 동일한 Ubuntu 20.04 버전에서 구동되는 ROS 2 Foxy를 사용할 예정입니다.\nROS 설정을 잘 따라오셨다면 별도의 설치 과정은 필요 없으며, 리눅스 커멘드 사용법, 패키지 설치 등 기본적인 내용은 알고 있다는 가정 하에 강의를 진행해보겠습니다.\nimage from : docs.ros.org ROS 1강의를 통해 탄탄하게 다진 기본기를 바탕으로 아래와 같은 내용들을 다뤄봅니다.\nROS 2 기본 커멘드 C++ ROS 프로그래밍 Nav 2를 사용한 자율주행 실제 로봇 데이터 활용해보기 과제를 통한 ROS 2 응용 프로그래밍 더불어, 이번 강의를 통해 실제 로봇이 어떻게 개발되는지 바닥부터 살펴보고자 합니다.\n로봇 설계 시뮬레이션 제작과 실습 실제 로봇을 만들기 위해 필요한 요소들 유지 보수와 로봇 제품 개발 Road Balance의 차량형 교육 로봇, SRC를 통해 실습해보겠습니다.\n강의를 수강하기 위해 필요한 선수지식 ROS 2는 Python 3와 C++ 11이상의 버전을 지원합니다. 따라서 최소한의 프로그래밍 지식이 있다는 가정 하에 강의가 진행되며, 환경 설정, ROS 개념 등 ROS 1 강의를 모두 수강했다는 전제 하에 진행됩니다.\nimage from : docs.ros.org 이번 강의에서는 좀 더 실질적인 ROS 2 개발을 맛보고자 C++를 활용한 프로그래밍도 준비해 보았으니 이번 기회에 C++를 공부해 보는 것도 좋은 기회가 되실 겁니다.\nROS 2 Workspace 생성 ROS 1에서 catkin build system을 사용한 것과 유사하게, ROS 2에서는 colcon이라는 빌드 시스템을 사용하고 있습니다. colcon을 사용하기 위해서 Workspace가 필요하며, ROS 1과 ROS 2를 모두 사용하는 현재 시스템 같은 경우, 혼란스럽지 않도록 이름을 달리 설정하겠습니다.\ncd ~/ mkdir -p ros2_ws/src cd ros2_ws colcon build 아래와 같은 폴더 구조가 생성되었을 것입니다. build : 컴파일 된 C++ 프로그램, custom interface 등이 위치하게 됩니다. install : ros2 launch와 ros2 run 등의 명령어는 프로그램의 실행 시 이 install 폴더 내 파일들을 조회합니다. 일종의 바로가기들의 모임이라고 생각하면 됩니다. log : colcon build 시 발생하는 로드들이 위치하게 됩니다. src : 모든 소스 코드들이 위치하게 됩니다. Package를 지우고 싶은 경우 ⇒ build와 install 폴더에서 해당 package에 해당하는 내용들을 삭제합니다.\ncolcon을 사용하여 package를 빌드하는 방법들을 간단히 소개합니다.\ncolcon build : src 폴더 내부에 존재하는 모든 package들을 빌드합니다. colcon build \u0026ndash;packages-up-to : 해당 package의 종속성이 존재할 시, 이들을 먼저 빌드하고 pkg-name을 빌드합니다. colcon build \u0026ndash;packages-select : 해당 package만을 빌드합니다. 새로운 Package를 빌드한 다음 ROS 2에서도 setup.bash를 source 해주어야 합니다. 이 작업에는 크게 두가지가 존재합니다.\nsource install/setup.bash ⇒ workspace를 source하고 ROS 2시스템 전체를 갱신합니다. source install/local_setup.bash ⇒ workspace만을 sources합니다. (여러 ROS 2 workspace가 있는 경우 local_setup.bash를 사용합시다.) # source chained prefixes # setting COLCON_CURRENT_PREFIX avoids determining the prefix in the sourced script COLCON_CURRENT_PREFIX=\u0026#34;/opt/ros/foxy\u0026#34; _colcon_prefix_chain_bash_source_script \u0026#34;$COLCON_CURRENT_PREFIX/local_setup.bash\u0026#34; # source this prefix # setting COLCON_CURRENT_PREFIX avoids determining the prefix in the sourced script COLCON_CURRENT_PREFIX=\u0026#34;$(builtin cd \u0026#34;`dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;`\u0026#34; \u0026gt; /dev/null \u0026amp;\u0026amp; pwd)\u0026#34; _colcon_prefix_chain_bash_source_script \u0026#34;$COLCON_CURRENT_PREFIX/local_setup.bash\u0026#34; unset COLCON_CURRENT_PREFIX unset _colcon_prefix_chain_bash_source_script 마지막으로, 이번 실습에 필요한 소스 코드를 clone 하고, apt 패키지를 설치하면서, 강의를 마치겠습니다.\ncd ~/ros2_ws/src git clone https://github.com/RB2023ROS/du2023-ros2.git cd du2023-ros2 ./setup_scripts.sh 참고자료\nhttps://www.theconstructsim.com/infographic-ros-1-vs-ros-2-one-better-2/ https://rsl.ethz.ch/education-students/lectures/ros.html https://velog.io/@hwang-chaewon/ROS2006 "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture2/",
	"title": "Lecture2 - ROS 2 Node, Package",
	"tags": [],
	"description": "",
	"content": " ROS Noetic 강의를 이미 학습하였기 때문에, Node, Package, launch file, Topic, Message, Service와 같은 개념은 이미 알고 계실 것이라 생각합니다. (맞죠?)\n혹시나 잊어버리셨을 수 있으니 강의 중간중간 제가 간단히 리뷰를 하면서 진행하겠습니다.\nROS 2 Node image from : docs.rog.org ROS에서의 Node는 하나의 실행 가능한 프로그램을 이야기하며, 각각의 Node는 본인 고유의 기능을 담당합니다.\n서로 다른 역할을 담당하는 Node들이 각자의 동작을 수행하고 서로 간의 데이터를 주고받게 됨으로 시스템을 형성하게 되고, 따라서, ROS를 통한 로봇 개발은 곧, 적절한 Node들의 개발이라고도 말할 수 있습니다.\nROS 2 Node 실행 - ROS 2에서 Node의 실행은 ros2 run \u0026lt;pkg-name\u0026gt; \u0026lt;executable-name\u0026gt;입니다. sudo apt install ros-foxy-turtlesim -y ros2 run turtlesim turtlesim_node ROS 2의 Node를 다루는 명령어는 ROS 1과 크게 다르지 않습니다. $ ros2 node list /teleop_turtle /turtlesim $ ros2 node info /turtlesim /turtlesim Subscribers: /parameter_events: rcl_interfaces/msg/ParameterEvent /turtle1/cmd_vel: geometry_msgs/msg/Twist Publishers: /parameter_events: rcl_interfaces/msg/ParameterEvent /rosout: rcl_interfaces/msg/Log /turtle1/color_sensor: turtlesim/msg/Color /turtle1/pose: turtlesim/msg/Pose Service Servers: /clear: std_srvs/srv/Empty … rqt_graph도 동일하게 사용 가능합니다. $ rqt_graph ROS 2 Package ROS의 Package는 파일 관점에서 관련된 소스코드, 라이브러리, 모델링 파일들, 설정 파일들을 한데 모아둔 폴더로 생각할 수 있으며, 기능 관점에서 시뮬레이션, 하드웨어 제어, 센서 다루기 등으로 분리시킨 모듈로 생각할 수 있습니다.\nimage from : packthub 새로운 패키지를 생성하는 과정에서, ROS 2는 ROS 1과 차이점이 있습니다.\nROS 1에서 catkin_create_package를 사용했던 것처럼, ROS 2에서는 colcon을 사용하여 새로운 package를 생성합니다. 하지만, ROS 2에서는 사용하는 프로그래밍 언어(python/c++)에 따라 다른 build type을 지정할 수 있습니다.\nROS 2 Python Package 파이썬 패키지의 생성은 다음과 같습니다. $ ros2 pkg create --build-type ament_python \u0026lt;package_name\u0026gt; $ ros2 pkg create --build-type ament_python my_first_pkg going to create a new package package name: my_first_pkg destination directory: /home/kimsooyoung/ros2_ws/src package format: 3 version: 0.0.0 ... 그리고, 다음과 같은 폴더 구조가 자동 생성됩니다. my_first_pkg/ ├── my_first_pkg │ └── __init__.py ├── package.xml ├── resource │ └── my_first_pkg ├── setup.cfg ├── setup.py └── test ├── test_copyright.py ├── test_flake8.py └── test_pep257.py 새롭게 만든 패키지를 빌드해봅시다. $ cd ~/ros2_ws $ colcon build --packages-select my_first_pkg Starting \u0026gt;\u0026gt;\u0026gt; my_first_pkg Finished \u0026lt;\u0026lt;\u0026lt; my_first_pkg [1.56s] Summary: 1 package finished [1.96s] $ source install/local_setup.bash 생성한 파이썬 코드 패키지에서, 실제 파이썬 코드는 어디에 위치할까요?\n새로운 패키지를 생성하면 해당 패키지 폴더 안에 패키지 이름과 동일한 폴더가 하나 위치하게 됩니다. 이 폴더 안에는 init.py 파일이 기본적으로 위치합니다. 참고로, wsl에서 파일 탐색기를 열기 위해서는 explorer.exe . 를 입력하시면 됩니다.\n강의 예시 소스코드를 하나 끌어와 빌드해보겠습니다. 아주 간단한 파이썬 예시가 실행될 것입니다. $ cd ~/ros2_sw $ colcon build --packages-select py_node_tutorial Starting \u0026gt;\u0026gt;\u0026gt; py_node_tutorial Finished \u0026lt;\u0026lt;\u0026lt; py_node_tutorial [1.85s] Summary: 1 package finished [2.14s] $ source install/local_setup.bash $ ros2 run py_node_tutorial example_node_1 [INFO] [1672462290.252773294] [example_node_1]: ==== Hello ROS 2 ==== 여기서 주목할 점은, node의 실행 시 roscore가 없어도 된다는 점입니다. DDS를 사용함으로 각각의 node가 분산 처리가 가능하기 때문에 가능한 것입니다.\nimage from : design.ros2.org ROS 2 C++ Package 대부분의 오픈소스 패키지들은 C++로 개발되어 있는 경우가 많습니다. turtlesim의 소스코드를 확인해봅시다.\nhttps://github.com/ros/ros_tutorials\n모두 C++로 개발되어 있습니다. 따라서, 실제 작업 시 파이썬을 위주로 사용하더라도 적어도 C++ 패키지의 구조는 파악하고 있어야 오류 상황에 대처할 수 있습니다.\nC++ 패키지의 생성은 다음과 같습니다. $ ros2 pkg create --build-type ament_cmake \u0026lt;package_name\u0026gt; $ ros2 pkg create --build-type ament_cmake my_first_cpp_pkg going to create a new package package name: my_first_cpp_pkg destination directory: /home/kimsooyoung/ros2_ws/src package format: 3 version: 0.0.0 ... C++ 패키지는 다음과 같은 구조를 갖습니다. 파이썬과 달리, C++는 컴파일 언어이기 때문에 CMake를 위한 CMakeLists.txt 파일이 추가되어 있습니다. my_first_cpp_pkg ├── CMakeLists.txt ├── include │ └── my_first_cpp_pkg ├── package.xml └── src 일반적으로 C++ 개발을 하다보면 header와 source의 분리를 시키곤 합니다.\n이를 위해 보통 include 폴더 안에 헤더 파일을 위치시키고, src 폴더 안에 소스 코드를 위치시킵니다.\n빌드와 실행은 C++ 패키지도 동일한 커멘드 라인을 사용합니다. $ colcon build --packages-select cpp_node_tutorial $ source install/local_setup.bash Starting \u0026gt;\u0026gt;\u0026gt; cpp_node_tutorial Finished \u0026lt;\u0026lt;\u0026lt; cpp_node_tutorial [0.42s] Summary: 1 package finished [0.64s] $ ros2 run cpp_node_tutorial example_node_1 [INFO] [1672462275.581606122] [example_node_1]: ==== Hello ROS 2 ==== apt를 통한 패키지 사용하기 널리 사용되고 검증된 패키지들은 소스 코드 빌드 없이 명령어 하나만으로 사용할 수 있습니다. 다만, ROS 1과 ROS 2, 그리고 같은 ROS 2일지라도 버전에 따라 재설치를 해줘야 합니다.\n$ sudo apt install ros-\u0026lt;DISTRO\u0026gt;-\u0026lt;pkg-name\u0026gt; $ sudo apt install ros-foxy-turtlesim 지금까지 우리가 사용했던 turtlesim, turtle_teleop_key는 모두 apt install turtlesim을 통해 설치가 가능하였기에 코드에 대한 고려 없이 바로 실행할 수 있던 것입니다.\n이를 사용하여 ROS 개발 초기에는 바로 설치 가능한 패키지들을 조합하여 빠르게 검증을 하고, 이후 직접 Customizing해야 하는 부분은 별도 소스코드 빌드를 통해 업그레이드를 하곤 합니다.\nROS 2 Launch ROS 2의 launch파일은 기본적으로 Python 문법을 사용합니다. 기존 ROS 1에서 xml 문법을 사용하던 것에서 비교하면, 보다 손쉽게 접근할 수 있어졌습니다.\n예제를 통해 기본 구조에 대해 짚고 넘어가겠습니다. $ cd ~/ros2_ws $ colcon build --packages-select src_description $ source install/local_setup.bash $ ros2 launch src_description src_description.launch.py 사진과 같이 RViz2와 joint state publisher gui가 등장할 것입니다. joint state publisher gui의 슬라이드바를 이리저리 옮겨보세요.\nROS 1 강의에서 배워보았던 tf에 대해서도 복습할 수 있는 기회입니다.\nros2의 launch 명령어는 다음과 같이 구성되어 있습니다. $ ros2 launch \u0026lt;package-name\u0026gt; \u0026lt;launch-file-name\u0026gt; 패키지 내에 존재하는 특정 launch 파일을 실행해라, 라는 뜻이 됩니다.\n예제 launch file을 살펴봅시다. ros2의 launch file은 python과 xml을 지원합니다. python 파일의 경우 .launch.py로 이름짓는 것이 일반적입니다.\n항상 launch file의 분석은 가장 하단부터 시작합니다. return LaunchDescription([ TimerAction( period=3.0, actions=[rviz2] ), robot_state_publisher, joint_state_publisher_gui, ]) LaunchDescription[] 안에 위치한 프로그램들을 동시에 실행하는 것이 launch file을 작성하는 이유입니다.\n상단 옵션을 하나씩 살피겠습니다. launch file에서 특정 폴더, 파일에 접근하기 위해 package에 기반하여 경로를 탐색합니다. def generate_launch_description(): pkg_path = os.path.join(get_package_share_directory(\u0026#34;src_description\u0026#34;)) rviz_config_file = os.path.join(pkg_path, \u0026#34;rviz\u0026#34;, \u0026#34;description.rviz\u0026#34;) urdf_file = os.path.join(pkg_path, \u0026#34;urdf\u0026#34;, \u0026#34;src_body.urdf\u0026#34;) urdf - Unified Robotics Description Format란 로봇의 형상을 파일로 표현하는 일종의 포멧입니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;!-- | This document was autogenerated by xacro from /home/kimsooyoung/ros2_ws/src/du2023-ros2/src_gazebo/urdf/src_body.urdf.xacro | --\u0026gt; \u0026lt;!-- | EDITING THIS FILE BY HAND IS NOT RECOMMENDED | --\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;robot name=\u0026#34;src_body\u0026#34;\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.700 0.700 0.700 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;1.000 1.000 1.000 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.0 0.8 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;green\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.0 0.8 0.0 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;grey\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.2 0.2 0.2 1.0\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; ... image from : http://library.isr.ist.utl.pt/ src의 urdf와 description 결과를 함께 살펴보면서 urdf에 대한 개념을 익혀봅시다.\nurdf를 생성하는 여러 방법들이 있습니다.\nxacro와 함께 직접 텍스트를 작성하기 CAD 프로그램을 사용하기 SOLIDWORKS Fusion 360 blender 시뮬레이션 프로그램 내 model builder 사용하기 Gazebo Colleliasim 저의 경우, Fusion 360에서 사용할 수 있는 오픈소스 urdf exporter를 통해 시뮬레이션을 개발하였습니다.\nhttps://github.com/syuntoku14/fusion2urdf\nurdf를 사용하여 ROS에게 로봇에 대한 정보를 전달하고 지속 주시하는 것이 아래 두 Node의 역할입니다. joint_state_publisher_gui = Node( package=\u0026#34;joint_state_publisher_gui\u0026#34;, executable=\u0026#34;joint_state_publisher_gui\u0026#34;, name=\u0026#34;joint_state_publisher_gui\u0026#34;, ) robot_state_publisher = Node( package=\u0026#39;robot_state_publisher\u0026#39;, executable=\u0026#39;robot_state_publisher\u0026#39;, name=\u0026#39;robot_state_publisher\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[{\u0026#39;use_sim_time\u0026#39;: True}], arguments=[urdf_file], ) launch file 분석의 마지막으로 Rviz2 실행입니다. Rviz와 동일하게 launch file에서 config option을 줄 수 있으며, TimerAction을 통해 3초의 여유를 갖고 실행하도록 하였습니다. # Launch RViz rviz2 = Node( package=\u0026#34;rviz2\u0026#34;, executable=\u0026#34;rviz2\u0026#34;, name=\u0026#34;rviz2\u0026#34;, output=\u0026#34;screen\u0026#34;, arguments=[\u0026#34;-d\u0026#34;, rviz_config_file], ) return LaunchDescription([ TimerAction( period=3.0, actions=[rviz2] ), ROS 2의 launch file 작성법을 간단하게 설명하고 넘어가겠습니다. robot_state_publisher = Node( package=\u0026#39;robot_state_publisher\u0026#39;, executable=\u0026#39;robot_state_publisher\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[robot_description] ) Node : Node 하나를 실행시킬 수 있는 옵션입니다. package : 실행시킬 Node가 포함된 package를 선택해줍니다. executable : c++ Node의 경우, colcon build를 하면 실행 가능한 프로그램이 생성됩니다. python의 경우도 스크립트를 실행 시키게 되며, 추후 코딩 실습을 거치면 완벽히 이해하실 수 있을 것입니다. parameters : 실행시킬 Node의 추가 매개변수가 있다면 이 부분에 추가됩니다. 이렇게 launch file 하나를 분석해 보았습니다. 하지만, 제가 보여드린 것은 하나의 예시일 뿐이며, launch file은 여러 형식으로 사용되고 있습니다.\n일례로, 자율 주행 시 사용되는 nav2 패키지의 lanuch file은 다음과 같은 형태를 갖습니다.\ndeclare_namespace_cmd = DeclareLaunchArgument( \u0026#39;namespace\u0026#39;, default_value=\u0026#39;\u0026#39;, description=\u0026#39;Top-level namespace\u0026#39;) ... # Create the launch description and populate ld = LaunchDescription() # Set environment variables ld.add_action(stdout_linebuf_envvar) # Declare the launch options ld.add_action(declare_namespace_cmd) ld.add_action(declare_use_namespace_cmd) ld.add_action(declare_slam_cmd) ld.add_action(declare_map_yaml_cmd) ld.add_action(declare_use_sim_time_cmd) ld.add_action(declare_params_file_cmd) ld.add_action(declare_autostart_cmd) ld.add_action(declare_bt_xml_cmd) # Add the actions to launch all of the navigation nodes ld.add_action(bringup_cmd_group) return ld 아직 프로그래밍을 시작하지도 않았기 때문에, launch file에 대해서 모두 이해하려 하지는 않으셔도 됩니다. 남은 강의들에서 계속해서 살펴보겠습니다.\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture3/",
	"title": "Lecture3 - ROS 2 Node Programming, ROS 2 parameter",
	"tags": [],
	"description": "",
	"content": " Python을 사용하여 Node Programming을 실습해봅시다. 강의 마지막에는 간단히 C++ 코딩에 대해서도 다뤄보겠습니다.\nexample 1 - Hello ROS 2 강의를 위해 준비된 예제 코드 패키지를 실습하고 분석하겠습니다.\n$ colcon build --packages-select cbp py_node_tutorial $ source install/local_setup.bash $ ros2 run py_node_tutorial example_node_1 [INFO] [1672463872.778216198] [example_node_1]: ==== Hello ROS 2 ==== 모든 예제 코드는 아래 링크에서 확인할 수 있습니다. https://github.com/RB2023ROS/du2023-ros2/tree/main/py_node_tutorial/py_node_tutorial\n코드 분석을 차근차근 함께 해보겠습니다.\nrcl은 ROS Client Libraries의 약자로 ROS 2에서는 rclc, rclcpp, rclpy, rcljs와 같은 다양한 언어를 지원하고 있습니다. 파이썬에서 ROS 2 개발을 하기 위해서는 필수적으로 rclpy의 import가 필요하며 Node의 사용을 위해서는 Node class를 import 해야 합니다.\n# !/usr/bin/env python3 import rclpy from rclpy.node import Node rclpy 코딩 규칙 ROS 2에서 파이썬 파일을 조회하고 실행하는 과정이 있어 아래와 같이 main()부분을 항상 따로 분리하여 작성하도록 합니다.\nif __name__ == \u0026#39;__main__\u0026#39;: \u0026#34;\u0026#34;\u0026#34;main function\u0026#34;\u0026#34;\u0026#34; main() Node 생성 def main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) node.destroy_node() rclpy.shutdown() 실제 동작을 수행하는 main 함수를 살펴보면 다음과 같은 과정을 거치고 있습니다.\nrclpy.init을 통해 initialization, 즉 초기화를 하고 있습니다. node = Node(\u0026rsquo;node_name\u0026rsquo;) : Node를 생성하는 부분으로 앞서 import한 Node class를 사용하고 있습니다. 매개변수로 node의 이름이 들어갑니다. node.destroy_node() : Node를 생성하고 원하는 작업을 모두 수행했다면, 이제 사용했던 Node를 제거해야 할 것입니다. 그래야 불필요한 자원의 낭비를 줄일 수 있겠지요. rclpy.shutdown() : 이번 예제의 제일 첫 부분에 rclpy.init을 통하여 초기화를 해주었습니다. 이제 rclpy를 통한 작업이 모두 끝났으므로 안전하게 종료시켜줍니다. 위 과정이 Python에서 rclpy를 통해 Node를 다루는 기본 절차입니다.\n1과 4, 2와 3이 짝꿍처럼 보이지요?\nsetup.py 수정 파이썬 파일을 ros2 run 으로 실행하기 위해서 패키지 내 setup.py 파일에 entry_points를 추가해 주어야 합니다.\nentry_points={ \u0026#39;console_scripts\u0026#39;: [ \u0026#39;example_node_1 = py_node_tutorial.node_example_1:main\u0026#39;, \u0026#39;example_node_2 = py_node_tutorial.node_example_2:main\u0026#39;, \u0026#39;example_node_3 = py_node_tutorial.node_example_3:main\u0026#39;, \u0026#39;example_node_4 = py_node_tutorial.node_example_4:main\u0026#39;, \u0026#39;example_node_5 = py_node_tutorial.node_example_5:main\u0026#39;, ], }, 작성하는 방법은 다음과 같습니다. ⇒ 실행 시 사용될 이름 = \u0026lt;패키지 이름\u0026gt;.\u0026lt;파일 이름\u0026gt;.main\nexample 2 - timer 로봇은 실행된 이후 계속해서 작업을 수행해야 하기에 주기적으로 무언가를 실행하는 일이 잦습니다. 이를 구현하는 Timer를 살펴봅시다. $ ros2 run py_node_tutorial example_node_2 ==== Hello ROS 2 : 1==== ==== Hello ROS 2 : 2==== ==== Hello ROS 2 : 3==== ==== Hello ROS 2 : 4==== ==== Hello ROS 2 : 5==== main문에 추가된 create_timer와 timer_callback 함수를 확인할 수 있습니다. def timer_callback(): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; global count count += 1 print(f\u0026#39;==== Hello ROS 2 : {count}====\u0026#39;) def main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.create_timer(0.2, timer_callback) rclpy.spin(node) node.destroy_node() rclpy.shutdown() timer를 생성하기 위해서 create_timer 함수가 사용됩니다.\ntimer_period_sec : 실행 주기 (초) callback : 해당 주기마다 실행될 함수 image from : docs.ros2.org\nexample 3 - spin_once, spin Node의 상태를 살피면서 반복 실행시키는 spin 함수에 대해 좀 더 자세하게 살펴봅니다.\n예제 실행 $ ros2 run py_node_tutorial example_node_3 ==== Hello ROS 2 : 1==== ==== Hello ROS 2 : 2==== ==== Hello ROS 2 : 3==== ... 주요 코드를 분석해 보겠습니다. Node는 상태를 지속 유지하면서 변경된 내용에 따라 지정된 동작을 수행해야 합니다. 이는 로봇 프로그램에서 매우 보편적인 작업으로, ROS 2에서는 **spin()**이라는 이름의 함수로 기능을 제공하고 있습니다.\ndef main(args=None): \u0026#34;\u0026#34;\u0026#34;Do enter into this main function first.\u0026#34;\u0026#34;\u0026#34; rclpy.init(args=args) node = Node(\u0026#39;node_name\u0026#39;) node.create_timer(0.2, timer_callback) while True: rclpy.spin_once(node, timeout_sec=10) node.destroy_node() rclpy.shutdown() spin을 비롯하여 spin_once, spin_until_future_complete와 같이 프로그램의 실행을 관리하기 위한 다양한 추가 함수들이 존재합니다.\ntimer_callback과 OOP의 필요성 def timer_callback(): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; global count count += 1 print(f\u0026#39;==== Hello ROS 2 : {count}====\u0026#39;) # How can I use logger without globalization ? # node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) callback 함수가 사용되면 필연적으로 두 함수 간 공유되는 count와 같은 자원이 생기며, 이 count를 다루면서 예기치 못한 실수가 발생할 수 있습니다.\n지금은 모두 전역 변수로 작업하고 있었는데, 이것을 어떻게 효율적으로 처리할 수 있을까요?\nexample 4 - OOP Node 예제 실행의 결과는 이전과 같습니다. 하지만 구현에서 차이를 갖습니다. $ ros2 run py_node_tutorial example_node_5 [INFO] [1657348011.971419700] [composition_example_node]: ==== Hello ROS 2 : 1==== [INFO] [1657348012.163466100] [composition_example_node]: ==== Hello ROS 2 : 2==== [INFO] [1657348012.363590700] [composition_example_node]: ==== Hello ROS 2 : 3==== class를 사용하여 Node를 구현한 모습을 확인할 수 있습니다. class NodeClass(Node): \u0026#34;\u0026#34;\u0026#34;Second Node Class. Just print log periodically. \u0026#34;\u0026#34;\u0026#34; def __init__(self): \u0026#34;\u0026#34;\u0026#34;Node Initialization. You must type name of the node in inheritanced initializer. \u0026#34;\u0026#34;\u0026#34; super().__init__(\u0026#39;composition_example_node\u0026#39;) self.create_timer(0.2, self.timer_callback) self._count = 1 def timer_callback(self): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; self.get_logger().info(f\u0026#39;==== Hello ROS 2 : {self._count}====\u0026#39;) self._count += 1 ROS 1과 달리, ROS 2의 OOP 구현은 Node를 상속받습니다. (때문에 생성 시, Node이름을 super().__init__()안에 넣어주어야 합니다.)\n이렇게 객체지향을 사용하면 Node의 기능들을 적극 활용하여 더욱 쉽고 강력한 ROS 2 개발이 가능해집니다. 앞으로의 예시에서는 모두 객체 지향을 사용하겠습니다.\nrclpy logger super().__init__(\u0026#39;node_name\u0026#39;) ... node.get_logger().info(\u0026#39;\\n==== Hello ROS 2 ====\u0026#39;) rospy.loginfo()와 같이 rclpy에서도 get_logger라는 logging API를 제공합니다. 다만, rclpy의 logger는 Node에 종속되는 개념입니다. (ROS 2에서는 여러 Node가 하나의 프로세스 안에서 실행될 수 있기 때문입니다.)\nget_logger()를 사용하면 일반적인 print 콘솔 출력과는 달리, 실행중인 Node이름, 시간, 위험성 등을 디버깅할 수 있어 이후 복잡한 시스템에서 큰 도움이 됩니다.\nexample 5 - Logger Level 기본 node 프로그래밍의 마지막 예시입니다. $ ros2 run py_node_tutorial example_node_5 [INFO] [1657348108.163389800] [node_name]: ==== Hello ROS 2 : 1==== [WARN] [1657348108.163810900] [node_name]: ==== Hello ROS 2 : 1==== [ERROR] [1657348108.164126200] [node_name]: ==== Hello ROS 2 : 1==== [FATAL] [1657348108.164514300] [node_name]: ==== Hello ROS 2 : 1==== ... ROS 1에서와 유사하게 ROS 2에서도 위험도에 따라서 다른 logger level을 적용할 수 있습니다.\ninfo를 기준으로 아래로 갈수록 높은 레벨의 log이며, 제일 심각한 error와 fatal의 경우, 콘솔 출력시에도 빨간 글씨로 보이는 것을 확인할 수 있습니다.\nimage from : 51CTO debug의 경우 실제 콘솔 출력으로는 나타나지 않으며, 효과적인 Tracking을 위해 ROS 1 강의에서 배운 rqt console 사용을 권장합니다.\nROS 2 Parameter ROS 1에서와 마찬가지로, ROS 2에서도 각종 매개변수를 다룰 수 있는 커멘드 명령어와 코드 API를 제공합니다.\n예제 Package 빌드와 실행 $ colcon build --packages-select py_param_tutorial $ source install/local_setup.bash $ ros2 run py_param_tutorial param_example [INFO] [1672390971.030532687] [param_ex_node]: string_param: world int_param: 119 float_param: 3.1415 arr_param: [1, 2, 3] nested_param.string_param: Wee Woo param_ex_node에서 5종류의 매개변수가 선언되었습니다. 이들을 확인하는 커멘드 라인을 배워봅시다.\nros2 param list $ ros2 param list /param_ex_node: arr_param float_param int_param nested_param.string_param string_param use_sim_time ros2 param get/set - node 이름과 매개변수 이름을 모두 필요로 함에 주의합니다. $ ros2 param get /param_ex_node arr_param Integer values are: array(\u0026#39;q\u0026#39;, [1, 2, 3]) $ ros2 param set /param_ex_node arr_param \u0026#39;[1,2,3,4]\u0026#39; Set parameter successful $ ros2 param get /param_ex_node arr_param Integer values are: array(\u0026#39;q\u0026#39;, [1, 2, 3, 4]) 이제, 파이썬 코드를 분석해봅시다.\nparameter의 생성은 node 내에서 이루어지며, declare_parameter를 통해 생성합니다. 함수의 두번째 인자는 기본값입니다. nested_param과 같이, parameter는 계층 구조를 가질 수 있으며 . 을 통해 구분할 수 있습니다. string_param이라는 이름을 가진 parameter가 두 종류 존재하지만 서로 소속된 계층이 달라 공존할 수 있는 것입니다.\nclass ParamExNode(rclpy.node.Node): def __init__(self): super().__init__(\u0026#39;param_ex_node\u0026#39;) self.declare_parameter(\u0026#39;string_param\u0026#39;, \u0026#39;world\u0026#39;) self.declare_parameter(\u0026#39;int_param\u0026#39;, 119) self.declare_parameter(\u0026#39;float_param\u0026#39;, 3.1415) self.declare_parameter(\u0026#39;arr_param\u0026#39;, [1,2,3]) self.declare_parameter(\u0026#39;nested_param.string_param\u0026#39;, \u0026#39;Wee Woo\u0026#39;) 선언된 매개변수의 값은 get_parameter를 통해 확인 가능합니다. get_parameter 자체는 Object이고, value 속성이 실제 값을 갖고 있습니다. string_param = self.get_parameter(\u0026#39;string_param\u0026#39;) int_param = self.get_parameter(\u0026#39;int_param\u0026#39;) float_param = self.get_parameter(\u0026#39;float_param\u0026#39;) arr_param = self.get_parameter(\u0026#39;arr_param\u0026#39;) nested_param = self.get_parameter(\u0026#39;nested_param.string_param\u0026#39;) self.get_logger().info(f\u0026#34;\\nstring_param: {string_param.value} \\ \\nint_param: {int_param.value} \\ \\nfloat_param: {float_param.value} \\ \\narr_param: {arr_param.value} \\ \\nnested_param.string_param: {nested_param.value}\u0026#34; ) parameter는 launch file에서도 설정할 수 있습니다. - Hello, 112로 변경된 값을 확인해봅시다. $ ros2 launch py_param_tutorial launch_with_param.launch.py ... [param_example-1] [INFO] [1672387864.135213913] [param_example]: [param_example-1] string_param: Hello [param_example-1] int_param: 112 [param_example-1] float_param: 3.1415 [param_example-1] arr_param: [1, 2, 3] launch file의 parameters 옵션을 사용하여 이러한 작업이 가능합니다. def generate_launch_description(): param_ex_node = Node( package=\u0026#39;py_param_tutorial\u0026#39;, executable=\u0026#39;param_example\u0026#39;, name=\u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[ {\u0026#39;string_param\u0026#39;: \u0026#39;Hello\u0026#39;}, {\u0026#39;int_param\u0026#39;: 112}, ], ) parameter가 매우 많은 경우에는 ROS 1에서와 같이 yaml 파일을 사용해 관리할 수 있습니다. launch file의 주석된 부분을 해제하고 다시 실행해봅시다. config = os.path.join( get_package_share_directory(\u0026#39;py_param_tutorial\u0026#39;), \u0026#39;config\u0026#39;, \u0026#39;params.yaml\u0026#39; ) param_ex_node = Node( package = \u0026#39;py_param_tutorial\u0026#39;, executable = \u0026#39;param_example\u0026#39;, name = \u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters = [config] ) 모든 매개변수들이 변경된 것을 확인 가능합니다.\n$ ros2 launch py_param_tutorial launch_with_param.launch.py ... [param_example-1] [INFO] [1672391557.995024614] [param_example]: [param_example-1] string_param: Yaml Yaml [param_example-1] int_param: 5 [param_example-1] float_param: 3.14 [param_example-1] arr_param: [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;ROS 2\u0026#39;] [param_example-1] nested_param.string_param: Ooh Wee yaml 파일은 config/params.yaml에 위치하고 있습니다. parameter 관리 용도로 사용하기 위해서 yaml 파일은 일정한 규칙을 갖춰야 합니다. param_example: ros__parameters: string_param: \u0026#34;Yaml Yaml\u0026#34; int_param: 5 float_param: 3.14 arr_param: [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;ROS 2\u0026#39;] nested_param: string_param: \u0026#34;Ooh Wee\u0026#34; \u0026lt;node-name\u0026gt;: ros__parameters: \u0026lt;param-name\u0026gt;: \u0026lt;param-value\u0026gt; ... \u0026lt;nested-layer-name\u0026gt;: \u0026lt;param-name\u0026gt;: \u0026lt;param-value\u0026gt; 이렇게 새로운 폴더와 파일을 추가한 경우, python 패키지의 setup.py를 수정해주어야 하며 패키지 빌드도 새로 해주어야 합니다. import os from glob import glob from setuptools import setup package_name = \u0026#39;py_param_tutorial\u0026#39; setup( name=package_name, version=\u0026#39;0.0.0\u0026#39;, packages=[package_name], data_files=[ (\u0026#39;share/ament_index/resource_index/packages\u0026#39;, [\u0026#39;resource/\u0026#39; + package_name]), (\u0026#39;share/\u0026#39; + package_name, [\u0026#39;package.xml\u0026#39;]), (os.path.join(\u0026#39;share\u0026#39;, package_name, \u0026#39;config\u0026#39;), glob(\u0026#39;config/*.yaml\u0026#39;)), (os.path.join(\u0026#39;share\u0026#39;, package_name, \u0026#39;launch\u0026#39;), glob(\u0026#39;launch/*.launch.py\u0026#39;)), ], launch file에 추가된 내용을 다시 살펴보면, 방금 전의 yaml 파일을 불러와서 node의 실행 option에 전달하고 있습니다. config = os.path.join( get_package_share_directory(\u0026#39;py_param_tutorial\u0026#39;), \u0026#39;config\u0026#39;, \u0026#39;params.yaml\u0026#39; ) param_ex_node = Node( package = \u0026#39;py_param_tutorial\u0026#39;, executable = \u0026#39;param_example\u0026#39;, name = \u0026#39;param_example\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters = [config] ) 아래 예시에서 보이듯이 로봇의 초기 속도, 최대/최소 값들, 하드웨어와 관련된 튜닝값 등 수많은 매개변수들이 사용되며 모두 지금 배운 parameter를 사용하게 됩니다.\nhttps://github.com/ros-planning/navigation2/blob/main/nav2_bt_navigator/src/bt_navigator.cpp\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture4/",
	"title": "Lecture4 - ROS 2 Node C++ Programming",
	"tags": [],
	"description": "",
	"content": " 실제 로봇 개발에서 Python만 사용되지는 않습니다. tensorflow, pytorch와 같은 딥러닝 프레임워크들이 모두 Python을 사용하고 있고, 상대적으로 개발 과정이 쉬워 많은 사람들이 Python을 사용하고 있지만, 제어, 센싱을 위해서는 C++를 대부분 사용한다고 보시면 됩니다.\nimage from : wikipedia 따라서 앞선 node 프로그래밍 예시들을 모두 C++로 구현해 볼 예정입니다. 아래와 같은 C++ 지식이 필요하지만 필수는 아닙니다.\n클래스 생성 (OOP) 스마트 포인터 헤더 분리 람다 함수 std::bind와 placeholders C++ 빌드 시스템 (CMake) 코드 설명에 앞서 ROS 2 C++ 패키지를 개발하는 절차에 대해 빠르게 훑어보겠습니다.\n패키지 생성 후 src \u0026amp; include 폴더에서 코드 작성 ros2 pkg create --build-type ament_cmake \u0026lt;package_name\u0026gt; CMakeLists.txt \u0026amp; package.xml 수정 add_executable(example_node_1 src/node_example_1.cpp) ament_target_dependencies(example_node_1 rclcpp) install( TARGETS example_node_1 DESTINATION lib/${PROJECT_NAME} ) 코드 빌드와 디버깅 colcon build --packages-select \u0026lt;package_name\u0026gt; source install/local_setup.bash 코드 실행 ros2 run \u0026lt;pkg-name\u0026gt; \u0026lt;executable-name\u0026gt; 개발 과정 자체는 파이썬 package와 크게 다르지 않습니다.\n하지만, C++ 개발은 코드를 빌드하는 과정에서 각종 컴파일 에러와 링크 에러, 런타임 에러까지 발생하기 때문에 개발에 여러움이 생길 수 있습니다.\n⇒ 이를 해결하기 위해서, 학생 라이센스로 무료 사용 가능한 IDE를 소개하고, 함께 셋업해보고자 합니다.\nCLion 설치와 ROS 2 개발환경 설정 CLion은 IDE의 명가 Jetbrains에서 만든 C/C++용 통합 개발 환경입니다. C++ 개발자를 힘들게 하는 각종 에러들의 디버깅을 편리하게 해줄 뿐더러 ROS 2 개발을 위한 솔루션도 제공하고 있습니다.\nimage from : wikipedia CLion은 오픈소스가 아닌 판매되고 있는 소프트웨어입니다.\n하지만 학생에게는 무료 라이센스를 제공하고 있습니다. 아래 링크를 통해서 회원가입과 학생인증을 진행한 다음, CLion을 설치합시다.\nhttps://www.jetbrains.com/clion/\nhttps://www.jetbrains.com/community/education/#students\n이메일 인증을 거치면 어렵지 않게 학생인증이 완료됩니다. 이 과정은 생략하겠습니다.\n학생 라이센스를 통해 CLion을 비롯하여 IntelliJ, PyCharm, WebStorm과 같은 다양한 언어의 IDE를 무료로 사용 가능합니다. snapcraft를 통해 CLion을 설치하고 실행 해봅시다. $ sudo snap install clion --classic [sudo] password for kimsooyoung: clion 2022.3.1 from jetbrains✓ installed $ clion 약관 동의 및 로그인을 통한 학생 인증을 거치면 모든 설치 절차가 완료됩니다. colcon build를 통해 빌드했던 cpp_node_tutorial package를 clion 프로젝트로 열어보겠습니다. clion에서 File ⇒ Open을 실행한 뒤 cpp_node_tutorial의 CMakeLists.txt를 선택합니다. build target를 지정하고 실행하면 CLion상에서 ROS 2 프로그램을 실행시킬 수 있습니다. CLion에서의 장점을 직접 살펴보기 위해 프로그램 개발을 함께 해보겠습니다. 라이브 코딩 Time!!\n모든 설정이 완료되었다면, 이제 본격적으로 C++ 예제 코드를 살펴봅시다.\nexample 1 - Hello ROS 2 파이썬에서 한차례 살펴본 바 있기에 자세한 로직들은 생략합니다.\n예제 실행 $ ros2 run cpp_node_tutorial example_node_1 [INFO] [1666431282.586519100] [example_node_1]: ==== Hello ROS 2 ==== 코드 분석 #include \u0026lt;rclcpp/rclcpp.hpp\u0026gt; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;example_node_1\u0026#34;); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 ====\u0026#34;); rclcpp::shutdown(); return 0; } rclcpp은 ROS 2를 C++에서 사용하기 위해 필요한 코드의 집합입니다.\nNode 생성 시 주의하셔야 할 점은 “모든 Node가 포인터의 형식을 갖는다”는 것입니다. shared_ptr를 사용하여 메모리 누수를 막기 위해 파생된 모든 데이터들을 추적하고 있습니다.\nrclcpp에서 로그의 실행은 RCLCPP_INFO와 get_logger() 메소드를 통해 실행할 수 있으며, 로그는 Node에서 실행된다는 점을 기억합시다.\nCMakeLists.txt 수정\n# find_package를 통해 종속성들을 추가합니다. find_package(\u0026lt;depends\u0026gt; REQUIRED) # 실행 프로그램 빌드 설정 add_executable(\u0026lt;program_name\u0026gt; include/\u0026lt;header\u0026gt;.hpp src/\u0026lt;code\u0026gt;.cpp ...) ament_target_dependencies(\u0026lt;program_name\u0026gt; \u0026lt;dependency1\u0026gt; \u0026lt;dependency2\u0026gt; ...) install( TARGETS \u0026lt;program_name\u0026gt; DESTINATION lib/${PROJECT_NAME} ) 패키지 빌드 \u0026amp; 실행 colcon build --packages-select cpp_node_tutorial source install/local_setup.bash ros2 run cpp_node_tutorial example_node_1 예제 소스 코드를 조금이라도 수정하여 여러분들만의 코드를 작성해보고 CLion을 통한 빌드까지 스스로 한 번 해봅시다.\nexample 2 - Timer 예제 실행 $ ros2 run cpp_node_tutorial example_node_2 ==== Hello ROS 2 : 0 ==== ==== Hello ROS 2 : 1 ==== ==== Hello ROS 2 : 2 ==== ==== Hello ROS 2 : 3 ==== ==== Hello ROS 2 : 4 ==== ... rclcpp에서 timer는 create_wall_timer를 사용합니다. #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; static int count = 0; void timer_callback(){ std::cout \u0026lt;\u0026lt; \u0026#34;==== Hello ROS 2 : \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; ====\u0026#34; \u0026lt;\u0026lt; std::endl; count++; } int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;example_node_2\u0026#34;); auto timer = node-\u0026gt;create_wall_timer(std::chrono::milliseconds(200), timer_callback); rclcpp::spin(node); rclcpp::shutdown(); return 0; } example 3 - OOP Node 기능 자체는 큰 의미가 없으므로 코드를 위주로 설명하겠습니다. #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; class NodeClass: public rclcpp::Node { public: NodeClass(): Node(\u0026#34;example_node_4\u0026#34;) {} }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;NodeClass\u0026gt;(); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 ====\u0026#34;); rclcpp::shutdown(); return 0; } 모든 Node는 rclcpp::Node로부터 상속을 받습니다. 상속 후 생성자에서 Node의 이름을 지정해줘야 하며, topic pub/sub, logger와 같은 기능들은 모두 rclcpp::Node에 구현되어 있습니다.\n더불어, Node 자체는 포인터로 취급된다는 점도 다시 한 번 강조드립니다.\nexample 4 - OOP Timer Node callback 함수를 binding하는 부분에 집중하세요. timer_callback는 클래스 메소드이기 때문에 binding 시 NodeClass::timer_callback와 같이 명시해주어야 합니다. #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; class NodeClass: public rclcpp::Node { private: size_t count; rclcpp::TimerBase::SharedPtr timer; void timer_callback() { RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d\u0026#34;, count); count++; } public: NodeClass() : Node(\u0026#34;example_node_5\u0026#34;) { timer = this-\u0026gt;create_wall_timer( std::chrono::milliseconds(200), std::bind(\u0026amp;NodeClass::timer_callback, this) ); } }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;NodeClass\u0026gt;(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } 마지막으로 rclcpp logger level을 간단히 살펴보고 마무리짓겠습니다. void timer_callback() { RCLCPP_DEBUG(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_WARN(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_ERROR(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); RCLCPP_FATAL(this-\u0026gt;get_logger(), \u0026#34;==== Hello ROS 2 : %d ====\u0026#34;, count); count++; } 참고자료\nhttps://roboticsbackend.com/ros2-yaml-params/ https://roboticsbackend.com/rclpy-params-tutorial-get-set-ros2-params-with-python/ https://www.jetbrains.com/help/clion/ros2-tutorial.html#change-prj-root "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture5/",
	"title": "Lecture5 - ROS 2 Topic and Examples",
	"tags": [],
	"description": "",
	"content": " Topic에 대해 배워보기 전에, 실습 시스템을 구축해봅시다.\nSRC Gazebo 이번 ROS 2 강의의 실습들은 Road Balance의 차량형 로봇 SRC를 통해 진행하고자 합니다. 실습을 진행하기 전 Gazebo 환경을 함께 세팅해보겠습니다.\nsrc_gazebo 실행 세팅 - 다소 번거로운 작업이므로 gif를 보시면서 차근차근 잘 따라와주세요! cd ~/ros2_ws/src/du2023-ros2 ./setup_scripts.sh # CMakeLists.txt 수정 (주석) colcon build --packages-select src_gazebo source install/local_setup.bash # CMakeLists.txt 수정 (주석 해제) colcon build --packages-select src_gazebo colcon build --packages-select src_odometry colcon build --packages-select src_controller source install/local_setup.bash empty world 실행 ros2 launch src_gazebo empty_world.launch.py 빈 gazebo 환경에 차량형 로봇이 등장할 것입니다. 함께 등장하는 rqt_robot_steering을 통해 로봇을 움직여보세요. 실행 중 발생할 수 있는 오류와 해결방법을 제시드립니다. 아래와 같은 에러 발생 시 sudo apt dist-upgrade를 입력하면 됩니다. 로봇에 부착되어 있는 센서 데이터들과 제어 데이터를 ros2 topic list로 확인해봅시다.\n/cmd_vel : Twist msg를 통해 로봇을 제어하는 topic /imu/data : imu 데이터 /scan : 2D lidar /logi_camera_sensor/image_raw : 전방 카메라 데이터 ROS 2 Topic 강의를 열심히 따라오면서 ROS 개념을 잊어버렸을 수도 있으므로 간단히 개념 복습을 해보겠습니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름이며, 적절한 이름으로 데이터를 송수신하지 않으면 원하는 동작을 수행할 수 없습니다. image from : docs.ros.org\nTopic의 중요한 특징으로 Topic은 여러 Node들로부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. image from : docs.ros.org topic을 통해 데이터가 전달되는 과정은 다음과 같습니다.\n데이터를 보내는 주체인 publisher는 topic을 통해 원하는 정보를 subscriber에게 전달합니다. 이것을 topic publish라고 부르지요. 반대로, 데이터를 받는 주체인 subscriber 입장에선 topic을 통해 데이터를 받게 되며 이것은 topic subscribe라고 불립니다. ROS 2 Topic msg 로봇 프로그래밍 시 센서, 제어 데이터를 비롯하여 다양한 유형의 데이터들이 Topic을 통해 오고 갑니다. ROS에서는 이러한 데이터 형식을 msg - Message라는 형태로 제공하며, 원하는 데이터에 적합한 topic msg를 사용하면 더욱 효율적인 로봇 프로그래밍이 가능해집니다.\nimage from : ethz.ch geometry_msgs/Twist와 같은 message는 ROS 2에서도 동일하게 사용할 수 있습니다. 다만, ROS 2에서는 msg/srv/action 과 같이 필드의 구분이 하나 더 추가됩니다.\nROS 1 : geometry_msgs/Twist ROS 2 : geometry_msgs/msg/Twist 출처 : http://docs.ros.org/ 특정 message가 어떻게 구성되어 있는지 알고 싶을 때는 다음과 같은 커멘드 라인을 사용합니다.\n$ ros2 interface show geometry_msgs/msg/Twist # This expresses velocity in free space broken into its linear and angular parts. Vector3 linear Vector3 angular 혹은 앞서 제가 살펴본 것 처럼 검색을 해 보아도 됩니다.\nROS 2로 넘어오면서, topic 커멘드들은 다음과 같이 살짝 바뀌었습니다.\nrostopic list ⇒ ros2 topic list rostopic info ⇒ ros2 topic info rostopic echo ⇒ ros2 topic echo ROS 2 Topic Tools ROS 2에서도 GUI툴 RQT를 사용할 수 있습니다. Topic과 관련된 rqt tools들을 사용해봅시다.\nROS 1과 ROS 2의 rqt는 다른 프로그램이며 ROS 1의 plugin과 ROS 2의 plugin이 완전 동일하지는 않습니다.\n실습을 위해 gazebo와 rqt를 실행합니다. # Terminal 1 ros2 launch src_gazebo empty_world.launch.py # Terminal 2 rqt rqt 상단의 메뉴바에서 Plugins ⇒ Topics ⇒ Topic Monitor를 클릭합니다. topic monitor를 통해 현재 오가고 있는 topic들을 한눈에 볼 수 있습니다. 이번에는 rqt 상단의 메뉴바에서 Plugins ⇒ Topics ⇒ Message Publisher를 클릭하고, + 버튼을 눌러 publish를 원하는 topic을 추가합니다.\nTopic Publisher는 별도의 작업 없이 msg에 원하는 값을 채워 topic publish가 가능하게 해주는 툴입니다. 최종 publish를 위해 체크박스를 클릭하고, 원하는 값을 채워넣습니다. ROS Bridge 강의노트를 작성하고 있는 2023년 지금도 ROS 1으로 개발된 시스템에 종속성을 가진 기업들과 프로젝트들이 많습니다. ROS 1과 ROS 2를 같이 사용할 수는 없을까요? ros1 bridge를 실습해봅시다.\n일전, ROS 1에서 사용하던 smb gazebo를 오랜만에 실행시켜봅시다. roslaunch smb_gazebo smb_gazebo.launch ros1 bridge를 통해 ROS 2 시스템에서 로봇을 제어해보겠습니다. 새로운 터미널을 열고, 초기 옵션 선택 시 3번을 선택하면 ros1 bridge가 실행됩니다. (이 동작은 사실 dynamic_bridge를 실행시키는 것입니다.) sudo apt install ros-foxy-ros1-bridge -y # Terminal 1 - ros bridge ros2 run ros1_bridge dynamic_bridge # Terminal 2 - ros2 foxy ros2 run teleop_twist_keyboard teleop_twist_keyboard ROS 2로 설정된 터미널에서 ROS 1으로 구동되고 있는 로봇을 조종할 수 있습니다. ros bridge가 있으니 ROS 2 개발을 굳이 하지 않아도 된다고 생각할 수 있습니다. 하지만 보안, 지연과 같은 ROS 1의 고질적인 문제들은 여전히 남아있게 되므로 프로젝트를 시작하는 단계라면, ROS 2로 모든 개발을 진행하시길 추천드립니다. image from : swri.org 참고로, /opt/ros/\u0026lt;ros-version\u0026gt;/setup.bash는 ROS 시스템을 사용하기 위해서 필요한 설정이 담긴 파일입니다. 혹여나 galactic, humble과 같이 최신 버전을 사용하고 싶을 때 참고하시기 바랍니다.\nROS 1과 ROS 2를 모두 관리하기에는 많은 노력이 필요하고, 원하는 기능이 모두 동작하지 않을 수 있습니다. 이전 버전 legacy가 있는 경우, 잘 판단하여 시스템을 유지/보수합시다.\nMy Gazebo World Topic의 응용으로 Gazebo를 사용하여 나만의 장애물을 만들고, 충돌을 회피하는 코드를 작성해보고자 합니다. 이를 위해 Gazebo의 Building Editor 사용법을 알려드리겠습니다.\ngazebo를 실행시킨 뒤, 상단 Edit 옵션에서 Building Editor를 실행합니다. 상단 모눈종이에 스케치를 통해 건물 벽을 생성할 수 있으며, 하단 view를 통해 실시간으로 업데이트되는 건물을 확인할 수 있습니다. 혹여 실수를 했거나, 보다 정확한 수치를 입력하고 싶은 경우, 모눈종이 위의 검은 선을 더블 클릭하면 사진과 같이 구체적인 설정을 변경할 수 있는 탭이 등장합니다. 수정이 완료되었다면, 왼쪽 탭에서 door, stairs도 사용해보고, Texture도 입혀봅시다. 모든 작업을 마친 뒤, File 탭에서 Save As를 선택하여 완성한 물체를 저장합니다. (저는 wall 이라는 이름으로 저장해보겠습니다.) 저장된 폴더 내부는 다음과 같은 구조를 갖게 됩니다. ├─ wall ├── model.config └── model.sdf model.config : 해당 model의 이름, 작성자 등 기본적인 정보들이 기입됩니다. model.sdf : 실직적인 sdf 형식의 모델이 위치합니다. 작성한 물체를 Gazebo에서 두고두고 사용하는 몇가지 방법들이 있습니다.\nGAZEBO_MODEL_PATH에 추가하기 ⇒ ~/.gazebo/gui.ini 파일 내 model_paths에 building 폴더에 절대 경로를 추가합니다. $ gedit ~/.gazebo/gui.ini [geometry] x=0 y=0 [model_paths] filenames=/home/kimsooyoung/\u0026lt;your-folder-location\u0026gt; launch file에서 GAZEBO_MODEL_PATH 수정하기 ⇒ 대신 이렇게 하면 해당 launch file 사용 시에만 GAZEBO_MODEL_PATH가 반영됩니다. if \u0026#39;GAZEBO_MODEL_PATH\u0026#39; in os.environ: os.environ[\u0026#39;GAZEBO_MODEL_PATH\u0026#39;] += \u0026#34;:\u0026#34; + gazebo_model_path else: os.environ[\u0026#39;GAZEBO_MODEL_PATH\u0026#39;] = gazebo_model_path 이제 Gazebo를 실행시키면, 사진과 같이 Insert 부분에 building이 추가되어있음을 확인 가능합니다. 이를 클릭 후 gazebo 환경으로 커서를 옮기면 원하는 위치에 wall을 위치시킬 수 있습니다. wall이 추가된 world는 별도로 저장해줘야 합니다. File ⇒ Save World As를 클릭하면 완성된 world 파일을 저장합시다. 생성한 world 파일을 launch 파일로 실행해봅시다.\n저장해두었던 Gazebo world 파일을 src_gazebo의 worlds 폴더에 위치시킵니다. launch 파일을 수정하여 새로운 world 파일의 위치를 전달합니다.\ndef generate_launch_description(): ... # gazebo pkg_gazebo_ros = FindPackageShare(package=\u0026#39;gazebo_ros\u0026#39;).find(\u0026#39;gazebo_ros\u0026#39;) pkg_path = os.path.join(get_package_share_directory(\u0026#39;src_gazebo\u0026#39;)) world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;여러분의-world-file.world\u0026#39;) ... # Start Gazebo server start_gazebo_server_cmd = IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(pkg_gazebo_ros, \u0026#39;launch\u0026#39;, \u0026#39;gzserver.launch.py\u0026#39;)), launch_arguments={\u0026#39;world\u0026#39;: world_path}.items() ) package를 빌드하고, gazebo를 다시 실행해봅시다. colcon build --packages-select src_gazebo source install/local_setup.bash ros2 launch src_gazebo empty_world.launch.py 제작한 world와 로봇이 함께 등장하는 것을 확인할 수 있습니다. 최대한 여러분들만의 장애물을 만들어보시고, 혹시나 이 과정에서 도저히 모르겠는 오류가 발생했거나, 시간이 없는 경우, 우선 제가 제작한 world와 launch file을 사용하도록 합니다. ⇒ ros2 launch src_gazebo wall_world.launch.py\nROS 2 Topic 프로그래밍 example1 - cmd_vel publish 준비된 예시를 우선 실행해봅시다. # Terminal 1 ros2 launch src_gazebo empty_world.launch.py # Terminal 2 cd ~/ros2_ws colcon build --packages-select py_topic_tutorial source install/local_setup.bash ros2 run py_topic_tutorial topic_pub_node 로봇이 원을 그리며 움직이기 시작합니다. ROS 1 강의를 완료하였다면 어떻게 구현하였을지 아시겠지요? 코드를 살펴보겠습니다 - 시작으로, 필요한 파이썬 패키지들을 import 합니다. ROS 2에서 파이썬 프로그래밍을 하기 위해서는 rclpy를 import 해야 합니다. 더불어, Twist를 import하는 문법도 눈여겨봅시다. import random from geometry_msgs.msg import Twist import rclpy from rclpy.node import Node 핵심이 되는 TwistPubNode 클래스의 생성자부터 살펴보겠습니다. class TwistPubNode(Node): def __init__(self): super().__init__(\u0026#39;twist_pub_node\u0026#39;) self.get_logger().info( f\u0026#39;TwistPubNode Created at {self.get_clock().now().to_msg().sec}\u0026#39; ) # self.twist_publisher = self.create_publisher(Twist, \u0026#34;twist_topic\u0026#34;, 10) self.twist_publisher = self.create_publisher(Twist, \u0026#39;/cmd_vel\u0026#39;, 10) create_publisher는 topic publisher를 생성하는 함수로 3개의 매개변수를 받으며 각각에 대한 설명은 다음과 같습니다.\nmessage type : Topic 통신에 사용될 msg Type 입니다. topic name : 사용할 Topic 이름을 지정합니다. (이 이름을 잘못 설정하면 존재하지 않는 topic에 Publish하는 오류 상황이 발생하니 주의합니다.) queue_size : 대기열의 크기라고 이해하시면 좋습니다. timer callback에서 publish가 이루어집니다. 생성한 publisher에서 publish 함수를 사용하며 매개변수로 message가 전달됩니다. ... self.create_timer(0.2, self.timer_callback) def timer_callback(self): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; msg = Twist() # Fill in msg with compatible values msg.linear.x = 0.5 msg.angular.z = 1.0 self.twist_publisher.publish(msg) example2 - scan subscription 이번 예시는 라이다 데이터를 다뤄보고자 합니다. 명령어를 실행해봅시다. # Terminal 1 $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ ros2 run py_topic_tutorial topic_sub_node [INFO] [1672494602.141200628] [scan_sub_node]: msg.ranges[0] : inf msg.ranges[30] : inf msg.ranges[60] : 0.7975894212722778 msg.ranges[90] : inf msg.ranges[119] : inf ... 예시를 실행시킨 상황에서 Gazebo 상의 로봇 주변으로 물체를 등장시켜봅시다.\nscan data의 ranges는 사진과 같은 거리 데이터를 담고 있답니다.\n코드를 살펴봅시다. 이번에는 sensor_msgs/msg/LaserScan이 사용되었습니다. import rclpy from rclpy.node import Node from sensor_msgs.msg import LaserScan ScanSubNode 클래스의 생성자에서는 scan topic의 subscriber가 생성됩니다. class ScanSubNode(Node): def __init__(self): super().__init__(\u0026#39;scan_sub_node\u0026#39;) queue_size = 10 # Queue Size self.pose_subscriber = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, queue_size ) create_subscription은 4개의 매개변수를 받으며 각각에 대한 설명은 다음과 같습니다.\nMessage Type : Topic 통신에 사용될 msg Type 입니다. topic name : 데이터를 Subscribe할 Topic의 이름을 지정합니다. (이 이름을 잘못 설정하면 아무것도 publish하고 있지 않는 topic을 마냥 기다리고 있게 되는 상황이 발생할 것입니다.) subscribe callback : 데이터가 전달될 때마다 실행되는 callback 함수로, 전달된 데이터를 통해 실행할 작업이 이 함수 안에 구현됩니다. queue_size : create_publisher때와 마찬가지로, 대기열의 크기라고 이해하시면 좋습니다. sub_callback의 첫번쨰 매개변수는 항상 topic message data가 됩니다. 해당 message에서 원하는 데이터만 추출한 다음, logger를 통해 콘솔 출력을 진행합니다.\ndef sub_callback(self, msg): \u0026#34;\u0026#34;\u0026#34;Timer will run this function periodically.\u0026#34;\u0026#34;\u0026#34; self.get_logger().info(f\u0026#39; \\ \\nmsg.ranges[0] : {msg.ranges[0]} \\ \\nmsg.ranges[30] : {msg.ranges[30]} \\ \\nmsg.ranges[60] : {msg.ranges[60]} \\ \\nmsg.ranges[90] : {msg.ranges[90]} \\ \\nmsg.ranges[119] : {msg.ranges[119]} \\ \u0026#39;) example3 - parking 이번 예시를 실행하기 전에, empty_world.launch.py를 수정해야 합니다. # gazebo pkg_gazebo_ros = FindPackageShare(package=\u0026#39;gazebo_ros\u0026#39;).find(\u0026#39;gazebo_ros\u0026#39;) pkg_path = os.path.join(get_package_share_directory(\u0026#39;src_gazebo\u0026#39;)) # world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;empty_world.world\u0026#39;) world_path = os.path.join(pkg_path, \u0026#39;worlds\u0026#39;, \u0026#39;wall_world.world\u0026#39;) 물체와 충돌하기 전까지 로봇을 움직이다가 일정 거리 내 벽이 검출되면 자동으로 멈추는 예시입니다. # Terminal 1 $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ ros2 run py_topic_tutorial parking_node ... [INFO] [1672563255.067421128] [parking_node]: Distance from Front Object : 0.6280616521835327 [INFO] [1672563255.173734128] [parking_node]: Distance from Front Object : 0.5546504259109497 [INFO] [1672563255.281276729] [parking_node]: Distance from Front Object : 0.5124648809432983 [INFO] [1672563255.389067729] [parking_node]: ==== Parking Done!!! ==== ... 이 기능을 구현하기 위해서는 Topic Publish와 Subscribe가 모두 필요합니다.\n/cmd_vel topic publish /scan topic subscribe ⇒ 따라서, Node의 생성자에서도 Publisher와 Subscriber를 모두 생성합니다.\nclass ParkingNode(Node): def __init__(self): super().__init__(\u0026#39;parking_node\u0026#39;) queue_size = 10 # Queue Size self.twist_publisher = self.create_publisher(Twist, \u0026#39;cmd_vel\u0026#39;, queue_size) self.scan_subscriber = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, queue_size ) sub_callback에서는 전방 (msg.ranges[60]) 물체와의 거리를 탐지하고, 이 거리가 0.5m 이하가 되면 정지 topic을 publish 합니다. def sub_callback(self, msg): twist_msg = Twist() distance_forward = msg.ranges[60] if distance_forward \u0026gt; 0.5: self.get_logger().info(f\u0026#39;Distance from Front Object : {distance_forward}\u0026#39;) twist_msg.linear.x = 0.5 self.twist_publisher.publish(twist_msg) else: self.get_logger().info(\u0026#39;==== Parking Done!!! ====\\n\u0026#39;) twist_msg.linear.x = 0.0 self.twist_publisher.publish(twist_msg) CV 2 and ROS 2 Topic과 ROS 2 Bag을 사용한 예시를 실행해보고자 합니다.\n이번 실습을 위해 제가 미리 준비한 데이터셋을 제공드리니, 기억하기 쉬운 위치에 다운받아 주세요.\n📁 quadrupped_train.zip\nWindows + WSL2 유저의 경우 explorer.exe 명령어를 통해 파일 탐색기를 열 수 있습니다.\n준비된 예시를 실행해봅시다. # 예제 실행 준비 sudo apt install ros-foxy-rosbag2 cd ~/ros2_ws colcon build --packages-select py_cv_tutorial source install/local_setup.bash # 터미널 1 – 데이터 위치로 이동하여 ros2 bag 실행 cd \u0026lt;데이터를 저장한 위치\u0026gt; ros2 bag play quadrupped_train.bag_0.db3 # 터미널 2 – image_view 실행 ros2 run rqt_image_view rqt_image_view 사진과 같이 기차 선로 모습이 보인다면 성공입니다. 해당 데이터셋은 기차 선로에서 주행하는 4족 보행 로봇으로부터 취득한 것입니다. 기차 선로는 주기적으로 관리가 필요하며, 길고 긴 선로를 로봇이 자동으로 검사해준다면 아주 유용할 것입니다. 이러한 상상을 해보면서 실습에 임해봅시다.\nExample1 - CV Bridge 이미지를 다루기 위한 오픈소스 라이브러리인 OpenCV를 사용해보려 합니다. 준비된 예시와, ros2 bag 파일을 실행하면 cv2.imshow를 통해 연속된 이미지를 확인할 수 있습니다.\n# 터미널 1 $ cd \u0026lt;bag 파일 위치\u0026gt; $ ros2 bag play quadruped_train.bag_0.db3 [INFO] [1667077909.362223100] [rosbag2_storage]: Opened database \u0026#39;quadrupped_train/quadrupped_train.bag_0.db3\u0026#39; for READ_ONLY. # 터미널 2 $ ros2 run py_cv_tutorial img_sub [INFO] [1667077909.613586300] [image_subscriber]: Receiving video frame [INFO] [1667077910.934147000] [image_subscriber]: Receiving video frame ... OpenCV에서는 CV::Mat 이라는 특정 타입을 사용합니다. 이를 ROS 2의 Topic Message로 변환하기 위해서 CV Bridge라는 것을 사용합니다. from cv_bridge import CvBridge # Package to convert between ROS and OpenCV Images import cv2 # OpenCV library class ImageSubscriber(Node): def __init__(self): # Used to convert between ROS and OpenCV images self.br = CvBridge() ... def listener_callback(self, data): ... # Convert ROS Image message to OpenCV image current_frame = self.br.imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) edge_frame = self.hough_transform(current_frame) imgmsg_to_cv2를 통해 CV::Mat으로 변환된 이미지 데이터를 OpenCV의 다양한 기능들과 함께 사용할 수 있습니다. 코드의 imshow 부분을 바꿔서 이미지 처리를 적용해 봅시다. 직선을 검출하는 알고리즘이며, 매개변수의 최적화를 통해 선로를 인지할 수 있습니다. 직선 검출을 위해 사용된 OpenCV 기능들은 아래와 같습니다. 로직을 업그레이드하여 여러분만의 선로 검출 알고리즘을 만들어 보세요!\ncv2.GaussianBlur cv2.fillPoly / cv2.bitwise_and ROI 설정 cv2.HoughLinesP rosbag to img 컴퓨터 비전만으로 완벽한 선로 인식을 구현하기는 너무나 힘듭니다. 딥러닝을 사용해서 이를 극복할 수 있을 것이며, 데이터셋의 제작을 위해 rosbag 데이터에서 이미지를 추출하는 예시를 준비하였습니다.\n$ ros2 run py_cv_tutorial rosbag2_to_timedimg /home/kimsooyoung/djhrd_ws/quadrupped_train/quadrupped_train.bag_0.db3 saved: color_1666796292992515592.png saved: color_1666796293035428479.png saved: color_1666796293079139778.png saved: color_1666796293120768031.png 예제 실행 전 main 함수에서 bag 파일의 위치를 여러분의 것으로 수정해야 합니다. def main(args=None): # Change below roots to your ros2 bag locations ROOT_DIR = \u0026#34;/home/kimsooyoung/djhrd_ws/quadrupped_train\u0026#34; FILENAME = \u0026#34;/quadrupped_train.bag_0.db3\u0026#34; DESCRIPTION = \u0026#34;color_\u0026#34; 예제 실행 후 사진과 같이 기차 생성된 이미지들이 보인다면 성공입니다. "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture6/",
	"title": "Lecture6 - ROS 2 Service and Examples",
	"tags": [],
	"description": "",
	"content": "ROS 2 Service ROS Service의 개념을 다시 복습해봅시다.\nimage from : docs.ros.org Service 개념 정리\nService를 요청하는 주체를 Service Client라고 하며, Service 요청 자체를 Request, 혹은 Call이라고 합니다. Service를 요청받는 주체를 Service Server라고 하며, Service Server는 Request에 대한 응답, 즉 Service Response를 다시 Service Client에게 회답합니다. Request와 Response를 위해 사용되는 데이터 타입은 srv라고 하며 Request와 Response로 나뉩니다. Service의 중요한 특징 한 가지 추가하자면, 하나의 Service Server에 여러 Client가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지 못합니다.\nimage from : docs.ros.org ROS Service 커멘드 라인 지난 topic 예시와 같이 ROS 1에서 ROS 2로 넘어오면서 변경된 커멘드 라인들을 살펴보겠습니다.\nrosservice list ⇒ ros2 service list ros2 service info는 없으며, ros2 service type으로 변경되었습니다. srv는 ros2 interface show로 조회 가능합니다. $ ros2 interface show turtlesim/srv/Spawn float32 x float32 y float32 theta string name # Optional. A unique name will be created and returned if this is empty --- string name 서비스 타입 중간에 보이는 - - - 부분은 request와 response의 구분자라고 생각하시면 됩니다.\nService Example - 📸 KimChi Service 이번에 보여드릴 ROS 2 service 예시는 사진을 찍는 service server입니다.\n예시 실행 - rqt를 통해 service call이 성공하면 현재 시간에 해당하는 파일이름으로 로봇이 바라보는 시야의 카메라 이미지가 PNG 형식으로 저장됩니다. # Terminal 1 - 여러분들만의 world를 사용하시면 더욱 좋습니다. $ ros2 launch src_gazebo empty_world.launch.py # Terminal 2 $ colcon build --packages-select py_service_tutorial $ source install/local_setup.bash $ ros2 run py_service_tutorial take_picture_server [INFO] [turtle_circle_server]: Picture Taking Node Started [INFO] [turtle_circle_server]: KimChi~ [INFO] [turtle_circle_server]: Image saved in 1672569224.png # Terminal 3 - rqt 실행 후 service caller 실행 (plugins =\u0026gt; services =\u0026gt; service caller) $ rqt Service Caller의 사용법과 결과는 다음과 같습니다. 코드를 살펴보기 전에, 이를 어떻게 구현할 수 있을지 같이 생각해봅시다.\n사진 촬영을 포함하는 Service Server 필요 로봇 전방 image data의 Subscriber 필요 ROS의 sensor_msgs/msg/Image를 저장 가능한 포멧으로 변경 필요 따라서, Node의 생성자는 다음과 같이 작성합니다.\nclass PictureNode(Node): def __init__(self): super().__init__(\u0026#39;turtle_circle_server\u0026#39;) self.server = self.create_service( SetBool, \u0026#39;take_picture\u0026#39;, self.take_picture_callback ) self.subscriber = self.create_subscription( Image, \u0026#39;logi_camera_sensor/image_raw\u0026#39;, self.sub_callback, 10 ) self.br = CvBridge() self.is_request = False 이번에 사용하는 srv는 example_interfaces/srv/SetBool이며, Bool Type의 request와 String response를 갖고 있습니다. $ ros2 interface show example_interfaces/srv/SetBool # This is an example of a service to set a boolean value. # This can be used for testing but a semantically meaningful # one should be created to be built upon. bool data # e.g. for hardware enabling / disabling --- bool success # indicate successful run of triggered service string message # informational, e.g. for error messages service call에 대한 callback입니다. is_request를 바꿔주기만 하는데, 이것이 하는 역할이 무엇일지 생각해보세요. def take_picture_callback(self, request, response): if request.data is True: self.get_logger().info(\u0026#39;KimChi~\u0026#39;) self.is_request = True response.success = True response.message = \u0026#34;Successfully image written\u0026#34; return response 정답은 subscription callback에서 찾을 수 있습니다. subscribe된 이미지 데이터는 is_request가 True인 순간에만 사용됩니다. CV Bridge를 통해 ROS topic을 OpenCV 포맷으로 바꿀 수 있으며, imwrite를 통해 이미지를 저장할 수 있습니다. def sub_callback(self, data): if self.is_request: current_frame = self.br.imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) file_name = str(self.get_clock().now().to_msg().sec) + \u0026#39;.png\u0026#39; cv2.imwrite(file_name, current_frame) self.get_logger().info(f\u0026#39;Image saved in {file_name}\u0026#39;) self.is_request = False Gazebo에 다양한 물체를 배치시킨 뒤 사진을 찍어보는 것도 좋은 실습이 될 것입니다. 제가 준비한 dataset을 사용하여 여러분들만의 실습도 해보세요.\n📁 3DGEMS.zip\n제공되는 3DGEMS 폴더를 압축해제한 뒤, ~/.gazebo/models 폴더에 위치시킵니다. 해당 모델들의 출처는 다음과 같습니다. (\u0026ldquo;The Effect of Color Space Selection on Detectability and Discriminability of Colored Objects.\u0026rdquo; arXiv preprint arXiv:1702.05421 (2017).)\nWSL2를 사용하시는 분들께서는 터미널에서 explorer.exe . 를 입력하면 윈도우 파일 탐색기를 실행 가능합니다.\n다시 한 번 Gazebo를 실행시킨 뒤 새로 추가된 모델들을 사용해봅시다. Server Client Example - Spawn Model 이번 예시는 ROS 1강의에서도 살펴본 바 있는, urdf를 사용하여 gazebo 상에 물체를 등장시키는 예시입니다.\n예시 실행 ros2 launch src_gazebo wall_world.launch.py ros2 run py_service_tutorial spawn_model Gazebo에서 일정한 간격을 두고, 하얀색 박스가 등장하게 됩니다. 매번 박스가 등장할 때마다 service call이 이루어지는 것이지요.\nROS 1에서의 예시와 기능은 동일하므로 중요한 코드들만 간단히 분석해봅시다. 사용하는 srv는 gazebo_msgs/srv/SpawnEntity 입니다. from gazebo_msgs.srv import SpawnEntity import rclpy from rclpy.node import Node create_client를 통해 Service Client를 생설할 수 있습니다. class SpawnRobot(Node): def __init__(self): super().__init__(\u0026#39;gazebo_model_spawner\u0026#39;) self.client = self.create_client(SpawnEntity, \u0026#39;spawn_entity\u0026#39;) while not self.client.wait_for_service(timeout_sec=1.0): self.get_logger().error(\u0026#39;service not available, waiting again...\u0026#39;) create_client의 매개변수는 각각 다음과 같습니다.\nService srv type - SpawnEntity Service server 이름 - \u0026lsquo;spawn_entity\u0026rsquo; main문은, 일반적인 node 실행과 다소 차이를 보입니다. Future라는 개념을 사용하여 이벤트 기반 spin을 구현하였습니다.\nfuture = robot_spawn_node.send_req() rclpy.spin_until_future_complete(robot_spawn_node, future) if future.done(): try: response = future.result() except Exception: raise RuntimeError( \u0026#39;exception while calling service: %r\u0026#39; % future.exception() ) else: robot_spawn_node.get_logger().info(\u0026#39;==== Service Call Done ====\u0026#39;) robot_spawn_node.get_logger().info(f\u0026#39;Status_message : {response.status_message}\u0026#39;) finally: robot_spawn_node.get_logger().warn(\u0026#39;==== Shutting down node. ====\u0026#39;) 친구와 명확한 약속을 했다면, 그동안 다른 일을 할 수 있는 것처럼 Future는, 효율적인 비동기 프로그래밍을 위해 사용됩니다.\nimage from : brunch.co\nservice call이 이루어지는 send_req에서 이 Future를 반환하고 있습니다. def send_req(self): ... self.future = self.client.call_async(self.req) return self.future launch file을 보면 gazebo의 실행을 비롯하여 spawn_model node도 함께 실행됩니다. 그래서 gazebo가 등장하자마자 하얀 박스들이 생성되었던 것입니다. spawn_parking_lot = Node( package=\u0026#39;py_service_tutorial\u0026#39;, executable=\u0026#39;spawn_model\u0026#39;, name=\u0026#39;spawn_model\u0026#39;, output=\u0026#39;screen\u0026#39; ) 이 예시는 다음 Action에서도 활용되므로 잘 기억해두시기 바랍니다.\nCustom Interface와 코딩 과제 - Turtle Jail ROS 2에서 custom interface를 만들기 위해서는 C++ Package에서 작업이 이루어져야 합니다. C++ package는 build type ament_cmake를 사용하는 package였습니다.\n$ ros2 pkg create --build-type ament_cmake \u0026lt;package-name\u0026gt; $ ros2 pkg create --build-type ament_cmake custom_interfaces 해당 패키지 내 action, msg, srv 라는 폴더를 만들고 해당 폴더 안에 나만의 인터페이스를 작성합니다. 사용할 수 있는 기본 데이터 형식들은 이 링크를 참고합니다.\n이번에 만들어볼 custom interface는 다음 과제와 연결됩니다. 우선 저를 따라와 주세요.\nsrv라는 폴더를 만들고, TurtleJail.srv라는 파일을 생성하여 아래와 같은 내용을 작성합니다. float32 width float32 height --- bool success 해당 interface를 rclpy, rclcpp에서 사용 가능하도록 해봅시다. ROS 2는 DDS의 IDL(Interface Description Language)를 사용하여 다양한 언어에서 사용 가능한 데이터 타입을 만들 수 있습니다.\nCMakeLists.txt 수정 find_package(rosidl_default_generators REQUIRED) rosidl_generate_interfaces(${PROJECT_NAME} \u0026#34;msg/Num.msg\u0026#34; \u0026#34;srv/AddThreeInts.srv\u0026#34; \u0026#34;srv/TurningControl.srv\u0026#34; \u0026#34;srv/TurtleJail.srv\u0026#34; \u0026#34;action/Fibonacci.action\u0026#34; \u0026#34;action/Maze.action\u0026#34; ) package.xml 수정 \u0026lt;build_depend\u0026gt;rosidl_default_generators\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rosidl_default_runtime\u0026lt;/exec_depend\u0026gt; \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; 패키지 빌드 $ colcon build --packages-select custom_interfaces \u0026amp;\u0026amp; rosfoxy Starting \u0026gt;\u0026gt;\u0026gt; custom_interfaces Finished \u0026lt;\u0026lt;\u0026lt; custom_interfaces [0.62s] Summary: 1 package finished [0.84s] 이제 ROS 2에서 해당 인터페이스를 사용할 수 있습니다 (단, 해당 workspace를 바라보게 해야 합니다.) $ ros2 interface show custom_interfaces/srv/TurtleJail float32 width float32 height --- bool success custom interface의 사용 시 파이썬 패키지에서는 별도 작업 없이 사용 가능하지만 C++ 패키지는 코딩 시 CMakeLists.txt의 수정이 필요합니다. 이는 다소 난이도가 있어 강의에서 살피지는 않고 링크를 남겨두겠습니다.\nhttps://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Custom-ROS2-Interfaces.html#id10 Assignment - Turtle Jail topic과 service에 대해서 모두 살펴본 지금 상황에서 여러분들께 코딩 과제를 제시해보고자 합니다. 이번 코딩 과제에서 구현해야 하는 최종 결과는 다음과 같습니다.\nrqt를 통해 turtle_jail_size service call을 하며, 감옥의 사이즈를 설정합니다.\n거북이는 감옥을 벗어날 수 없으며, 감옥을 벗어나는 순간 원점으로 순간이동합니다.\n터미널에서 실행하는 절차는 다음과 같습니다. # Terminal 1 – turtlesim실행 ros2 run turtlesim turtlesim_node # Terminal 2 - turtle_teleop 실행 ros2 run turtlesim turtle_teleop_key # Terminal 3 - 과제 프로그램 실행 ros2 run py_service_tutorial turtle_jail [INFO] [turtle_jail_node]: === [Service Client : Ready to Call Service Request] === [INFO] [turtle_jail_node]: ==== [Service Server : Ready to receive Service Request] ==== # Terminal 4 - rqt의 service caller 실행 후 /turtle_jail_size에게 service call cd ~/ros2_ws source install/local_setup.bash rqt 이번 예시는 custom interface를 사용하므로 local_setup.bash를 꼭 실행해주세요!\n이 예시에서는 topic과 service를 모두 사용해야 합니다. 지금까지 학습한 내용들을 확인해볼 수 있는 좋은 기회가 될 것입니다.\n힌트1 : turtlesim의 좌표계 힌트 2 : 거북이를 순간이동시키기 위해 /turtle1/teleport_absolute service를 사용하세요. "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture7/",
	"title": "Lecture7 - Useful ROS 2 Example, Navigation2",
	"tags": [],
	"description": "",
	"content": " 코딩을 시작하기 전에 구현해야 하는 기능들과 Topic, Service 기준 input, output을 정리해봅시다.\nPart 1 - 감옥 구현 거북이가 일정 범위를 벗어나게 되면 다시 원위치로 돌아오게 한다.\n거북이의 위치는 /turtle1/pose topic subscribe을 통해 얻을 수 있습니다. 거북이가 일정 위치를 벗어나는 순간, 원위치로 돌아오게 하는 /turtle1/teleport_absolute service call을 해야 합니다. 이를 위한 service client가 필요합니다. Part 2 - 감옥 크기 변경 사용자로부터 감옥의 크기를 변경해달라는 service request가 오면 기존 감옥의 크기를 변경하는 작업이 필요하다.\n/turtle_jail_size service server를 구현해야 합니다. 감옥의 크기가 변경되면 topic 로직에도 반영되어야 하므로 OOP의 형태로 구현이 필요할 듯 합니다. 코드를 구현하기 위해 필요한 topic, service interface들을 조회합시다.\n$ ros2 interface show custom_interfaces/srv/TurtleJail float32 width float32 height --- bool success $ ros2 interface show turtlesim/srv/TeleportAbsolute float32 x float32 y float32 theta --- $ ros2 interface show turtlesim/msg/Pose float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity 모든 필요조건들을 알게 되었습니다. 이제 프로그래밍을 해보겠습니다.\n필요 파이썬 패키지 import import rclpy from rclpy.node import Node from turtlesim.msg import Pose from turtlesim.srv import TeleportAbsolute from custom_interfaces.srv import TurtleJail Service Server, Service Client, Topic Subscriber 생성 # Create Turtle teleport client self.client = self.create_client(TeleportAbsolute, \u0026#39;turtle1/teleport_absolute\u0026#39;) while not self.client.wait_for_service(timeout_sec=1.0): self.get_logger().info(\u0026#39;Service not available, Waiting again...\u0026#39;) self.request_srv = TeleportAbsolute.Request() self.get_logger().info(\u0026#39;=== [Service Client : Ready to Call Service Request] ===\u0026#39;) # Create Subscriber for turtle1/pose queue_size = 10 # Queue Size self.pose_subscriber = self.create_subscription( Pose, \u0026#39;turtle1/pose\u0026#39;, self.sub_callback, queue_size ) # Create Service Server for User Interfaces self.srv = self.create_service( TurtleJail, \u0026#39;turtle_jail_size\u0026#39;, self.turtle_jail_callback ) self.get_logger().info(\u0026#39;==== [Service Server : Ready to receive Service Request] ====\u0026#39;) 클래스 변수 선언 (감옥 사이즈, 벽에 도달하기 전 거북이의 각도) # Preserve its rotation before teleport self.cur_theta = 0.0 # jail size in rectangular form self.jail_width = 6.0 self.jail_height = 6.0 topic subscribe와 service server에 대한 callback이 두 개 필요합니다.\n거북이의 Pose Topic Subscribe Callback def sub_callback(self, msg): \u0026#34;\u0026#34;\u0026#34;Turtle Pose Subscriber Callback\u0026#34;\u0026#34;\u0026#34; if abs(msg.x - 6.0) \u0026gt; self.jail_width or abs(msg.y - 6.0) \u0026gt; self.jail_height: self.cur_theta = msg.theta self.get_logger().warn(\u0026#34;You can\u0026#39;t go out Turtle! :(\u0026#34;) self.send_request() 감옥 사이즈 변경 요청 시 발생하는 Service Server Callback def turtle_jail_callback(self, request, response): \u0026#34;\u0026#34;\u0026#34;Service Server for jail resizing client request\u0026#34;\u0026#34;\u0026#34; self.jail_width = request.width self.jail_height = request.height self.get_logger().info(f\u0026#34;\u0026#34;\u0026#34;Jail Size Update to {self.jail_width}/{self.jail_height}\u0026#34;\u0026#34;\u0026#34;) response.success = True return response 마지막으로, 거북이를 원점으로 이동시켜달라는 service request를 구현합니다. def send_request(self): \u0026#34;\u0026#34;\u0026#34;Service Clinet request fuction\u0026#34;\u0026#34;\u0026#34; self.request_srv.x = 6.0 self.request_srv.y = 6.0 self.request_srv.theta = self.cur_theta self.future = self.client.call_async(self.request_srv) return self.future 바로 코딩을 시작하지 말고, 무엇을 구현해야 하는지 적어보는 것, 조금씩 조금씩 구현한 뒤, 확인하면서 개발하는 것, ROS 뿐만 아니라 앞으로의 프로그래밍에서 반드시 잊지 마시기 바랍니다.\nNavigation 2 이번 시간에는 유용한 ROS 2 프로젝트를 소개하고, 관련된 내용을 함께 살펴보고자 합니다. ROS 2의 자율 주행 메타페키지인 Navigation 2, Nav2 입니다.\nimage from : https://navigation.ros.org\nNav 2는 삼성 리서치 아메리카의 Steven Macenski의 주도 하에 개발되고 있으며, 아래와 같은 자율주행을 위해 필요한 거의 모든 기능들을 집합해둔 프로젝트입니다.\n지도 저장, 전송, 관리 (Map Server) 지도 상에서 로봇의 위치 파악하기 (AMCL) A to B 주행을 위한 경로 생성 (Nav2 Planner) 경로를 따라 로봇을 이동시키기 위한 컨트롤 시스템 (Nav2 Controller) 주행 경로의 최적화 (Nav2 Smoother) Costmap 생성과 센서 데이터 반영 (Nav2 Costmap 2D) Behavior Tree를 통한 복잡한 주행 시나리오 핸들링 (Nav2 Behavior Trees and BT Navigator) 주행 실패를 방지하기 위한 recovery behaviors (Nav2 Recoveries) Waypoints 주행 (Nav2 Waypoint Follower) Nav2 Node들의 모니터링과 관리 (Nav2 Lifecycle Manager) 커스텀 알고리즘 개발을 위한 Plugins (Nav2 Core) 일반 개발자나 기업이 자율주행을 구현하기 위해서는 이렇게 많은 것들이 필요합니다. 하지만, ROS 2를 사용한다면 Nav 2를 통해 많은 시간을 단축할 수 있지요!\n이 강의에서 모든 내용을 다루고 싶지만, 시간적 한계가 있기 때문에 예시를 통해 로봇 자율주행에 대한 개념을 체감해보도록 하겠습니다.\nNav 2 Example 1 - SLAM_ToolBox 처음 가보는 환경을 맞닥뜨리면, 우리는 주변 상황을 탐색하고 내 위치를 파악하려 할 것입니다. 이것을 로보틱스에서는 SLAM - Simultaneous localization and mapping이라고 이야기합니다.\nSLAM Toolbox는 Steven Macenski에 의해 제작된 ROS 2 패키지이며 backend와 frontend SLAM 알고리즘 뿐만 아니라, ROS 2와 호환되는 관리 도구, 최적화까지 담고 있습니다. 예시를 통해 SRC 로봇으로 SLAM을 실습해봅시다. 로봇을 이동시키면서 rviz에 갱신되는 지도를 확인합니다. colcon build --packages-select src_slam colcon build --packages-select src_odometry source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo racecourse.launch.py use_rviz:=false # Terminal 2 ros2 launch src_slam src_slam_gazebo_slam_toolbox.launch.py 지도를 저장하는 두 가지 방법이 있습니다.\nrviz plugin 사용 - RViz상의 공란에 지도를 저장할 위치를 포함한 절대경로를 기입하고 왼쪽 “Save Map” 버튼을 눌러 최종 지도를 추출합니다. 커멘드 라인 사용 - 저장 위치가 존재하는지 확인 후 실행하세요. ros2 run nav2_map_server map_saver_cli -f \u0026lt;map_dir\u0026gt;/\u0026lt;map_name\u0026gt; 저장 결과로 두 가지 파일이 생성되며, 이러한 지도 데이터를 관리해주는 것이 Nav 2의 Map Server 입니다. 지도 이미지 파일 지도 정보를 담은 yaml 파일 Localization 로봇의 현재 위치와 방향을 파악하는 것을 localization이라고 부릅니다.\nNav2의 AMCL 패키지는 주어진 맵을 기반으로 Adaptive Monte Carlo Localization 방식을 사용하여 로봇의 위치를 파악합니다.\nimage from : wikipedia\n이 Adaptive Monte Carlo Localization은 입자(Particle)를 사용하여 로봇의 위치를 파악하는 방식이며, 이 입자들은 실제 로봇처럼 주어진 가중치와 함께 그들만의 좌표와 방향 값을 가지고 있게 됩니다.\n로봇이 주어진 환경에서 이동하여 새 센서 데이터를 제공할 때마다 입자가 다시 샘플링되며, 각 샘플링에서 가중치가 작은 입자는 소멸되고 가중치가 큰 입자는 더 커지면서 생존합니다.\nAMCL 알고리즘을 여러 번 반복하게 되면 입자들의 위치가 수렴하여 로봇 포즈의 근사치를 평가할 수 있고, 결국 이 로봇의 최종 방향과 위치를 추정하게 됩니다.\nNav2 Lifecycle Manager Map Server, AMCL과 같은 Nav2의 stack은 Nav2 Lifecycle Manager에 의해 관리됩니다.\nLifecycle이라는 것은 생성과 실행, 일시정지와 최종 종료와 같이 Node의 상태를 지칭합니다. image from : roscon2019\n기존 ROS 2도 lifecycle을 갖고 있지만, Nav 2는 전용 lifecycle_manager를 사용함으로 다른 node과 별도로 자율주행과 관련된 최적화된 시스템 설계가 가능해졌습니다. image from : navigation2\n하지만, ROS 2의 lifecycle이 아닌 독자적인 방식을 사용하게 됨으로 디버깅 툴 사용이 불가하다는 점이 문제점으로 대두됩니다. 이러한 이유로, nav2 개발 시에는 rqt console의 사용을 권장합니다.\nCostmap 2D 자율주행의 경로를 계산할 시, 일반적으로 구역을 나누고 장애물 여부, 충돌 가능 여부등을 점수화하여 구역별 costmap을 만듭니다.\nNav2에서도 로봇의 크기와 사용자의 정의에 따라 inflation을 적용한 costmap을 생성합니다.\nNav2의 costmap에서 각 셀의 cost는 unknown, free, occupied, inflated로 정의되고, controller, planner, recovery plugin등이 이를 사용하여 안전하고 효율적인 경로를 계산하게 됩니다. 이 costmap에는 두가지 종류가 있는데\nGlobal Costmap은 SLAM을 통해 얻은 정적 지도를 기반으로 생성되며, 벽, 가구와 같이 SLAM 당시 존재했던 장애물들에 대한 costmap입니다. Local Costmap은 로봇 주위 일정 범위에 로봇에 부착된 센서들을 기반으로 생성되며, 동적 장애물을 감지할 수 있습니다. 로봇이 이동함에 따라 매번 갱신되는 데이터입니다. 아래 사진에서 왼쪽은 Global costmap을, 오른쪽은 Local costmap을 보이고 있습니다.\ninflation의 변경에 따른 costmap의 차이는 아래와 같이 rviz 화면에서 확인할 수 있습니다. inflation을 줄이게 되면 경로 상 갈 수 있는 영역이 많아졌지만, 충돌 측면에서는 좀 더 위험해졌다고 말할 수 있습니다. 따라서, 로봇의 크기와 최대 속도, 제동거리를 고려하여 적절한 inflation radius를 설정해야 합니다.\nLocal Path와 Global Path 센서 데이터에서 장애물이 검출되었다면, local planner는 이를 회피하기 위해 기존 global planner와는 다른 별도의 경로를 따르도록 로봇에게 지시할 것입니다.\nNav2에서 물체 회피를 위해 수행되는 동작들은 다음과 같습니다.\nglobal planner가 지도를 기반으로 거시적인 경로를 계산하면 이 경로의 일부가 local planner에게 전달됩니다. local planner는 기본적으로 global Planner의 파편이지만, 현재 주행중인 환경과 센서 데이터를 입력으로 받아, 경로를 최신화합니다. global plan과 local plan은 엄연히 다른 알고리즘이 사용되는 분야입니다.\nimage from : Autonomous Wheeled Mobile Robot Control\nController local Path가 계산되었다면, 이제 로봇이 실제로 해당 경로를 주행할 차례입니다.\n로봇의 최대 선속도, 각속도와 후진 여부 등 매개변수에 따라 경로를 최적화해야 합니다. Nav2에서는 Controller가 이를 담당하고 있습니다.\nController는 그 이름과 같이 주어진 경로를 따르기 위해 로봇에게 실제 제어 신호를 전달하게 되며, 따라서 사용하는 로봇의 모델과 밀접한 관련이 있습니다. (제자리 회전, y축 이동 등)\nimage from : dwa_local_planner\nNav2 Behavior Tree 로봇의 일련의 행동들은 Tree 자료 구조로 표현될 수 있으며, Tree의 Node에 해당하는 작업을 구현해두고 이들을 조합하여 시나리오를 구성할 수 있습니다.\nex) A 위치에 도착한 뒤, 물건을 싣고, 다시 B 위치로 이동하여 새로운 물건을 싣고, 최종적으로 C지점으로 돌아와라. 만약 C 지점에 물건이 가득 차있다면 D 지점으로 이동하여 물건을 최종 이송해라\u0026hellip; image from : wikipedia\nNav2는 **BehaviorTree.CPP**를 사용하여 로봇의 자율주행 시나리오 기능을 제공합니다. Behavior Tree는 Nav2와는 별도의 오픈소스 프로그램인데, 시각화를 포함한 높은 완성도를 갖추고 있어 게임 및 로봇 도메인에서 많이 사용됩니다. https://robohub.org/introduction-to-behavior-trees/\nNav2 Core nav2_core 패키지는 custom 알고리즘을 적용한 플러그인을 구현할 수 있도록 인터페이스를 제공합니다. 연구실이나 기업에서는 자신만의 로직을 Plugin으로 구현해서 Nav2 시스템에 적용할 수 있으며, 이러한 방식으로 구현의 시간을 단축시킬 수 있습니다.\nGlobal Planner – global_planner.hpp Local Planner – local_planner.hpp Recovery behaviors – recovery.hpp Goal checker – goal_checker.hpp Exceptions – exceptions.hpp 여러분만의 plugin을 만들어보고 싶다면, 아래 링크를 참고하세요.\nhttps://navigation.ros.org/plugin_tutorials/index.html Nav2 실행 예시 지루한 이론을 듣느라 고생하셨습니다. 이제 src를 통해 자율 주행 예시를 함께 실행해보겠습니다. colcon build --packages-select src_nav source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo racecourse.launch.py use_rviz:=false # Terminal 2 ros2 launch src_nav bringup_launch.py rqt_graph를 확인해봅시다. 방금 우리가 실행한 launch file을 같이 살펴볼까요?\nLaunchDescription부터 살펴봅시다. 대부분 launch arguement의 선언이고 결국 실행과 관련된 것은 bringup_cmd_group 뿐입니다. # Set environment variables ld.add_action(stdout_linebuf_envvar) # Declare the launch options ld.add_action(declare_namespace_cmd) ld.add_action(declare_use_namespace_cmd) ld.add_action(declare_map_yaml_cmd) ld.add_action(declare_use_sim_time_cmd) ld.add_action(declare_slam_cmd) ld.add_action(declare_params_file_cmd) ld.add_action(declare_autostart_cmd) ld.add_action(declare_bt_xml_cmd) ld.add_action(declare_open_rviz_cmd) # Add the actions to launch all of the navigation nodes ld.add_action(bringup_cmd_group) return ld Launch file의 실행 시 GroupAction을 통해 관련된 실행 프로그램들을 한데 묶을 수 있습니다. 이렇게 하는 이유는, 여러 로봇의 실행을 대비한 것입니다. IncludeLaunchDescription을 통해 4개의 launch file들을 다시 추가하고 있습니다. # Specify the actions bringup_cmd_group = GroupAction([ PushRosNamespace( condition=IfCondition(use_namespace), namespace=namespace), IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;slam_launch.py\u0026#39;)), ... IncludeLaunchDescription( # Run Localization only when we don\u0026#39;t use SLAM PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;localization_launch.py\u0026#39;)), ... IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;navigation_launch.py\u0026#39;)), ... IncludeLaunchDescription( PythonLaunchDescriptionSource(os.path.join(my_launch_dir, \u0026#39;rviz_view_foxy_launch.py\u0026#39;)), ... ]) 각각의 하위 launch file은 개별 실행될 수 있도록 구성되었습니다. nav2_lifecycle_manager가 위치하고 있는 점도 확인 가능하고 node를 전달하는 방법도 알 수 있습니다. Node( package=\u0026#39;nav2_lifecycle_manager\u0026#39;, executable=\u0026#39;lifecycle_manager\u0026#39;, name=\u0026#39;lifecycle_manager_localization\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[{\u0026#39;use_sim_time\u0026#39;: use_sim_time}, {\u0026#39;autostart\u0026#39;: autostart}, {\u0026#39;node_names\u0026#39;: lifecycle_nodes}]) ... lifecycle_nodes = [nav2, related, nodes] Nav2의 최적화를 위해서는 수많은 매개변수들과 씨름해야 합니다. yaml 파일을 통해 관리되며 지금까지 살펴본 내용들이 모두 녹아들어 있습니다. amcl: ros__parameters: bt_navigator: ros__parameters: controller_server: ros__parameters: controller_server_rclcpp_node: ros__parameters: use_sim_time: False local_costmap: local_costmap: global_costmap: global_costmap: map_server: ros__parameters: use_sim_time: False yaml_filename: \u0026#34;turtlebot3_world.yaml\u0026#34; map_saver: ros__parameters: planner_server: ros__parameters: planner_server_rclcpp_node: ros__parameters: use_sim_time: False recoveries_server: ros__parameters: robot_state_publisher: ros__parameters: use_sim_time: False 자율 주행 시 발생하는 상황들에 대처하기 위해 기본적으로 Behavior Tree 예시를 제공합니다. 구체적인 내용보다 Node를 작성하고 시나리오를 구성할 수 있다는 점에 집중합시다.\n"
},
{
	"uri": "/kr/ros2_basic_foxy/lecture8/",
	"title": "Lecture8 - ROS 2 Action and Examples",
	"tags": [],
	"description": "",
	"content": " 지금까지 Topic, Service에 대해 모두 배워보았습니다. 마지막 통신 메커니즘인 Action에 대해서 배워봅시다.\nROS2 Action 개념 Action은 Service와 Topic의 특성을 모두 갖고 있으며, 실제로 가장 늦게 탄생한 통신 메커니즘입니다. 일전 Service의 단점을 상기시켜보면서 Action의 필요성에 대해 체감해봅시다.\nService의 중요한 특징 한 가지 추가하자면, 하나의 Service Server에 여러 Client가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지 못합니다.\nimage from : docs.ros.org Action은 바로 이러한 Service의 단점을 극복하기 위해 탄생한 통신 메커니즘입니다.\nAction의 특징 action client는 action server가 Result를 보내기 전까지 마냥 기다리지 않고, 다른 일을 할 수 있습니다. action client는 Result Response를 받기 전에도 지속적으로 Feedback을 받을 수 있습니다. 따라서, Feedback을 받고 있다가, 뭔가 잘못 돌아가고 있다는 것을 감지한 경우 cancel을 할 수도 있습니다. ⇒ 하지만, 여러 request를 동시에 작업하는 것이나, Feedback 중에 topic subscribe와 같은 작업은 본질적으로 불가합니다. 이에 대한 해결 방법도 후에 살펴보겠습니다.\nimage from : https://docs.ros.org/en/foxy/Tutorials/Understanding-ROS2-Actions.html\n사진과 같이 Action Client와 Server가 주고받는 내용은 크게 5가지가 있습니다.\nClient ⇒ Server, Goal Request (service request와 유사합니다.) server ⇒ client, Goal Response client ⇒ server, Result Request server ⇒ client, Feedback (topic과 유사합니다.) server ⇒ client, Result Response 만약 4번 도중 cancel이 발생하면 Action은 종료됩니다.\n이렇게 Action은 Topic, Service의 특징을 모두 갖고 있으며 Cancel이라는 추가 기능까지 갖추고 있는 복잡한 통신 메커니즘입니다.\nAction 커멘드 라인 툴 turtlesim을 실행시킨 뒤, 실습을 진행해봅시다. ros2 run turtlesim turtlesim_node 실행 중인 action은 다음과 같이 조회 가능합니다. $ ros2 action list /turtle1/rotate_absolute 특정 action의 정보를 조회하기 위해 ros2 action info를 사용합니다. $ ros2 action info /turtle1/rotate_absolute Action: /turtle1/rotate_absolute Action clients: 0 Action servers: 1 /turtlesim Action에서 사용되는 데이터 타입은 action이며 ros2 interface show를 통해 조회 가능합니다. $ ros2 interface show turtlesim/action/RotateAbsolute # The desired heading in radians float32 theta --- # The angular displacement in radians to the starting position float32 delta --- # The remaining rotation in radians float32 remaining 커멘드 라인에서 손쉽게 Action Goal을 보낼 수 있습니다. (feedback option을 제공합니다.) $ ros2 action send_goal \u0026lt;action_name\u0026gt; \u0026lt;action_type\u0026gt; \u0026lt;values\u0026gt; $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \u0026#34;{theta : 0.0}\u0026#34; --feedback 1657646954.088327 [0] ros2: using network interface enp7s0 (udp/166.104.135.89) selected arbitrarily from: enp7s0, docker0 Waiting for an action server to become available... Sending goal: theta: 0.0 Goal accepted with ID: d3ddca85948d4099a13dbeb8183e5ecc Result: delta: -0.7839995622634888 Goal finished with status: SUCCEEDED Action 프로그래밍 Action Client 작성하기 일전 거북이를 회전시키는 Action Server에 매칭되는 Action Client입니다. 거북이가 움직이기 원하는 각도를 입력하면 해당 각도록 회전하기 시작합니다. $ colcon build --packages-select py_action_tutorial $ source install/local_setup.bash $ ros2 run py_action_tutorial turtle_turning_client [INFO] [1672647544.783857088] [turtle_rotate_client]: === Turtle Rotate Action Client Started ==== Enter Target Angle : 3.14 [INFO] [1672647549.097662572] [turtle_rotate_client]: Goal accepted [INFO] [1672647549.193173672] [turtle_rotate_client]: Received feedback: 0.051996707916259766 [WARN] [1672647549.226111271] [turtle_rotate_client]: Action Done !! Result: -0.12800025939941406 Action Client를 생성하기 위해서는 ActionClient 패키지를 추가해야 합니다. import rclpy from rclpy.action import ActionClient from rclpy.node import Node 우리가 사용할 turtlesim/action/RotateAbsolute라는 action은 다음과 같은 구조를 갖습니다. # The desired heading in radians float32 theta --- # The angular displacement in radians to the starting position float32 delta --- # The remaining rotation in radians float32 remaining Action Client는 ActionClient 인스턴스입니다. Service Client와 매우 비슷하다는 것을 알 수 있습니다. # Create Action Client self.action_client = ActionClient(self, RotateAbsolute, \u0026#39;turtle1/rotate_absolute\u0026#39;) action type : Client가 사용할 action 데이터 타입 action name : Action Server 이름 wait_for_server를 통해 Action Server의 존재 여부를 우선 확인합니다. # Wait for server first if self.action_client.wait_for_server(10) is False: self.get_logger().error(\u0026#39;Server Not exists\u0026#39;) Action Client는 callback이 많아 각 함수에 대한 실행 시점을 잘 알아두셔야 합니다. # Send Goal then receive future self._send_goal_future = self.action_client.send_goal_async( goal_msg, feedback_callback=self.feedback_callback ) # Done callback Add self._send_goal_future.add_done_callback(self.goal_response_callback) send_goal : main 함수에서 호출되며, Goal request를 진행합니다. feedback_callback : Server로부터의 Feedback이 들어올 때마다 실행되는 Callback 입니다. goal_response_callback : Goal Accpet와 Reject 여부를 확인합니다. get_result_callback : 최종 result에 대한 Callback으로, Action의 제일 마지막에 실행됩니다. Action은 메커니즘 자체가 어렵기 때문에 일부러 쉬운 예제를 가져왔습니다. 코드의 로직은 간단하며, Action Client API 자체에 집중하며 따라와주세요.\ngoal_response_callback : goal은 그 자체로 Service라고 말할 수 있습니다. 따라서, goal 완료까지 대기한 뒤 get_result_callback을 연동합니다. def goal_response_callback(self, future): goal_handle = future.result() if not goal_handle.accepted: self.get_logger().info(\u0026#39;Goal rejected\u0026#39;) return self.get_logger().info(\u0026#39;Goal accepted\u0026#39;) # Add Result cb self._get_result_future = goal_handle.get_result_async() self._get_result_future.add_done_callback(self.get_result_callback) feedback_callback은 subscriber의 callback과 유사하게 매개변수로 feedback 데이터를 받습니다. get_result_callback은 goal_response_callback과 유사하게, future를 매개변수로 받습니다. 하지만 더이상 추가할 callback은 없고 result를 받으면서 마무리됩니다. def feedback_callback(self, feedback_msg): feedback = feedback_msg.feedback self.get_logger().info(f\u0026#39;Received feedback: {feedback.partial_sequence}\u0026#39;) def get_result_callback(self, future): result = future.result().result self.get_logger().warn(f\u0026#39;Action Done !! Result: {result.sequence}\u0026#39;) rclpy.shutdown() 이번 예시에 구현되어 있지는 않지만, goal_handle로부터 cancel handler를 생성할 수도 있습니다. 아래 코드를 예시에 적용한 다음, cancel도 실습해보세요. # Cancel the goal future = self.goal_handle.cancel_goal_async() future.add_done_callback(self.cancel_done) # Cancel the timer self.timer.cancel() def cancel_done(self, future): cancel_response = future.result() if len(cancel_response.goals_canceling) \u0026gt; 0: self.get_logger().info(\u0026#39;Goal successfully canceled\u0026#39;) else: self.get_logger().info(\u0026#39;Goal failed to cancel\u0026#39;) rclpy.shutdown() Action Server Example - Parking Master image from : 기호일보\n이번에는 재미있는 예시를 준비해 보았습니다. 아래 명령어을 입력해 주세요 cbp custom_interfaces cbp parking_action_server source install/local_setup.bash # Terminal 1 ros2 launch src_gazebo wall_world.launch.py # Terminal 2 ros2 run py_action_tutorial parking_action_server [INFO] [1672654091.689062703] [parking_action_server]: Action Ready... [INFO] [1672654101.355609636] [parking_action_server]: Executing goal... [INFO] [1672654101.356973636] [parking_action_server]: Distance from forward obstacle : 100.0 ... # Terminal 3 ros2 action send_goal /src_parking custom_interfaces/action/Parking \u0026#34;start_flag: true\u0026#34; --feedback Waiting for an action server to become available... Sending goal: start_flag: true Goal accepted with ID: d7bcfec5a6e94bd4a349f4955cc495c8 Feedback: distance: 100.0 Feedback: distance: 1.7898634672164917 ... 벽에 인접하여 흰색 상자들이 주차 공간을 배정해줄 것입니다. rqt_robot_steering으로 로봇을 잘 제어하여 주어진 주차 공간에 알맞게 주차를 해보세요!\nFeedback을 통해 벽과의 거리를 확인할 수 있으며, 이 거리가 0.5m 이내가 되면 주차가 완료됩니다. 이 시점에서 좌우 공간이 얼마가 균형이 맞는지에 따라 다른 Result를 얻게 됩니다.\n올바른 주차 시 ⇒ Success! 잘못된 주차 시 ⇒ Fail Action Server 프로그래밍 프로그래밍을 시작하기 전, 필요한 통신 메커니즘들을 살펴봅시다.\nAction Server : Goal을 받으면, 정면 벽과의 거리를 feedback으로 전달합니다. 최종 Result는 String으로 성공 여부를 알려줍니다. LaserScan Sub : 주변 물체와의 스캔된 거리를 알 수 있습니다. Feedback Callback과 Subscription Callback 두 함수도 구현해야 할 것입니다.\n이번 예시를 위해 custom interface를 만들어 보았습니다. Action 데이터 타입은 세 종류의 데이터로 이루어져 있습니다. #goal definition bool start_flag --- #result definition string message --- #feedback definition float32 distance 이제 코드를 살펴봅시다. Action Server를 사용하기 위해서는 ActionServer 패키지를 import 해야 합니다. import rclpy from rclpy.node import Node from rclpy.action import ActionServer 코드 분석 전 살펴본 바와 같이 두 종류의 핸들러를 생성합니다. class ParkingActionServer(Node): def __init__(self): super().__init__(\u0026#39;parking_action_server\u0026#39;) self.laser_sub = self.create_subscription( LaserScan, \u0026#39;scan\u0026#39;, self.sub_callback, 10 ) self.action_server = ActionServer( self, Parking, \u0026#39;src_parking\u0026#39;, self.execute_callback ) Action Server의 Callback입니다. 첫 인자는 goal handler로 feedback 전송이 이를 통해 이루어집니다. feedback msg에는 정면 물체와의 거리가 담깁니다. def execute_callback(self, goal_handle): self.is_sub = True self.get_logger().info(\u0026#39;Executing goal...\u0026#39;) feedback_msg = Parking.Feedback() while self.f_obs_distance \u0026gt; 0.5: feedback_msg.distance = self.f_obs_distance goal_handle.publish_feedback(feedback_msg) self.get_logger().info( f\u0026#34;Distance from forward obstacle : {self.f_obs_distance}\u0026#34; ) time.sleep(1) while loop를 벗어나게 되면 goal succed를 수행하고, Result를 리턴합니다. 현재의 로직은 좌우 물체와의 거리가 균일할 때 성공으로 판정짓습니다. goal_handle.succeed() result = Parking.Result() lr_diff = abs(self.r_obs_distance - self.l_obs_distance) print(lr_diff) if lr_diff \u0026lt; 0.15: result.message = \u0026#34;[Success!] Oh... Teach me how you did :0\u0026#34; else: result.message = \u0026#34;[Fail] Be careful, Poor Driver! \u0026#34; return result main문에서 특별한 점을 찾아볼 수 있습니다. MultiThreadedExecutor를 사용하고 있는데요. 이것이 하는 역할이 무엇일지 실습을 통해 살펴봅시다. try: parking_action_server = ParkingActionServer() # MultiThreadedExecutor ref # https://url.kr/x4kf2b executor = MultiThreadedExecutor() executor.add_node(parking_action_server) try: executor.spin() except KeyboardInterrupt: parking_action_server.get_logger().info(\u0026#39;Keyboard Interrupt (SIGINT)\u0026#39;) finally: executor.shutdown() parking_action_server.destroy_node() finally: rclpy.shutdown() main 문의 주석을 토글하고, sub_callback에 디버깅 메세지를 심은 다음, 다시 예제를 실행 시켜봅니다. 어떠한 결과를 얻으셨나요? def sub_callback(self, data): if self.is_sub: self.f_obs_distance = data.ranges[60] self.r_obs_distance = data.ranges[30] self.l_obs_distance = data.ranges[90] self.get_logger().info(\u0026#34;sub success\u0026#34;) ... # parking_action_server = ParkingActionServer() # rclpy.spin(parking_action_server) # parking_action_server.destroy_node() # rclpy.shutdown() 현재의 시스템은 두 종류의 callback을 갖고 있습니다. execute_callback이 실행되면서 while loop로 진입하면, 자원을 점유하여 sub_callback이 동작할 수 없는 구조가 됩니다. 이를 해결하기 위해 ROS 2에서는 rclpy단에서 멀티 스레딩을 구현해 두었습니다.\nimage from : docs.ros.org 이후 여러가지 구현을 하다 보면 지금처럼 다중 Subscribe를 해야하는 경우가 반드시 생깁니다. 혹은 하나의 프로세스에서 여러개의 Node를 실행시켜야 하는 경우가 발생합니다. 이때, Node Composition과 MultiThreadedExecutor를 적극 사용해보세요!\n참고자료\nhttps://docs.ros.org/en/foxy/Concepts/About-Executors.html "
},
{
	"uri": "/kr/ros2_basic_foxy/lecture9/",
	"title": "Lecture9 - C++ Programming Again, Outro",
	"tags": [],
	"description": "",
	"content": "C++ Programming Again 실질적으로 C++을 통해 ROS 2 개발이 많이 이루어진다 이야기하였습니다. Topic Publish와 Subscriber의 C++코드들도 turtlesim 예제와 함꼐 간단하게 정리해보았습니다.\nTopic Publish 예제 - Random Movement Turtle 예제 실행 cbp cpp_topic_tutorial source install/local_setup.bash # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_topic_tutorial topic_pub_node ⇒ 거북이가 마구잡이로 움직이기 시작할 것입니다\n로봇을 움직이기 위해서는 geometry_msgs/msg/Twist 형식의 topic message type을 사용해야 함을 배운 바 있습니다. 이를 위해서 다음과 같이, 헤더를 include 하면 됩니다. #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; 단, 파이썬과 달리 c++ 헤더는 snake_case를 취하며, 코드 사용 시 CamelCase를 사용합니다.\nrclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr twist_publisher; ... twist_publisher = this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;turtle1/cmd_vel\u0026#34;, 10); publisher는 create_publisher 함수를 통해 생성할 수 있습니다.\n\u0026lt;\u0026gt; 안에는 message type을 적어주고 첫 번째 매개변수는 생성할 topic의 이름 두 번째 매개변수로 queue size를 전달합니다. geometry_msgs::msg::Twist와 같이 타입이 길기 때문에 using을 사용하여 축약하곤 합니다.\nTopic Subscribe 예제 - Turtle Pose Sub turtlesim 상의 거북이의 위치를 Subscribe 받습니다. # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_topic_tutorial topic_sub_node [INFO] [1666434438.709117200] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 [INFO] [1666434438.725522800] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 [INFO] [1666434438.741218300] [turtlepose_sub_node]: x: 5.544/ y: 5.544/ theta: 0.000/ lin_vel: 0.000, ang_vel: 0.000 ... 로직 자체는 어렵지 않기에 API에 집중하여 분석해보겠습니다. TwistPubNode() : Node(\u0026#34;twist_pub_node\u0026#34;) { twist_publisher = this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;turtle1/cmd_vel\u0026#34;, 10); timer = this-\u0026gt;create_wall_timer( std::chrono::milliseconds(500), std::bind(\u0026amp;TwistPubNode::timer_callback, this) ); } subscriber는 create_subscription 함수를 통해 생성할 수 있습니다.\n\u0026lt;\u0026gt; 안에는 message type을 적어주고 첫 번째 매개변수는 subscribe topic의 이름 두 번째 매개변수로 queue size 세 번째 매개변수로는 std::bind를 통해 callback 함수를 전달합니다. callback의 매개변수가 1개이기에 이를 알려야 하며, std::placeholders::_1이 사용되었습니다.\nsub_callback의 첫번째 매개변수인 데이터는 SharedPtr 타입이 사용된다는 것에 주의하며, 때문에 레퍼런스를 사용할 수 없습니다.\nService Client와 Server의 C++코드들도 분석해봅시다.\nService Client 예제 - Turtle Spawn Turtle Spawn 예제 - 영상과 같이 우리가 내린 명령대로 거북이가 등장한 모습을 볼 수 있습니다. cbp cpp_service_tutorial source install/local_setup.bash # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_service_tutorial turtle_spawn_client \u0026gt; Turtle X position : 5.0 \u0026gt; Turtle Y position : 5.0 \u0026gt; Turtle Angle : 0.0 \u0026gt; Turtle Name : my_turtle [INFO] [1666434554.012857700] [spawn_turtle_node]: Turtle Named : my_turtle Spawned Successfully. create_client는 다음과 같은 정보를 요합니다.\n사용하는 srv 타입 request할 service 이름 wait_for_service를 통해 Service Server의 존재 여부를 체크할 수 있습니다.\n... public: SpawnTurtle() : Node(\u0026#34;spawn_turtle_node\u0026#34;){ spawn_client = this-\u0026gt;create_client\u0026lt;Spawn\u0026gt;(\u0026#34;spawn\u0026#34;); while (!spawn_client-\u0026gt;wait_for_service(1s)) { if (!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(), \u0026#34;Interrupted while waiting for the service. Exiting.\u0026#34;); exit(0); } RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;service not available, waiting again...\u0026#34;); } } send_request를 호출함으로 Service call이 가능합니다. 이때, send_request의 반환값을 살펴보면, 비동기 실행을 하고 있음을 알 수 있습니다. auto send_request(){ get_user_input(\u0026#34;\u0026gt; Turtle X position : \u0026#34;, spawn_request-\u0026gt;x); get_user_input(\u0026#34;\u0026gt; Turtle Y position : \u0026#34;, spawn_request-\u0026gt;y); get_user_input(\u0026#34;\u0026gt; Turtle Angle : \u0026#34;, spawn_request-\u0026gt;theta); get_user_input(\u0026#34;\u0026gt; Turtle Name : \u0026#34;, spawn_request-\u0026gt;name); return spawn_client-\u0026gt;async_send_request(spawn_request); } spin_until_future_complete는 async_send_request의 비동기 promise를 받아 실행 완료까지 대기하게 됩니다. int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;SpawnTurtle\u0026gt;(); auto result = node-\u0026gt;send_request(); // Wait for the result. if (rclcpp::spin_until_future_complete(node, result) == rclcpp::FutureReturnCode::SUCCESS) { RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;Turtle Named : %s Spawned Successfully.\u0026#34;, result.get()-\u0026gt;name.c_str()); } else { RCLCPP_ERROR(node-\u0026gt;get_logger(), \u0026#34;Failed to call service add_two_ints\u0026#34;); } rclcpp::shutdown(); return 0; } promise의 반환 완료값은 enumerator type을 갖고 있으며, 공식 문서를 참고하였습니다. image from : docs.ros2.org\nService Server 예제 - Turtle Turn 거북이가 원을 그리며 돌기 시작하다가, 일정 시간이 지나면 움직임을 멈추게 됩니다. rqt의 Service Caller를 사용하며, turtle_turn service를 사용하시면 됩니다. # Terminal 1 ros2 run turtlesim turtlesim_node # Terminal 2 ros2 run cpp_service_tutorial turtle_circle_server # Terminal 3 [INFO] [1666435009.330619900] [turtle_circle_server]: Turtle Turning Server Started, Waiting for Request... [INFO] [1666435026.497839300] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498143700] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498297800] [turtle_circle_server]: 0.00 Seconds Passed [INFO] [1666435026.498427400] [turtle_circle_server]: 0.00 Seconds Passed ... 전체 코드 중 Service Server를 생성하는 핵심을 위주로 살펴봅시다. class TurtleCircleNode : public rclcpp::Node { private: rclcpp::Service\u0026lt;SetBool\u0026gt;::SharedPtr bool_server; void turtle_circle(){ ... } ... } void server_callback(const std::shared_ptr\u0026lt;SetBool::Request\u0026gt; request, const std::shared_ptr\u0026lt;SetBool::Response\u0026gt; response){ if (request-\u0026gt;data) { turtle_circle(); } response-\u0026gt;success = true; response-\u0026gt;message = \u0026#34;Turtle successfully drawed Circle\u0026#34;; } public: TurtleCircleNode() : Node(\u0026#34;turtle_circle_server\u0026#34;){ bool_server = this-\u0026gt;create_service\u0026lt;SetBool\u0026gt;( \u0026#34;turtle_circle\u0026#34;, std::bind(\u0026amp;TurtleCircleNode::server_callback, this, std::placeholders::_1, std::placeholders::_2) create_service는 다음과 같은 정보를 필요로 합니다.\n사용하는 srv 타입 - SetBool 생성할 service 이름 - turtle_circle request 시 실행될 callback - server_callback service callback은 request와 response 두 데이터를 매개변수로 받습니다. 때문에, std::placeholders::_1, _2가 명시된 것이 보입니다. 더불어, 거북이를 움직이기 위해 Publisher도 하나 생성하였습니다.\n이렇게 C++ 코드까지 살펴보았는데요, Action의 C++ 코드는 이번 강의에서는 넘어가도록 하겠으며, 링크를 남겨두겠습니다.\nhttps://docs.ros.org/en/foxy/Tutorials/Intermediate/Writing-an-Action-Server-Client/Cpp.html\nAbout Real Robot 지금까지 우리의 실습을 책임졌던 src 로봇이 어떻게 만들어졌는지 살펴보면서, 실제 로봇 제품의 개발 과정을 살펴봅시다.\n항상 로봇 시스템을 제작하기 전, 저는 부품의 수급부터 계획합니다.\n메인 PC - 라즈베리파이, 젯슨 나노, 라떼판다, 오드로이드, Mini PC, etc… MCU 보드 - 아두이노, ESP 시리즈, Teensy, Node MCU etc… Actuator - 서보/스텝 모터, BLDC 모터, (엔코더 장착 여부, 전압 고려) … Sensor - Lidar, Camera (Monocular, Stereo, RGB-D, 360도 카메라…), Lidar, Range Sensor, etc… 외관 - 알루미늄, 3D 프린팅, 절곡, 카본 플레이트, CNC 가공… 이러한 이유로 로봇 제작에는 일정 비용과 경험이 요구됩니다. 하지만 모두 피와 살이 되니 아낌없이 투자하시기 바랍니다.\nimage from : 로봇 신문 로봇 개발의 초기부터 너무 모든 것을 고려할 필요는 없습니다. 작은 사이즈의 테스트 베드를 구축하여 기능과 경험을 충분히 쌓은 뒤, 점차 하드웨어를 개선해 나가면서 업그레이드를 진행합니다.\n함께하는 개발은 언제나 즐겁습니다.\n개발을 진행하고 하드웨어를 업그레이드해가면서, CAD 파일도 함께 관리합니다. 비록 SRC는 금속 가공이 들어간 것은 아니라 비교적 간단하지만, 규모 있는 로봇 프로젝트에서는 반드시 거쳐야 하는 과정입니다. CAD 파일로부터 urdf를 추출하고, 움직이는 joint들에는 gazebo controller plugin을, 센서 joint에는 gazebo sensor plugin을 적용하여 시뮬레이션을 제작합니다. 시뮬레이션을 통해 제어기와 Odometry Driver, 자율 주행 로직의 검증이 완료되면, 실제 로봇에 이를 적용합니다. 적용과 검증을 반복하면서 로봇을 계속해서 개선해나갑니다.\n작은 팁을 이야기하자면, 발생하는 모든 기록들을 문서화하는 것을 추천드립니다. 하드웨어를 다루다보면, 방금까지 되던 기능이 갑자기 말썽을 일으켜서 하루를 날리는 날도 있습니다. 항상 모든 것을 기록합시다.\nimage from : 에누리닷컷 강의의 마지막으로, ROS / ROS 2에 대한 프로젝트들, 센서들, 도전해볼 수 있는 것들을 제시해보고자 합니다.\nTutorial \u0026amp; Courses\nawesome-ros2 : https://github.com/fkromer/awesome-ros2 ROS2 Packages on NVIDIA Jetson : https://nvidia-ai-iot.github.io/ros2_jetson/ros2-packages/ Stereo labs : Getting Started with ROS2 and ZED Micro ROS Tutorial : https://micro.ros.org/docs/tutorials/core/overview/ Self-Driving Cars with ROS 2 \u0026amp; Autoware : https://www.youtube.com/playlist?list=PLL57Sz4fhxLpCXgN0lvCF7aHAlRA5FoFr Certification\nGoogle Source of Code : https://summerofcode.withgoogle.com/ Jetson AI Ambassador : Jetson AI Courses and Certification - NVIDIA Developer Open Source Contribution\nNav2 : https://navigation.ros.org/contribute/index.html ROS 2 Control : https://control.ros.org/master/doc/project_ideas.html MoveIt : https://moveit.ros.org/documentation/contributing/ Gazebo : https://gazebosim.org/docs/all/contributing 지금까지 부족한 강의를 함께해주셔서 감사드리며, 재미있는 로봇 개발을 프로젝트를 시작하시거나, 기획하고 계신 분, 커피 한잔 하며 로봇 이야기를 나누고 싶으신 분, 언제나 환영합니다. 김수영 / Kim Soo Young\nTel : 010-8689-0259 Email : tge1375@hanyang.ac.kr / mr.swimmingkim@gmail.com "
},
{
	"uri": "/kr/advanced_contents_ros2/lecture1/",
	"title": "Lecture1 - About DDS",
	"tags": [],
	"description": "",
	"content": "About DDS ROS 1과 대두되는 가장 큰 차이점으로, ROS 2는 DDS를 미들웨어로 기반하여 개편되었습니다. 따라서 DDS에 대한 개요와 기능을 이해하는 것은 ROS 2의 성질을 파악하는 데 많은 도움이 됩니다.\nWhat is DDS? DDS - Data Distribution Service는 OMG에서 정의한 Publish-Subscribe 방식의 실시간 데이터 분배 서비스 표준입니다.\nPub-Sub이라는 용어는 ROS 개발자에게 무척 익숙한 단어이지요? DDS의 기본 통신 개념은 ROS의 Topic과 매우 유사합니다. 이러한 결론을 머리속에 잘 담아두고 계속해서 진행해 보겠습니다.\nOMG(Object Management Group)는 분산 객체 컴퓨팅(Distributed Object Computing) 영역의 표준을 제정하는 국제 비영리 컨소시엄으로 영향력 있는 각종 세계 표준을 정의하고 있습니다.\nimage from : 분산이동컴퓨팅 연구실 OMG DDS는 통신 프로토콜이 아닌 기능적 표준으로, 위 그림과 같이 TCP/UDP 같은 통신 프로토콜 위에서 정의되는 객체입니다.\n그림의 아래에서부터 OMG DDS의 구조를 간단히 살펴보겠습니다.\nRTPS(Real-Time Publish-Subscribe Wire Protocol) Layer RTPS Layer는 네트워크 내, 참여자 정보를 유지하고, 네트워크 참여자에 대한 정보를 기반으로 자동 검색을 해주며, (같은 네트워크를 사용하는 ROS 2 시스템은 서로 통신이 가능합니다.) 더불어, 참여자의 동적 추가와 이탈에 대응하는 기능을 합니다.\nRTPS는 OMG에 의해 표준화된, 데이터 분산 시스템을 위한 프로토콜로써 Pub-Sub 구조의 통신 모델을 지원합니다. UDP와 같이 신뢰성 없는 계층 위에서도 동작 가능하도록 설계되었으며, 4가지 모듈로 구성되어 있습니다.\nStructure Module : 데이터 교환 시, 통신에 참여하게 되는 개체들에 대해 정의합니다. Message Module : Writer와 Reader간 정보 교환을 위해 사용되는 메시지에 대해 정의합니다. Behavior Module : Writer와 Reader간 상태, 시간 조건에 따라 수행되어야 할 메시지 전송 절차에 대해 정의합니다. Discovery Module : 같은 도메인 상에 존재하는 개체에 대한 정보를 탐색하는 기능을 수행합니다. Discovery Module은 다음과 같이 두 가지의 RTPS 프로토콜을 사용합니다. PDP(Participant Discovery Protocol) : 서로 다른 네트워크 상에서의 Participant탐색을 위한 프로토콜 EDP(Endpoint Discovery Protocol) : Writer, Reader와 같이 서로 다른 종단점 간의 탐색 정보 교환에 사용되는 프로토콜 image from : OMG DDS(Data Distrubution Service) 기술 개요 DDS Discovery ROS 2를 사용하는 두 디바이스는 같은 네트워크를 사용하고 있다면 자동으로 서로를 인식할 수 있습니다. 어떻게 이러한 동작이 가능하며, 이를 위한 필요조건은 무엇인지 살펴보겠습니다.\nDiscovery를 위해 필요한 정보들 - DDS 미들웨어 통신을 위해 아래 4가지 정보를 사전에 교환해야 합니다.\nWho : Topic Publish 혹은 Subscribe 대상 Where : DDS 표준에서 생성한 Locator 정보 What : Publish하거나 Subscribe하려는 Topic How : Topic Publisher인지 Subscriber인지에 대한 정보 DDS RTPS도 결국 UDP나 TCP 네트워크 레이어를 사용하며, 이를 위해서 실질적으로 IP와 PORT등의 정보가 필요합니다. 하지만, DDS는 사용자가 주소를 지정하지 않아도 “Topic”만으로 통신이 가능합니다. 이를 가능하게 해주는 것이 Locator이며, 이는 Middle Ware단에서 능동적으로 통신에 필요한 정보를 포함하는 새로운 개념을 별도로 생성하는 것입니다.\nDDS 표준에서는 Discovery를 수행하는 절차를 PDP 와 EDP로 구분하고 있습니다.\nPDP(Participant Discovery Protocol) : 같은 도메인에 존재하는 서로 다른 Participant를 검색하는 절차로, Participant에 포함되어 있는 endpoint 의 정보를 검색합니다. EDP(Endpoint Discovery Protocol) : PDP를 통해 Participant가 서로를 탐지하고 나면, EDP가 수행됩니다. 표준에서는 각 프로토콜이 지원해야할 최소한의 기능을 만족하는 SPDP와 SEDP에 대해 설명하고 있습니다. vendor에 따라 다양한 PDP와 EDP를 지원할 수 있지만, 호환성을 위해 모든 RTPS는 SPDP(Simple Participant Discovery Protocol)와 SEDP(Simple Endpoint Discovery Protocol)를 필수로 지원해야합니다. 서로 다른 vendor를 가진 머신 사이에 통신이 가능한 이유이기도 합니다.\n그림을 통해 SPDP와 SEDP를 활용한 Discovery 절차에 대해 알아봅시다.\n같은 Domain을 사용하는 Participant는 생성 시, Discovery를 수행하는 3쌍의 builtin Writer와 builtin Reader, 그리고 pre-defined topic를 포함하게 됩니다. DDS가 구동되면, Participant는 Multicast로 PDP(Participant Discovery Protocol) 메시지를 주기적으로 전송하기 시작합니다. 각 Participant의 builtinParticipantWriter와 builtinPariticpantReader 사이 SPDP 교환이 이루어집니다. 전달되는 정보에는 Participant에 포함된 builtinPublicationWriter와 builtinPublicationReader의 Locator 정보가 담겨 있습니다. SPDP 교환 이후, 상대방 Participant의 정보를 통해 양측 Participant들은 서로 연결됩니다. 이후, Topic 수행을 위해 각 Participant에 Endpoint에 해당하는 Publisher와 Datawriter가 하나씩 생성됩니다. SPDP에서 교환했던 Locator정보를 바탕으로 builtinPublicationWriter는 builtiinPublicationReader에게, builtinSubscriptionWriter는 SubscriptionReader에게 Unicast를 통해 정보를 전달합니다.(SEDP를 교환하는 것입니다.) 전달되는 정보에는 topic, data type, Qos등의 정보가 포함되어 있습니다. SEDP의 결과로 Participant에 포함된 Endpoint들이 연결되고, 연결된 두 Endpoint는 동일 Topic으로 통신을 시작합니다. Discovery 과정을 한번에 정리한 그림입니다. 다시 한 번 의미를 이해하면서 과정을 복기해봅시다.\nDCPS(Data-Centric Publish-Subscribe) Layer DCPS Layer는 RTPS Layer와 Application 사이의 인터페이스 역할을 합니다. 이후 다뤄지는 Participant, Domain, Topic 등을 정의하고, Publish-Subscribe를 수행합니다. 더불어, DDS의 중요한 기능 중 하나인 QoS(Quality of Service)도 담당하고 있습니다.\n구현 측면에서, DCPS는 Data read/write API를 제공함으로 응용 프로그램들 사이 데이터를 교환할 상대에 대한 인지 없이 원하는 데이터의 송수신이 가능하게 합니다.\nimage from : OMG DDS(Data Distrubution Service) 기술 개요 DataWriter / DataReader DataWriter는 송신자, DataReader는 수신자의 역할을 합니다. DataWriter는 Sample(실제 데이터)을 생성하고 전송하는 역할을 하며, DataReader는 Sample을 수신하는 기능을 합니다. 단일 DataWriter와 DataReader는 단일 Topic만을 보유할 수 있습니다.\nPublisher 데이터 Publish를 담당하는 객체로, 하나의 Publisher는 다수의 DataWriter를 가질 수 있습니다. 때문에, 각 Publisher들은 여러 Topic 데이터를 Publish 할 수 있습니다. Publish하고자 하는 데이터 객체의 값이 Publisher에게 전해지면 Publisher는 자신에게 설정된 QoS값에 따라 연관된 Subscriber에게 전달합니다.\nSubscriber 데이터 Subscribe를 담당하는 객체로, Publisher와 유사하게 다수의 DataReader를 가질 수 있으며 여러 Topic 데이터를 수신할 수 있습니다. Subscriber가 데이터를 수신한 이후, 응용 프로그램은 DataReader를 통해 실제 데이터로 접근하는 방식입니다.\nDDS Pub-Sub의 기본 구성 요소 image from : MDS 테크 Topic\nTopic은 Publish-Subscribe의 관계를 정의하는 Key입니다. topic은 데이터 타입과 해당 데이터의 QoS에 대한 정보를 담고 있습니다. QoS를 Topic 데이터에 추가하고, Topic과 연관된 DataWriter, Datawriter에 연관된 QoS를 설정하는 식으로 제어됩니다. (Subscriber 측도 동일합니다.)\nTopic의 이름은 Domain 내에서 유일해야 합니다.\nParticipant\nParticipant는 DDS Publisher와 Subscriber를 담게 되는 객체입니다. ROS 2의 Node안에 다수의 Publisher와 Subscriber와 공존할 수 있는 것처럼, Participant도 다수의 DataWriter와 DataReader를 가질 수 있습니다.\nDomain\nDomain은 Participant들이 활동하는 영역으로, 같은 Domain을 갖는 Participant내에서만 정보전달을 할 수 있습니다. ROS 2 터미널의 실행 시 ROS_DOMAIN_ID라는 콘솔 출력이 나왔던 것을 기억하시나요?\n*************** Startup Menu for ROS *************** * Usage: To set ROS env to be auto-loaded, please * * assign ros_option in ros_menu/config.yaml * ****************************************************** 0) Do nothing 1) ROS 1 noetic 2) ROS 2 foxy 3) ROS2/ROS1_bridge Please choose an option: 2 ------------------------------------------------------ * ROS_DOMAIN_ID = 30 ------------------------------------------------------ 이렇게 DDS의 통신 구조에 대해서 알아보았습니다. 위 구조에서 실제 사용자는 Topic, Publisher, Subscriber만 구현하면 되며, DataWriter, DataReader와 RTPS, DCPS는 DDS가 알아서 처리하게 됩니다. 이러한 DDS의 장점에 기반하여 ROS 2 시스템이 올라가게 되는 것이지요.\nDDS QoS TCPROS/UDPROS라는 자체 프로토콜을 사용했던 기존 ROS 1과는 달리, ROS 2에서는 QoS 옵션을 통해 원하는 기능을 선택적으로 사용할 수 있습니다. 이는 DDS의 QoS를 도입하였기 때문으로, Publisher, Subscriber를 선언할 때, QoS를 매개변수형태로 지정하는 방식이 사용됩니다.\n상황에 따라 데이터의 신뢰성이 중요할 수도 있고, 버퍼의 크기를 크게 하여 Topic의 안정성을 높여야 할 수도 있습니다. 이러한 통신의 품질을 옵션화하기 위해서, DDS에서는 아래와 같은 22가지의 QoS를 정의하고 있습니다.\n각각의 QoS 옵션은 연관된 조합으로 Topic, DataWriter, DataReader, Publisher, Subscriber, Domain, Participant에 적용되며, 본 세션에서는 주로 사용되는 QoS를 위주로 살펴보고자 합니다.\nRELIABILITY: 데이터 통신의 신뢰성 레벨(재전송 여부)을 결정하며 두 가지 속성을 설정 할 수 있습니다. RELIABLE : DataWriter History에 있는 모든 샘플들이 DataReader에 전달되는 것을 보장합니다. BEST_EFFORT : 통신 시 손실된 데이터 샘플을 재전송 하지 않고, 전달된 데이터의 순서는 유지 합니다. 알파벳은 다음과 같은 의미를 갖습니다. T : TOPIC, DR : DataReader, DW : DataWriter, P : Publisher, S : Subscriber\nRxO는 Requested/Offered의 약자로 QoS가 적용되는 대상을 Publisher(발간/송신) 측과 Subscriber(구독/수신) 측으로 구분해서 서로의 상관관계를 표현하는 방법입니다.\n‘YES’ : Publisher 측과 Subscriber 측 모두 QoS가 적용되어야 하고, 설정된 QoS 값이 호환되어야 한다. ‘NO’ : Publisher 측과 Subscriber 측 모두 QoS 가 적용되어야 하지만, 설정된 QoS 값은 서로 독립적이다. ‘N/A’ : Publisher 측과 Subscriber 측 중 한 측에만 적용되어야 한다. Changeable이 ‘YES’ 일 경우에는, 동작하면서도 QoS 의 값이 변경될 수 있지만, ‘NO’일 경우에는 처음 생성된 이후에는 변경할 수 없습니다.\nHISTORY : 데이터의 재전송을 위해 HistoryCache내 데이터 보관 방법을 결정하며 두 가지 속성을 설정 할 수 있습니다. KEEP_LAST : Depth(History Cache안에 유지하고 있을 데이터 개수) 크기 만큼 최신 데이터를 유지 합니다. KEEP_ALL : DataReader에게 인스턴스의 모든 값들을 유지하고 전송 합니다. DURABILITY : 나중에 참여한 DataReader에게 이전 데이터를 전송할지 여부를 결정 하며 네 가지 속성을 설정 할 수 있습니다. VOLATILE : 연결이 설정 된 이후의 데이터만 제공 합니다. TRANSIENT LOCAL : DataWriter 생명주기와 일치 일치합니다. TRANSIENT : DataReader에 과거 데이터를 제공 합니다. PERSISTENT : Permanent-Storage에 과거 데이터를 저장하며, 데이터의 유효성은 System 보다 오래 지속 됩니다. OWNERSHIP : 다수의 DataWriter가 동일한 인스턴스를 갱신하게 허용할지를 결정합니다. SHARED : 다수의 DataWriter들이 동일한 데이터 인스턴스 업데이트가 가능합니다. EXCLUSIVE : 데이터 객체의 각 인스턴스는 하나의 DataWriter에 의해서만 수정 가능합니다. PARTITION : Domain 내부에서 Node들을 분리하는 방법을 결정 합니다. (Domain 내에서 별도의 논리적인 통신 채널 형성) - Partition Name이 같은 DataWriter/DataReader간 데이터 배포 가 가능합니다. Partition과 Domain의 차이 - 다른 Domain들에 속하는 개체들은 완전히 서로 독립 된 상태입니다. Entity는 다수의 Partition에 있을 수 있지만 하나의 Domain에만 속할 수 있습니다.\nDEADLINE : 데이터 샘플 사이의 최대 도착 시간을 정의할 수 있습니다. DataWriter는 DEADLINE(period:Duration_t)이 설정된 시간 안에 적어도 한번 이상의 데이터를 전송합니다. DataReader는 DEADLINE(period:Duration_t) 시간 안에 DataWriter로부터 데이터를 받지 못하면 DDS로부터 위반 통보를 받습니다. TIME_BASED_FILTER : DataReader 가 데이터를 필터링 하는 시간을 결정 합니다. Minimum_separation: Duation_t 값을 설정하여 DataReader는 이 값 이내에 수신한 데이터는 삭제 합니다. ROS 2에서는 자주 사용되는 QoS 조합을 묶어 RMW QoS Profile이라는 이름으로 제공하고 있습니다. 지금까지 우리가 queue_size만을 전달하고 있었지만, 사실은 아래 사진의 Default에서 Depth만 바꿔주고 있었던 것입니다.\nimage from : 오로카 ros2에서 QoS 설정하는 방법은 매우 간단합니다. Publisher, Subscriber 클래스를 생성하면서 QoS 옵션을 매개변수로 전달하면 됩니다.\npython example - RMW QoS Profile 사용 시 from rclpy.qos import qos_profile_sensor_data self.string_publisher = self.create_publisher(String, \u0026#39;qos_test_topic\u0026#39;, qos_profile_sensor_data) python example - 직접 Profile 설정 시 from rclpy.qos import QoSDurabilityPolicy from rclpy.qos import QoSHistoryPolicy from rclpy.qos import QoSProfile from rclpy.qos import QoSReliabilityPolicy my_profile = QoSProfile( reliability=QoSReliabilityPolicy.BEST_EFFORT, history=QoSHistoryPolicy.KEEP_LAST, depth=10, durability=QoSDurabilityPolicy.VOLATILE ) self.string_publisher = self.create_publisher(String, \u0026#39;qos_test_topic\u0026#39;, my_profile) =\u0026gt; 참고 링크 : rclpy/qos.py\ntopic 통신이 이루어지고 있는 상황에서, QoS 옵션을 보고 싶다면 Topic 커멘드에 verbose 옵션을 추가하면 됩니다. # Terminal 1 - publisher $ ros2 run py_topic_tutorial qos_example_publisher # Terminal 2 - subscriber $ ros2 run py_topic_tutorial qos_example_subscriber # Terminal 3 - topic info $ ros2 topic info /qos_test_topic --verbose Type: std_msgs/msg/String Publisher count: 1 Node name: twist_pub_node Node namespace: / Topic type: std_msgs/msg/String Endpoint type: PUBLISHER GID: 60.77.10.01.f3.67.78.3d.6b.0c.cc.7b.00.00.14.03.00.00.00.00.00.00.00.00 QoS profile: Reliability: RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT Durability: RMW_QOS_POLICY_DURABILITY_VOLATILE Lifespan: 9223372036854775807 nanoseconds Deadline: 9223372036854775807 nanoseconds Liveliness: RMW_QOS_POLICY_LIVELINESS_AUTOMATIC Liveliness lease duration: 9223372036854775807 nanoseconds Subscription count: 1 Node name: string_sub_node Node namespace: / Topic type: std_msgs/msg/String Endpoint type: SUBSCRIPTION GID: d2.03.10.01.d5.6b.69.e0.be.3f.b5.a2.00.00.14.04.00.00.00.00.00.00.00.00 QoS profile: Reliability: RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT Durability: RMW_QOS_POLICY_DURABILITY_VOLATILE Lifespan: 9223372036854775807 nanoseconds Deadline: 9223372036854775807 nanoseconds Liveliness: RMW_QOS_POLICY_LIVELINESS_AUTOMATIC Liveliness lease duration: 9223372036854775807 nanoseconds DDS QoS는 RxO - requested by offered 특성을 갖고 있어 서로 양립할 수 없는 조합이 존재합니다. 예를 들어, Publish의 Reliability가 BEST_EFFORT일때, Subscriber의 Reliability가 RELIABLE라면, Topic 통신이 발생할 수 없습니다.\n코드를 수정하여 직접 실습해봅시다. qos_example_publisher.py qos_example_subscriber.py my_profile = QoSProfile( reliability=QoSReliabilityPolicy.BEST_EFFORT, history=QoSHistoryPolicy.KEEP_LAST, depth=10, durability=QoSDurabilityPolicy.VOLATILE ) ... self.string_publisher = self.create_publisher(String, \u0026#39;qos_test_topic\u0026#39;, qos_profile_sensor_data) my_profile = QoSProfile( reliability=QoSReliabilityPolicy.RELIABLE, history=QoSHistoryPolicy.KEEP_LAST, depth=10, durability=QoSDurabilityPolicy.VOLATILE ) ... self.pose_subscriber = self.create_subscription( String, \u0026#39;qos_test_topic\u0026#39;, self.sub_callback, my_profile ) 코드 변경 후 실행 - Warning과 함께 Subscriber가 동작하지 않음을 알 수 있습니다. $ ros2 run py_topic_tutorial qos_example_publisher [WARN] [1673945160.449603592] [twist_pub_node]: New subscription discovered on this topic, requesting incompatible QoS. No messages will be sent to it. Last incompatible policy: RELIABILITY_QOS_POLICY $ ros2 run py_topic_tutorial qos_example_subscriber [WARN] [1673945160.455319911] [string_sub_node]: New publisher discovered on this topic, offering incompatible QoS. No messages will be received from it. Last incompatible policy: RELIABILITY_QOS_POLICY QoS를 통해 원하는 도메인에서의 성능을 끌어올리고 안정성을 갖춘 시스템을 구축합시다.\n⇒ 다음 페이지에서 계속됩니다.\n"
},
{
	"uri": "/kr/advanced_contents_ros2/lecture2/",
	"title": "Lecture11 - About DDS (2)",
	"tags": [],
	"description": "",
	"content": "DDS의 IDL DDS에서는 특정 언어에 의존적이지 않는 데이터 통신을 위해 IDL을 사용합니다.\nIDL - Interface Description Language 또는 Interface Definition Language는 어느 한 언어에 국한되지 않는 언어중립적인 방법으로 인터페이스를 표현함으로써, 같은 언어를 사용하지 않는 컴포넌트 사이의 통신을 가능하게 합니다.\nOMG의 Interface Definition Language Version 3.5에 따른 사용 가능한 키워드들은 아래와 같습니다. image from : MDS 테크 ROS 2에서는 interface라는 이름으로 topic message, service srv, action action이 사용되었지요. 이들이 모두 IDL 타입을 갖기 때문에 rclpy, rclcpp, rcljava 모두에서 사용할 수 있는 것입니다.\ncustom interface를 빌드하게 되면, 해당 패키지 내부에 생성된 IDL들을 확인할 수 있습니다. build 폴더 내부 패키지 폴더에 진입하면 사진과 같이 다양한 언어를 지원하기 위한 설정 파일들이 위치하는 것을 확인 가능합니다.\nrosidl_generator_py__arguments.json { \u0026#34;package_name\u0026#34;: \u0026#34;custom_interfaces\u0026#34;, \u0026#34;output_dir\u0026#34;: \u0026#34;/home/kimsooyoung/ros2_ws/build/custom_interfaces/rosidl_generator_py/custom_interfaces\u0026#34;, \u0026#34;template_dir\u0026#34;: \u0026#34;/opt/ros/foxy/share/rosidl_generator_py/cmake/../resource\u0026#34;, \u0026#34;idl_tuples\u0026#34;: [ \u0026#34;/home/kimsooyoung/ros2_ws/build/custom_interfaces/rosidl_adapter/custom_interfaces:action/Parking.idl\u0026#34;, \u0026#34;/home/kimsooyoung/ros2_ws/build/custom_interfaces/rosidl_adapter/custom_interfaces:srv/CircleTurtle.idl\u0026#34;, \u0026#34;/home/kimsooyoung/ros2_ws/build/custom_interfaces/rosidl_adapter/custom_interfaces:srv/TurtleJail.idl\u0026#34; ], \u0026#34;ros_interface_dependencies\u0026#34;: [ \u0026#34;action_msgs:/opt/ros/foxy/share/action_msgs/msg/GoalInfo.idl\u0026#34;, \u0026#34;action_msgs:/opt/ros/foxy/share/action_msgs/msg/GoalStatus.idl\u0026#34;, \u0026#34;action_msgs:/opt/ros/foxy/share/action_msgs/msg/GoalStatusArray.idl\u0026#34;, \u0026#34;action_msgs:/opt/ros/foxy/share/action_msgs/srv/CancelGoal.idl\u0026#34;, \u0026#34;builtin_interfaces:/opt/ros/foxy/share/builtin_interfaces/msg/Duration.idl\u0026#34;, \u0026#34;builtin_interfaces:/opt/ros/foxy/share/builtin_interfaces/msg/Time.idl\u0026#34;, \u0026#34;unique_identifier_msgs:/opt/ros/foxy/share/unique_identifier_msgs/msg/UUID.idl\u0026#34; ], ... 생성된 IDL 파일 내부를 함께 살펴봅시다. custom_interfaces ⇒ rosidl_adapter ⇒ custom_interfaces ⇒ action 폴더 내부에 위치한 Parking.idl은 아래와 같은 IDL 형태를 띄고 있습니다.\nParking.idl // generated from rosidl_adapter/resource/action.idl.em // with input from custom_interfaces/action/Parking.action // generated code does not contain a copyright notice module custom_interfaces { module action { @verbatim (language=\u0026#34;comment\u0026#34;, text= \u0026#34;goal definition\u0026#34;) struct Parking_Goal { boolean start_flag; }; struct Parking_Result { @verbatim (language=\u0026#34;comment\u0026#34;, text= \u0026#34;result definition\u0026#34;) string message; }; struct Parking_Feedback { @verbatim (language=\u0026#34;comment\u0026#34;, text= \u0026#34;feedback definition\u0026#34;) float distance; }; }; }; DDS RTPS 패킷 확인해보기 (wireshark) DDS RTPS의 well-know UDP/IP\ndiscovery과정에서 participant는 미리 정의된 rule에 따라 address와 port를 사용합니다. SPDP에서는 multicast의 address로 239.255.0.1 을 사용하고 아래와 같은 port 설정 rule을 따릅니다.\n=\u0026gt; 따라서, wireshark 실행 시 destination option을 239.255.0.1로 설정합니다.\nip.dst == 239.255.0.1 Publisher와 Subscriber는 서로의 Participant와 Endpoint를 찾고, 주기적으로 HEARBEAT와 ACKNACK를 주고받습니다. 이번에는 ROS 2 Publisher와 Subscriber를 실행시켜 보고 이들 사이 데이터를 주고받는 과정에서 RTPS 프로토콜이 어떻게 동작하는지, 패킷의 분석을 진행해보겠습니다.\n터미널을 실행하여 topic publisher를 실행합니다. $ ros2 run examples_rclcpp_minimal_publisher publisher_member_function [INFO] [1673789194.561595897] [minimal_publisher]: Publishing: \u0026#39;Hello, world! 0\u0026#39; [INFO] [1673789195.061600207] [minimal_publisher]: Publishing: \u0026#39;Hello, world! 1\u0026#39; [INFO] [1673789195.561601140] [minimal_publisher]: Publishing: \u0026#39;Hello, world! 2\u0026#39; [INFO] [1673789196.061605037] [minimal_publisher]: Publishing: \u0026#39;Hello, world! 3\u0026#39; [INFO] [1673789196.561602313] [minimal_publisher]: Publishing: \u0026#39;Hello, world! 4\u0026#39; ... publisher node가 일정 시간마다 multicast로 RTPS DATA(p)를 송신하는 모습을 확인할 수 있습니다. Publish하는 DATA(p)에는 DEFAULT_UNITCAST_LOCATOR, DEFAULT_MULTICAST_LOCATOR, METATRAFFIC_UNICAST_LOCATER, METATRAFFIC_MUTICAST_LOCATOR정보 등 particiapnt에 대한 정보가 담겨 있습니다.\n더불어 현재 사용하고 있는 Domain ID는 30번이기 때문에, 14900포트를 Discovery Multicast Port로 사용하게 됩니다.\ntopic sublisher를 실행하고 다시 패킷을 수집합니다. $ ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function [INFO] [1673790688.700183037] [minimal_subscriber]: I heard: \u0026#39;Hello, world! 1199\u0026#39; [INFO] [1673790689.200236939] [minimal_subscriber]: I heard: \u0026#39;Hello, world! 1200\u0026#39; [INFO] [1673790689.700209001] [minimal_subscriber]: I heard: \u0026#39;Hello, world! 1201\u0026#39; [INFO] [1673790690.200257339] [minimal_subscriber]: I heard: \u0026#39;Hello, world! 1202\u0026#39; [INFO] [1673790690.700230772] [minimal_subscriber]: I heard: \u0026#39;Hello, world! 1203\u0026#39; ... 패킷 초반부 publisher node와 subscriber node는 사이의 정보 교환(PDP)을 확인할 수 있습니다. subscribe node의 등록과, reader/writer Entity 사이 PDP가 교환되며, Data(w)는 publisher의 정보, Data(r)은 subscriber의 정보를 담고 있습니다. PDP 이후 EDP는 데이터 타입 등 Topic에 대한 정보, QoS Profile등 많은 정보를 담고 있기 때문에 수차례 패킷 전송이 오고갑니다. topic info verbose option을 사용하여 topic에 대한 정보와 패킷 정보를 비교해봅시다.\n$ ros2 topic info /topic --verbose Type: std_msgs/msg/String Publisher count: 1 Node name: minimal_publisher Node namespace: / Topic type: std_msgs/msg/String Endpoint type: PUBLISHER GID: f9.f7.10.01.2b.c5.e1.c7.cd.59.7c.2a.00.00.15.03.00.00.00.00.00.00.00.00 QoS profile: Reliability: RMW_QOS_POLICY_RELIABILITY_RELIABLE Durability: RMW_QOS_POLICY_DURABILITY_VOLATILE Lifespan: 9223372036854775807 nanoseconds Deadline: 9223372036854775807 nanoseconds Liveliness: RMW_QOS_POLICY_LIVELINESS_AUTOMATIC Liveliness lease duration: 9223372036854775807 nanoseconds ... PDP와 EDP가 모두 끝나면, Publisher는 자신과 매칭 된 Subscriber에게 Topic을 Publish를 진행합니다. 주기적으로 아래 두 종류의 패킷이 반복되는 것을 확인 가능합니다. publisher의 DATA와 HEARTBEAT 패킷 subscriber의 HEARTBEAT 수신 및 ACKNACK 송신 패킷 ROS 2 Domain ID DDS 시간 살펴본 바와 같이 각 DDS Participant들은 특정 Domain에 속하게 됩니다. 기본적으로 ROS 2에서는 Domain ID 0을 사용하고 있으며, 같은 Domain ID를 사용하는 Participant들 사이에서만 Discovery와 통신이 가능합니다.\n이번 시간에는 ROS 2의 Domain ID를 수정해보고, Domain ID를 설정할 시 주의해야 할 점들에 대해서도 알아보겠습니다.\n우선, 예시를 통해 서로 다른 Domain ID를 갖는 Participant들을 실행해봅시다. # Ternimal 1 ros2 topic pub -r 1 /string_topic std_msgs/String \u0026#34;{data: \\\u0026#34;Hello from my 2ND domain\\\u0026#34;}\u0026#34; # Terminal 2 ROS_DOMAIN_ID=1 ros2 topic list # Terminal 3 ros2 topic list 예시 결과에서 알 수 있듯이 통신을 위해서는 같은 Domain ID를 갖는 조건이 필수적입니다. $ ros2 topic list /parameter_events /rosout /string_topic Domain ID는 환경변수를 통해 변경할 수 있습니다. 터미널의 실행 시 Domain ID를 자동 적용하기 위해 ~/.bashrc를 수정하거나 config.yaml을 수정하시면 됩니다. export ROS_DOMAIN_ID=\u0026lt;your_domain_id\u0026gt; or # edit ~/ros_menu/config.yaml Config: menu_enable: true ros_option: menu default_ros_domain_id: 30 Menu: ... ROS 2 foxy: option_num: 2 ROS_version: 2 distro_name: foxy ros2_path: /opt/ros/foxy domain_id: # set if you don\u0026#39;t want to use default domain id cmds: DDS는 Domain ID를 사용하여 Participant들이 사용할 UDP Port를 지정합니다. Port가 계산되는 방법은 아래와 같으며, 링크를 참고합니다. - 추가 링크 ROS 2 공식 문서에서는 Domain ID와 Participant 순서에 따라 사용되는 포트 번호를 계산해주는 계산기를 제공하고 있습니다. 이를 통해 최대 가질 수 있는 Domain ID와 Participant 수를 확인해 보겠습니다. - 공식 문서 링크 Domain ID 설정 시 고려해야 할 요소들은 다음과 같습니다.\n각 OS 별로 침범하면 안되는 포트 영역이 있습니다. (Linux - 32768-60999 / Windows \u0026amp; macOS - 49152-65535) 각 Participant당 2개의 Unicast Port를 사용합니다. 따라서, 하나의 Domain ID에서 사용할 수 있는 최대 Participant의 수는 120개 입니다. (ROS 2는 하나의 프로세스에서 여러 Node를 실행할 수 있기 때문에 Node를 120개까지 사용할 수 있는 것은 아닙니다.) 이러한 이유로 ROS 2 공식 문서에서는 0-101 사이의 Domain ID를 사용하기를 권장하고 있습니다.\nROS RMW와 다양한 DDS 벤더들 DDS 자체는 산업 표준이다보니 다양한 벤더들에서 제공되고 있습니다. ROS 2 설치 시 자동으로 Fast DDS가 사용되지만, 아래 표와 같이 다양한 DDS 벤더들이 존재하고 있습니다.\n이렇게 다양한 DDS 벤더들에 맞추기 위해 ROS 2는 RMW(“ROS MiddleWare interface”)라는 패키지들을 제공합니다. 다른 벤더의 DDS를 사용하게 되면, 이 RMW를 바꿔줘야 하는 것입니다.\nProduct name License RMW implementation Status eProsima Fast DDS Apache 2 rmw_fastrtps_cpp Full support. Default RMW. Packaged with binary releases. Eclipse Cyclone DDS Eclipse Public License v2.0 rmw_cyclonedds_cpp Full support. Packaged with binary releases. RTI Connext commercial, research rmw_connext_cpp Full support. Support included in binaries, but Connext installed separately. GurumNetworks GurumDDS commercial rmw_gurumdds_cpp Community support. Support included in binaries, but GurumDDS installed separately. 오픈소스인 Fast DDS, Cyclone DDS는 무료이지만, 더 좋은 성능을 위해서는 rti와 같은 유료 서비스를 사용하시기 바랍니다.\napt를 통해 손쉽게 rmw를 설치할 수 있습니다. $ sudo apt install ros-foxy-rmw ros-foxy-rmw ros-foxy-rmw-fastrtps-dynamic-cpp ros-foxy-rmw-connext-cpp ros-foxy-rmw-fastrtps-dynamic-cpp-dbgsym ros-foxy-rmw-connext-cpp-dbgsym ros-foxy-rmw-fastrtps-shared-cpp ros-foxy-rmw-connext-shared-cpp ros-foxy-rmw-fastrtps-shared-cpp-dbgsym ros-foxy-rmw-connext-shared-cpp-dbgsym ros-foxy-rmw-gurumdds-cpp ros-foxy-rmw-cyclonedds-cpp ros-foxy-rmw-gurumdds-cpp-dbgsym ros-foxy-rmw-cyclonedds-cpp-dbgsym ros-foxy-rmw-gurumdds-shared-cpp ros-foxy-rmw-dbgsym ros-foxy-rmw-gurumdds-shared-cpp-dbgsym ros-foxy-rmw-dds-common ros-foxy-rmw-implementation ros-foxy-rmw-dds-common-dbgsym ros-foxy-rmw-implementation-cmake ros-foxy-rmw-fastrtps-cpp ros-foxy-rmw-implementation-dbgsym ros-foxy-rmw-fastrtps-cpp-dbgsym ROS 2 시스템 상에서 사용하는 DDS 벤더를 바꾸는 것은 환경변수를 설정하는 것으로 손쉽게 진행할 수 있습니다. (해당 DDS와 RMW가 설치되어 있다는 가정 하에) 더불어, 서로 다른 벤더의 DDS를 사용하고 있더라도 DDS 표준(SPDP와 SEDP)을 따르고 있다면 상호 통신이 가능합니다.\nExample - Fast DDS \u0026lt;\u0026gt; Cyclone DDS 상호간 Topic 통신 $ export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp $ ros2 run demo_nodes_cpp listener [INFO]: I heard: [Hello World: 1] [INFO]: I heard: [Hello World: 2] [INFO]: I heard: [Hello World: 3] $ export RMW_IMPLEMENTATION=rmw_fastrtps_cpp $ ros2 run demo_nodes_cpp talker [INFO]: Publishing: \u0026#39;Hello World: 1\u0026#39; [INFO]: Publishing: \u0026#39;Hello World: 2\u0026#39; [INFO]: Publishing: \u0026#39;Hello World: 3\u0026#39; 예시의 실행에서 지연이 발생함으로 알 수 있듯이, 실제 제품을 제작할 때는 사용하는 RMW를 통일시켜주는 것을 추천합니다.\n강의 개발환경에서 제공하는 설치 튜토리얼을 따라오셨다면 config.yaml 파일을 수정함으로 손쉽게 DDS Vendor를 변경하실 수 있습니다. $ gedit ~/ros_menu/config.yaml ROS 2 foxy: option_num: 2 ROS_version: 2 distro_name: foxy ros2_path: /opt/ros/foxy domain_id: # set if you don\u0026#39;t want to use default domain id cmds: # - source ${HOME}/ros2_ws/install/local_setup.${shell} - source_plugin dds_bashrc 1 # - source_plugin openvino_bashrc 제공되는 기본 DDS Vendor들은 아래와 같습니다.\nNumber DDS Vendor 0 Show Menu 1 Eclipse Cyclone DDS 2 OpenSplice 3 FastRTPS dds_bashrc를 0으로 수정한 다음 새로운 터미널을 실행시키면, 아래와 같이 DDS를 선택하는 옵션이 등장합니다. 0) Do nothing 1) ROS 1 noetic 2) ROS 2 foxy 3) ROS2/ROS1_bridge Please choose an option: 2 ------------------------------------------------------ * ROS_DOMAIN_ID = 0 ------------------------------------------------------ source /home/kimsooyoung/.ros_menu/plugins_bashrc/dds_bashrc 0 **** Choose DDS you want to use **** 1) Eclipse Cyclone DDS 2) OpenSplice CE 3) FastRTPS Please choose an option 1-3: 참고자료\nMDS테크 로봇 운영체제 강좌 community.rti.com docs.ros.org https://github.com/ADLINK-IST/opensplice "
},
{
	"uri": "/kr/ros_basic_noetic/lecture1/",
	"title": "Lecture1 - Introduction to ROS",
	"tags": [],
	"description": "",
	"content": "What is ROS? ROS란, 로봇 소프트웨어 개발에 사용되는 일종의 프레임워크입니다.\n프레임워크라는 말은, ROS 나름대로의 실행 시나리오를 갖고 있다는 뜻입니다.\n사용자인 우리들은, 이 시나리오를 사용하여 로봇을 다루는 우리만의 Application을 만들게 됩니다.\nimage from : wikimedia 그런데 왜 OS라는 이름이 붙게 되었을까요?\n로봇을 실행하기 위해서, 수많은 프로그램들이 실행되며, ROS는 이들 사이의 우선순위와, 프로그램 사이의 데이터 흐름을 책임집니다. 이 작업은 스케쥴링이라고 불리며, 이러한 동작을 수행하는 시스템을 Operating System이라고 부르기 때문에 ROS라는 이름을 갖게 되었습니다.\nimage from : tutorialspoint 로봇을 개발하기 위해서 어떠한 프로그램들이 필요할까요?\n로봇이 수행하는 임무들을 크게 3가지로 분류하면 인지, 판단, 제어의 3가지로 나뉩니다.\n인지란, 센서들을 통한 물체 인지, 자기 자신의 위치와 방향 인지, 상황 인지 등 로봇에게 있어 환경과 상호작용하는 과정에 해당합니다. 판단이란, 앞/뒤로 움직일지, 로봇 팔을 뻗을지와 같이 인지를 기반으로 얻은 데이터를 통해 결정을 내리는 작업들이 해당할 것입니다. 제어는 로봇에서 빼놓을 수 없는 영역으로, 로봇은 실제 세상에서 움직이기 때문에, 얼마나 움직일지, 어느정도의 속도로 힘은 얼마나 강하게 줄지 등 물리적인 임무를 포함합니다. 이렇게 로봇 시스템은 무척 복잡하며, 이뿐만 아니라 회로, 설계, 재료, 에너지 등을 고려해야 하는 완성품 로봇은 현대 공학의 집합 그 자체라고 말할 수 있습니다.\nAbout this lecture 이 강의에서 다루고자 하는 부분을 정확히하자면, 인지도 판단도 제어도 아닌, 시스템입니다.\n로봇의 센서, 구동부, 알고리즘이 모두 준비되어 있는 상황에서, 이들을 하나의 시스템으로 엮어주는 역할을 하는 것이 바로 ROS입니다.\nimage from : ROS Industrial ROS라는 시스템의 특성상 정해진 코드와 방법으로 소프트웨어를 개발해야 하며, 대부분 ROS를 다루는 강의라고 하면 이를 지칭합니다. 우리가 배우고자 하는 주된 내용도 바로 이 부분이라고 말할 수 있습니다.\nROS 개념 ROS 커멘드 다루기 ROS 프로그래밍 - Topic, Service, Action etc… 하지만, 여기서 그치지 않고, 저는 좀 더 실질적인 로봇 개발을 이야기하고자 합니다.\n리눅스 시스템 Docker 사용하기 로봇 시뮬레이션 라이브 코딩과 에러 디버깅 학교를 다니다 보면 아무리 많은 이론을 공부하고 머릿속에 집어넣어도, 시험을 치고 나면 모두 사라지곤 합니다. 머리 속에 남는 공부를 위해서는 직접 코딩을 해보고, 프로젝트를 진행해봐야 합니다.\n강의를 수강하기 위해 필요한 선수지식 본 강의는 최대한 많은 분들이 끝까지 이해할 수 있도록 설계되었습니다. 따라서, 최대한 쉽고, 프로그래밍 실력이 출중하지 않아도 모두 완강할 수 있게 진행합니다. 하지만 그럼에도, 아래 코드를 이해할 수 있을 정도의 배경지식은 필요합니다. class OOPNode: def __init__(self): self.counter_ = 0 def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; print(hello_du) self.counter_ += 1 def my_first_oop_node(): oop_node = OOPNode() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except Exception as e: print(e) 파이썬 클래스, 메소드와 인스턴스 for, while, if/else 등 기본 문법 강의 코드와 강의 노트 사용법 강의 도중 사용되는 코드들은 Github Repository를 통해 배포되어 있습니다. 코드 강의 중 지속해서 링크를 해드리며, 강의 시작 전 미리 살펴보시면 더욱 좋습니다.\nhttps://github.com/RB2023ROS/du2023-ros1 강의 노트의 주소는 https://rb2023ros.github.io/kr/ 입니다. 코드와 명령어 등 필요한 리소스를 모두 담고 있으므로 복사/붙여넣기를 활용하여 강의 청취 시간을 절약하시기 바랍니다.\n참고로 해당 노트는 hugo를 사용하여 제작된 웹 페이지임을 밝힙니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture2/",
	"title": "Lecture2 - Dev Env Setup",
	"tags": [],
	"description": "",
	"content": "Develpoment Environment Setup 프로젝트 기반의 강의인 만큼, 개발 환경이 구축되지 않으면 앞으로의 실습을 진행할 수 없습니다. 따라서 이번 파트에 많은 시간을 배정하였고, 힘들 수 있지만 끝까지 따라와주시면 감사합니다.\n준비한 환경은 다음과 같습니다.\nUbuntu Linux 설치와 ROS 설정 wsl2를 기반으로 한 Windows 내 ROS 설정 Docker 기반의 ROS 설정 1,2,3 순서로 추천하는 설정입니다. 1번을 진행하시다가 도저히 못하겠으면 2번으로, 그래도 안되면 3번으로 진행해 주시면 됩니다.\nUbuntu Linux 설치와 ROS 설정 Linux라고 함은 사실 OS 자체라기보다 OS의 기초가 되는 코어 소프트웨어에 가깝습니다. 이 코어를 사용하여 여러 버전의 OS가 개발되었으며 이를 Liunx 배포판 이라고 지칭합니다.\nUbuntu Linux는 리눅스 배포판 중 가장 널리 알려진 배포판으로, 영국의 Software회사인 Canonical과 우분투 재단에서 개발, 유지보수 및 배포를 하고 있습니다.\nimage from : omdriod.com 기존의 Windows 노트북을 사용하고 있었다면 듀얼 부팅이라는 것을 통해 Ubuntu + Windows를 모두 사용 가능합니다. 듀얼 부팅에 방법에 대해선 잘 설명한 영상들이 많으므로 링크로 대체하겠습니다.\nHow to Dual Boot Ubuntu 20.04 LTS and Windows 10 How to Dual Boot Ubuntu and Windows 11 Ubuntu 20.04 설치를 확인 하셨다면 터미널을 실행한 뒤 아래의 명령어들을 실행합니다.\nterminator 설치 sudo apt update sudo apt install terminator -y terminator 화면 분할 예시\nctrl + alt + t : 터미널 실행 ctrl + shift + e : 세로 분할 ctrl + shift + o : 가로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 ROS / ROS 2 한줄 설치 cd ~/ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; … Do you want to install ROS automatically? (y/N): y 다음으로, 시뮬레이션 프로그램인 Gazebo를 설치합니다. Gazebo는 ROS를 관리하는 조직인 OSRF에서 공식 지원하는 로봇 시뮬레이터입니다.\nsudo sh -c \u0026#39;echo \u0026#34;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\u0026#34; /etc/apt/sources.list.d/gazebo-stable.list\u0026#39; wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt update sudo apt install gazebo11 libgazebo11-dev -y sudo apt install ros-foxy-gazebo-ros-pkgs -y 그림와 같이 Gazebo의 화면이 어둡고, 그림자가 보이지 않는다면 호환되는 그래픽 드라이버를 설치해야 합니다.\nsudo ubuntu-drivers autoinstall sudo reboot # 장착된 장치 확인 ubuntu-drivers devices 마지막으로, catkin build system을 사용하기 위해 아래 커멘드 명령어를 실행합니다.\nsudo apt update sudo apt install python3-catkin-tools Windows + WSL2 설정 WSL(Windows Subsystem for Linux) 이란, 리눅스용 윈도우 하위 시스템의 약자로, 윈도우 10에서 네이티브로 리눅스 실행 파일(ELF)을 실행하기 위한 호환성 계층입니다.\nWindows10부터 WSL을 지원하며, Windows 2004(20H1) version부터 WLS2를 지원하고 있습니다.\n최신 Windows 업데이트 적용 (\u0026ldquo;Windows Key ⇒ 업데이트\u0026quot;로 이동하여 최신 업데이트를 적용합니다.) powershell을 관리자 권한으로 실행한 뒤, 설치 되어있는 WSL 2를 활성화시킵니다. \u0026gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. \u0026gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. MS Store로 이동하여 windows terminal을 설치합니다. windows terminal 화면 분할 예시 alt + shift + - : 가로 분할 alt + shift + + : 세로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 다음 링크를 통해 프로그램을 다운받고 WSL 2 Linux 커널 업데이트를 설치/진행 후 재부팅합니다.\n커널 업데이트를 마친 다음, powershell에 아래 커맨드 라인을 입력하여 WSL 2를 기본 사용하도록 설정합니다.\n\u0026gt; wsl --set-default-version 2 WSL 2와의 주요 차이점에 대한 자세한 내용은 https://aka.ms/wsl2를 참조하세요 작업을 완료했습니다. 이 시점에서 발생할 수 있는 문제들을 한차례 살펴보고 가겠습니다.\nwsl --set-default-version 2 에서 작업 완료 메세지가 등장하지 않는 경우 ⇒ 제일 처음 명령어부터 제가 보여드린 예시와 동일한 결과를 얻었는지 확인해보세요\nLinux용 Windows 하위 시스템 설정 여부도 확인합니다.\n지금까지 진행한 작업들이 제대로 설정 되어있는지 확인해봅시다. \u0026gt; wsl -l -v NAME STATE VERSION * Ubuntu-20.04 Running 2 문제가 없다면 MS Store 진입 후, Ubuntu 20.04 버전을 설치합니다. 설치 이후, 열기 버튼을 눌러 초기 실행을 하고 username, password를 설정합니다.\n이 시점에서 발생할 수 있는 문제들도 다시 한차례 살펴보고 가겠습니다.\n‘The WSL Optional Component is not Enabled. Please Enable it and Try again’ 오류가 발생하는 경우 \u0026gt; Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 0x80370102 에러가 발생한 경우 ⇒ 부팅 BIOS에서 가상화 기능을 활성화해줍니다.\n0xc03a001a 에러가 발생한 경우 ⇒ 다음 블로그 포스팅을 참고합니다.\n설치 이후에는 windows terminal에서 Ubuntu Terminal을 선택하여 실행 및 진입이 가능합니다. 설정 탭을 통해 Ubuntu 20.04를 기본 터미널로 설정 후 저장합시다.\nROS / ROS 2를 한줄 설치합니다. $ cd ~/ $ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; Installing Neuron Startup Menu... Cloning into \u0026#39;/home/kimsooyoung/ros_menu\u0026#39;... remote: Enumerating objects: 583, done. remote: Counting objects: 100% (290/290), done. remote: Compressing objects: 100% (193/193), done. remote: Total 583 (delta 179), reused 173 (delta 93), pack-reused 293 Receiving objects: 100% (583/583), 154.50 KiB | 3.22 MiB/s, done. Resolving deltas: 100% (340/340), done. Do you want to install ROS automatically? (y/N): y 설치가 완료되었다면, 앞으로 터미널을 새로 등장시킬 때마다 다음과 같이 사용할 ROS 버전을 묻게 됩니다. GUI 인터페이스 설정 링크를 통해 VcXsrv를 설치합니다. ⇒ https://sourceforge.net/projects/vcxsrv/ 설치 이후, XLaunch를 실행하고, 사진과 같은 설정을 진행합니다. 앞으로 재부팅 시마다 이 설정을 반복해줘야 하며, 종종 Gazebo의 Memory Leak로 인해 화면이 종료되지 않는 경우가 있는데, 이런 경우 XLaunch를 강제 종료해주면 됩니다.\n설정이 잘 되었는지 Gazebo를 실행해봅시다. export GAZEBO_IP=127.0.0.1 export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 export LIBGL_ALWAYS_INDIRECT=0 gazebo Gazebo의 실행 시 그래픽 카드 인식 문제가 발생하면 아래와 같이 어두운 화면이 등장합니다.\n이러한 경우, World 탭 ⇒ Scene ⇒ Shadows 옵션을 토글해주시면 됩니다. 마지막입니다! ~/.bashrc를 수정합니다. echo \u0026#39;export GAZEBO_IP=127.0.0.1\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 \u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export LIBGL_ALWAYS_INDIRECT=0\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 발생할 수 있는 오류 상황들을 살펴보고 가겠습니다.\ngazebo 실행 시 symbol error $ gazebo gazebo: symbol lookup error: /usr/lib/x86_64-linux-gnu/libgazebo_common.so.9: undefined symbol: _ZN8ignition10fuel_tools12ClientConfig12SetUserAgentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE 해결 방법 ⇒ sudo apt upgrade -y libignition-math2\nGazebo 자체가 실행되지 않는 경우\nPC 재시작 후 백신 프로그램을 종료시킵니다. 제어판 ⇒ 시스템 및 보안 ⇒ Windows 방화벽 ⇒ 고급 설정 ⇒ 인바운드 규칙 ⇒ VcXsrv 사용 허용\nGazebo는 실행되지만, Grid (실선)이 등장하지 않는 경우\n안타깝지만 그래픽 드라이버 문제일 가능성이 큽니다. (Window ⇒ 업데이트 확인 진입 후 가장 최신 버전으로 모두 업그레이드를 실행해줍니다.)\nDocker 기반의 ROS 설정 이전 설치 모두 실패하신 경우 사용할 수 있는 최후의 방법이자. MacOS 사용자들을 위한 설정입니다.\ndocker desktop for windows를 설치합니다. ⇒ https://docs.docker.com/desktop/windows/install/ # 설치 확인 \u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 설치 확인 이후 동일한 명령 프롬프트에서 다음 커멘드 라인을 입력하여 도커 이미지를 다운받습니다. (해당 docker image는 강의에 필요한 작업을 제가 미리 준비해둔 것입니다.) docker pull tge1375/du_ros_noetic:0.0.0 docker 이미지를 최초 실행 시, 방금의 명령 프롬프트에서 아래와 같은 커멘드 라인을 입력해 주세요. docker run -it -p 6080:80 --name ros_noetic tge1375/du_ros_noetic:0.0.0 입력 후 링크를 통해 로컬 VNC 서버로 접속이 가능합니다. 첫 실행 시 방화벽 보안 경고가 등장하며, 이때 반드시 엑세스를 허용해줍니다. ⇒ (http://127.0.0.1:6080/) 위와 같은 화면이 등장했다면 noVNC에 접속이 성공한 것입니다.\n최초 명령 프롬프트에서 실행한 이후 다시 실행시키고 싶은 경우, 혹은 중지시키고 싶은 경우 docker desktop을 사용하면 매우 편리하게 작업이 가능합니다. VScode 셋업 VNC내에서의 개발은 매우 불편하기 때문에, VScode를 통해 코드 개발을 하고자 합니다. 다음과 같은 extension들을 설치합시다.\nDocker Docker Explorer Remote Development 설치 이후, cmd + p를 통해 Remote-Containers를 입력하면, 현재 실행 중인 컨테이너의 목록을 조회할 수 있습니다.\n이들 중 원하는 컨테이터를 선택하면, 새로운 vscode가 새로이 실행되며 작업 폴더를 설정하게 됩니다.\nLinux Commands 셋팅한 환경은 모두 리눅스를 기반으로 합니다.\n때문에 최소한의 리눅스 커멘드 지식이 필요하며, 짚고 넘어가겠습니다.\n리눅스 필수 명령어\ncd \u0026lt;디렉토리\u0026gt; : 해당 디렉토리로 이동하기 (절대 경로와 상대 경로, ../ 와 ~/) pwd : 현재 위치한 절대 경로 ls : 현재 디렉토리에 위치하는 모든 파일들 (ls -al 옵션) touch \u0026lt;파일 이름\u0026gt; : 해당 이름을 가진 파일 생성 source : 쉘 스크립트 실행하기 (source ~/.bashrc) 강의를 위해 알아야 할 추가 명령어들\nsudo : root 권한으로 실행하기 apt install / remove / purge : 리눅스 배포 패키지 설치 apt update : apt의 상태를 최신화, 설치된 패키지들을 최신화하는 과정을 포함함 그 외 알아두면 좋은 것들\ntop / htop : 리눅스의 작업 관리자 ps aux : 실행 중인 프로세스 출력 (ps aux | grep ros) tee \u0026lt;파일 이름\u0026gt; : 터미널 로그를 기록하기 xdg-open . : 현재 위치에서 파일 탐색기 열기 강의 중 설정된 Alias 설명\neb : edit bashrc의 약자로 ~/.bashrc 파일을 gedit을 통해 수정할 수 있습니다. sb : source bashrc의 약자로 수정된 ~/.bashrc 파일을 반영시킵니다. killg : 실행중인 Gazebo관련 모든 프로그램을 종료시킵니다. 유용한 프로그램들 설치하기\nsudo apt install gedit sudo apt install terminator -y 코드 에디터와 IDE 추천\nVSCode - https://code.visualstudio.com/ PyCharm - https://www.jetbrains.com/ko-kr/pycharm/download CLion - https://www.jetbrains.com/ko-kr/clion/ 참고자료\nhttps://www.youtube.com/watch?v=DW7l9LHdK5c https://www.lainyzine.com/ko/article/how-to-install-wsl2-and-use-linux-on-windows-10/ https://github.com/Tiryoh/docker-ros2-desktop-vnc https://89douner.tistory.com/123 "
},
{
	"uri": "/kr/ros_basic_noetic/lecture3/",
	"title": "Lecture3 - Core of ROS",
	"tags": [],
	"description": "",
	"content": " 지난 시간 개발환경 세팅을 잘 진행하였는지 확인을 해보면서 강의를 시작해보겠습니다.\n터미널 프로그램을 실행한 뒤, gazebo를 실행해 봅시다.\ngazebo 위 사진과 같은 화면이 나오지 않았다면 설치가 제대로 되지 않은 것입니다. (sudo apt install libgazebo11 을 통해 다시 설치해봅시다.)\nAbout Gazebo Gazebo의 특징과 기본적인 UI, 그리고 사용법을 짚고 넘어가고자 합니다.\nimage from : Open Robotics Gazebo는 로봇공학을 위해 제작된 전용 물리 엔진 기반의 높은 3D 시뮬레이터입니다.\nROS를 관리하는 Open Robotics에서 비롯된 시뮬레이터인만큼 ROS와 높은 호환성을 자랑합니다.\nGazebo는 실제 로봇을 위한 설계 검증 테스트와 시뮬레이션을 용이하게 하며, 윈도우, 맥, 리눅스에서 모두 실행되지만 대부분 리눅스 시스템에서 ROS와 함께 사용됩니다.\n⇒ 이후 Gazebo 사용 및 오류 발생 시 디버깅을 위해, Gazebo를 구성하는 요소들을 간단하게 짚고 넘어가겠습니다.\ngzserver \u0026amp; gzclient Gazebo는 Socket-Based Communication을 갖습니다. 따라서 서버와 Client를 분리하여 실행 가능하며 다른 기기에서의 실행 후 연동도 가능합니다.\nGazebo Server gzserver는 Gazebo 동작의 대부분을 수행합니다. 시뮬레이션하려는 장면과 그 안에 있는 개체 파일을 분석하고, 그런 다음 물리 엔진과 센서 엔진을 사용하여 전체 장면을 시뮬레이션합니다.\n터미널에서 다음 명령을 사용하여 서버를 독립적으로 시작할 수 있습니다.\n$ gzserver Gazebo Client gzclient는 gzserver에 연결하여 대화형 도구와 함께 시뮬레이션을 렌더링하는 Graphic Client를 제공합니다.\n다음 명령을 사용하여 gzclient를 단독으로 실행할 수 있습니다.\n$ gzclient client만 실행하면, 연결되고 명령을 수신할 서버가 없기 때문에 (컴퓨팅 리소스를 소비하는 것을 제외하고) 아무 것도 하지 않습니다.\nCombining Gazebo Server and Gazebo Client gzserver를 먼저 실행한 다음 gzclient를 실행하는 것이 일반적이며, 렌더링하기 전에 시뮬레이션 장면, 객체 관련 파라미터를 초기화할 수 있습니다.\ngazebo 명령어를 입력하면 내부적으로 server와 client가 순차적으로 실행됩니다.\n$ gazebo 이러한 이유로 Gazebo를 종료했다고 생각하지만 gzserver가 깔끔하게 종료되지 않는 상황이 발생합니다. ⇒ killg를 사용합시다!\nWorld File과 Model File image from : dronecode World Files Gazebo world file에는 로봇 모델, 환경, 조명, 센서, 다른 기타 물체들까지 시뮬레이션 환경의 모든 요소가 포함되어 있습니다. 일반적으로 확장자명 .world를 사용합니다.\n아래 예시와 같이 Gazebo 실행 시 world 파일을 옵션으로 하여 실행이 가능합니다.\n$ gazebo \u0026lt;yourworld\u0026gt;.world Model Files Gazebo의 World는 다양한 Model들로 구성됩니다. 하지만 Model만을 가지고 gazebo를 실행시킬 수는 없습니다. (gazebo 이렇게는 불가합니다.)\n모델을 별도의 파일로 보관하는 이유는 다른 프로젝트에 재사용하기 위해서이며, 로봇의 모델 파일 또는 다른 모델을 월드 파일 내에 포함하려면 다음과 같이 태그를 통해 import 할 수 있습니다.\n\u0026lt;include\u0026gt; \u0026lt;uri\u0026gt;model://model_file_name\u0026lt;/uri\u0026gt; \u0026lt;/include\u0026gt; Environment Variables Gazebo에 World, Model을 연동하고, gzserver와 gzclient 간 통신을 설정하기 사용하는 많은 환경 변수가 있습니다.\n예를 들어, GAZEBO_MODEL_PATH는 Gazebo가 모델 파일을 검색할 시 참조하는 경로입니다.\nPlugins Gazebo의 World, Model에 장착되는 각종 센서와 제어를 위한 다양한 플러그인이 준비되어 있으며, 이러한 플러그인은 커멘드 라인에서 로드하거나 SDF 파일 내부에 추가할 수 있습니다. (자체 Plugin을 개발할 수도 있습니다.)\nUnderstanding Gazebo GUI 이번에는 Gazebo의 기본 조작 방법과 내장 Tool들을 살펴보겠습니다.\n우선 Gazebo를 실행시킵니다. $ gazebo Gazebo의 시점 변환은 마우스를 사용하여 손쉽게 조작 가능합니다. 마우스 왼쪽 버튼을 누르고 드래그하면 시점을 이동할 수 있습니다. 마우스 휠을 누른 상태로 이동시키면 회전 시점을 조작할 수 있습니다. 최상단에 위치한 Top Toolbar를 살펴보겠습니다. 왼쪽부터 오른쪽 순서대로 각 아이콘 별 기능을 설명해보겠습니다.\nSelect mode Select mode는 가장 일반적으로 사용되는 커서 모드입니다. 장면을 탐색할 수 있습니다.\nTranslate mode 커서 모드를 선택한 다음 이동시키길 원하는 객체를 클릭합니다. 이후 등장하는 3축 중 적절한 축을 사용하여 개체를 원하는 위치로 끌기만 하면 됩니다.\nRotate mode translate mode와 마찬가지로 이 커서 모드를 사용하면 주어진 모델의 방향을 변경할 수 있습니다.\nScale mode Scale mode를 사용하면 객체의 전체 크기를 변경할 수 있습니다.\nUndo/Redo 앞,뒤로 되돌리는 기능입니다.\nSimple shapes 큐브, 구체 또는 실린더와 같은 기본 3D 모델을 환경에 삽입할 수 있습니다.\nLights 스포트라이트, 포인트 라이트 또는 방향이 정해진 조명과 같은 다양한 광원을 환경에 추가합니다.\nCopy/Paste 모델을 복사/붙여넣을 수 있습니다. (Ctrl+C/V를 통해서도 가능합니다.)\nAlign 이 도구를 사용하면 x y z 축 중 하나를 따라 한 모형을 다른 모델과 정렬할 수 있습니다.\n또는 두 모델을 특정한 면 기반으로 서로 붙이는 것도 가능합니다.\nChange view 상단 뷰, 측면 뷰, 전면 뷰, 하단 뷰와 같은 다양한 관점에서 장면을 볼 수 있습니다.\n다음으로 Side Panel을 살펴보겠습니다.\nWorld 현재 사용중인 조명 및 모델들이 표시됩니다. 개별 모델을 클릭하여 위치 및 방향과 같은 모델의 기본 파라미터를 보거나 편집할 수 있습니다. 또한 물리 옵션을 통해 중력 및 자기장과 같은 물성치도 변경할 수 있습니다. GUI 옵션을 사용하면 기본 카메라 뷰 각도 및 포즈에 액세스할 수 있습니다.\nInsert 추가할 모델을 찾을 수 있습니다. 환경 변수에 지정된 폴더에서 모델들을 검색한 뒤 배치하는 것이 가능하며, 환경 변수 설정 없이도 Add Path 옵션을 통해 정해진 포멧을 갖는 모델을 가져올 수 있습니다.\n다시 본론으로 돌아와서, ROS 설치는 잘 되었는지도 확인해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun rospy_tutorials talker 모든 확인이 끝났다면, 예제 프로그램을 실행시켜보겠습니다.\nHusky Gazebo 예제 패키지 설치 sudo apt-get update sudo apt-get install ros-noetic-husky-desktop sudo apt-get install ros-noetic-husky-simulator 예제 프로그램 실행 # Terminal 1 roslaunch husky_gazebo husky_empty_world.launch # Terminal 2 roslaunch husky_viz view_robot.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py cmd_vel:=/husky_velocity_controller/cmd_vel Terminal 1에서 발생하는 아래 오류는 무시해도 좋습니다.\n모든 실행이 정상 동작하였다면, Terminal 3에서 키보드를 통해 Husky를 제어할 수 있습니다. 로봇이 움직임에 따라 두번째 터미널 결과였던 Rviz에 아래와 같은 변화가 생깁니다. 다음으로, 새로운 터미널에서 아래 커멘드 라인을 실행시켜 봅시다. rosrun rqt_graph rqt_graph 위 그림은 방금 전 실행한 예제 내부적으로 어떠한 동작들이 이루어지고 있었는지를 보여주는 것으로, 강의를 마칠 때면 여러분들은 위 그림이 어떠한 의미를 갖는지 모두 이해하실 수 있을 것입니다.\n다음으로, 터미널을 새로 실행시켜 rosnode list와 rostopic list를 실행시켜 봅시다.\nrosnode list $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rostopic list $ rostopic list /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state /gazebo/set_model_state ... 앞으로의 강의들에서, 위 명령어들이 어떠한 의미를 갖는지 하나하나씩 함께 살펴보겠습니다.\nROS Node ROS는 각 프로세스들을 Node라는 단위로 관리합니다.\n로봇을 움직이는 Node, 센서와 통신하는 Node, 시각화 Node 등 다양한 Node들이 얽혀 로봇 시스템을 구성하게 됩니다. Node들 사이에는 데이터의 송수신이 필요합니다. 이를 담당하는 ROS의 통신 메커니즘들이 있으며 각기 다른 특성을 갖고 있습니다. Node들끼리 데이터를 주고받기 위해서는 어떤 노드가 존재하는지, id는 몇번인지 등의 정보가 공유되어야 할 것입니다. 아래 그림의 ROS Master가 이를 관리해주는 것이라고 이해하시면 됩니다. image from : clearpathrobotics 그렇다면, 방금 우리가 실행한 예시에서도 ROS Master와 Node들이 실행되었겠군요!\n실행되는 Node를 확인하는 방법은 크게 두 가지가 있습니다.\nrosnode command $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rqt_graph rosrun rqt_graph rqt_graph rqt graph를 살펴보면, 동그란 Node와 Node들 사이의 데이터 송수신이 화살표로 표현된 것을 알 수 있습니다. 키보드를 통해 제어 데이터를 송신하는 teleop_twist_keyboard는 gazebo node로 데이터를 보내고 있으며, 따라서 gazebo는 이 데이터를 통해 실제 로봇을 움직이게 되는 것입니다.\n특정 Node에 대해서 더 자세한 정보를 얻고 싶다면, rosnode info 커맨드를 사용합니다. $ rosnode info /base_controller_spawner -------------------------------------------------------------------------------- Node [/base_controller_spawner] Publications: * /rosout [rosgraph_msgs/Log] Subscriptions: * /clock [rosgraph_msgs/Clock] Services: * /base_controller_spawner/get_loggers * /base_controller_spawner/set_logger_level contacting node http://192.168.55.236:33811/ ... Pid: 63764 Connections: * topic: /rosout * to: /rosout * direction: outbound (43329 - 192.168.55.236:34456) [10] * transport: TCPROS * topic: /clock * to: /gazebo (http://192.168.55.236:33853/) * direction: inbound * transport: TCPROS 이전 예제들은 일단 종료시킨 뒤, 간단한 새로운 예시를 실행해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener # Terminal 4 rqt_graph rqt_graph를 보면 talker ⇒ listener로 데이터가 전송되는 것을 알 수 있습니다.\n이제, rqt_graph를 보는 것은 익숙해졌지요?\n첫번째 Gazebo 예시와 다른 점으로 roscore라는 것을 실행해주었습니다.\nroscore는 ROS Master를 실행시키는 명령어로 모든 ROS Node들은 Master에 의해 관리되기 때문에 roscore를 통해 실행시키거나, roslaunch를 사용해야 합니다. ROS Master가 실행되고 있지 않다면, 아래와 같이 오류가 발생합니다. ETH Super Mega Bot \u0026amp; ROS Workspace ROS는 catkin이라는 빌드 시스템을 사용합니다. 기존 c/c++ cross-platform 개발을 경험하셨다면 cmake에 익숙하실텐데, 이와 매우 비슷합니다. catkin을 통해 실행 가능한 프로그램 (C/C++의 빌드), 라이브러리, 인터페이스들을 만들 수 있으며, catkin 시스템을 사용하기 위해서는 workspace라는 특별한 폴더가 필요합니다. ROS 개발을 하다 보면 여러 프로젝트를 동시에 진행하는 경우가 생깁니다. 새로운 작업은 새로운 폴더를 만들어 작업하듯이 ROS 에서도 새로운 프로젝트는 새로운 WorkSpace에서 작업을 수행하는 것이 일반적입니다. 새로운 WS로 이동하게 되면 ROS에게 이러한 변화를 알려줘야 하며 이 명령어가 source devel/setup.bash 입니다. 이번 강의용 WS를 만들어보고, 이후 여러분들만의 WS도 만들어 작업해보세요! 일반적으로 ROS의 workspace는 name_ws라는 이름을 갖는 것이 일반적이며, 우리는 catkin_ws라는 workspace를 만들어보고자 합니다.\n아래 커멘드 라인들을 따라해주세요 cd ~/ mkdir -p catkin_ws/src cd catkin_ws catkin config --init catkin build 다음과 같이 build, devel, src, log 폴더가 만들어집니다. ROS 코드들은 모두 src 폴더 안에 위치하게 됩니다. src 폴더 내부에서 코드 개발 ⇒ catkin을 사용한 빌드 ⇒ build 폴더 내부에 실행 가능한 프로그램 생성의 순서로 개발이 이루어집니다. 실습을 통해 개발 프로세스에 익숙해져봅시다.\n아래 폴더를 catkin_ws/src 안에 압축 해제합니다. Example Packages smb_common.zip (132 ) 터미널 프로그램을 실행시키고 아래 커멘드 라인을 따라합니다. catkin build smb_description catkin build smb_gazebo catkin build smb_control source devel/setup.bash source로 시작하는 마지막 라인은 새로운 빌드 후에 항상 실행해줘야 합니다. 1강을 잘 따라했다면 sds라는 단축어로 사용이 가능합니다.\n예제 프로그램을 실행시킵니다. roslaunch smb_gazebo smb_gazebo.launch 실행 시 붉은 에러 메세지가 나오지만 동작만 된다면 문제 없습니다.\n이 로봇을 한번 움직여 볼까요? - teleop 실행 rosrun teleop_twist_keyboard teleop_twist_keyboard.py 파일 구조 관점에서, ROS Application은 여러 Package들로 이루어집니다. 이들 Package가 소스 파일을 담고 있고, catkin이 이들을 빌드하여 실행 프로그램들을 만들었습니다. 제가 공유한 압축 파일 안에도 3개의 Package가 포함되어있던 것이며, ROS 개발자들은 자신들의 로봇 Package를 개발하고 공유합니다. Package 생성 실습 Package를 생성하는 방법은 다음과 같습니다.\ncd \u0026lt;your-ws\u0026gt;/src catkin_create_pkg \u0026lt;package_name\u0026gt; [depend1] [depend2] [depend3] my_first_package라는 package를 시험삼아 생성해봅시다.\n# exameple $ catkin_create_pkg my_first_package rospy std_msgs Created file my_first_package/package.xml Created file my_first_package/CMakeLists.txt Created folder my_first_package/src Successfully created files in /home/kimsooyoung/catkin_ws/src/my_first_package. Please adjust the values in package.xml. depend에는 해당 패키지의 의존성 패키지들이 나열되며, rospy는 파이썬을 통해 ROS를 사용하기 위한 의존성입니다.\n미리 제공되었던 Package, smb_gazebo를 살펴봅시다.\nGazebo 실행에 필요한 모델 파일과 환경 파일 등 기능별 정리된 모습을 볼 수 있습니다.\n이렇게 Package를 잘 구성해두면 이후 코드의 관리에도 편리하다는 장점이 있습니다.\n참고자료\nhttp://wiki.ros.org/ko/ROS/Tutorials/CreatingPackage https://rsl.ethz.ch/education-students/lectures/ros.html https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture4/",
	"title": "Lecture4 - ROS Launch, RViz",
	"tags": [],
	"description": "",
	"content": "ROS Launch 일전 예시 실행에서 다음과 같은 커멘드 라인을 사용했었습니다.\nroslaunch smb_gazebo smb_gazebo.launch roslaunch란, 다수의 ROS Node들을 한번에 실행할 수 있도록 해주는 툴 입니다.\nroslaunch를 사용하기 위해서는 xml이라는 포멧을 사용하는 launch file이 있어야 하며, 이는 보통 패키지의 launch 폴더에 위치하고 있습니다.\nlaunch file의 구조를 파악해봅시다.\nlaunch파일은 xml이라는 문법을 사용합니다. html을 사용해보셨다면 아시겠지만, \u0026lt;\u0026gt;를 이용하여 라인을 구분하는 포멧입니다. 한 라인에서 끝나는 경우 /\u0026gt;로 맺을 수 있지만, 여러 라인이 필요한 경우에는 여는 태그와 닫는 태그를 사용하여 구분합니다. \u0026lt;tag /\u0026gt; or \u0026lt;tag (value)\u0026gt; ... \u0026lt;/tag\u0026gt; launch file은 시작과 끝, 태그로 감싸집니다.\nnode 태그는 실행되는 ROS Node를 지칭합니다. name 태그는 node를 실행할 때의 이름을 설정하는 부분으로 자유롭게 지정 가능합니다. pkg 태그에는 해당 node가 속해있는 package를 적습니다. type 태그에는 실행가능한 파일, 혹은 프로그램을 적게 되며, c++의 경우 빌드된 프로그램, 파이썬의 경우 파이썬 파일이 됩니다. output 태그는 로그가 출력되는 위치를 지정하며 screen일 시 터미널에 출력됩니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;listener\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;listener.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;talker\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;talker.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 이번에는 smb_gazebo.launch를 살펴봅시다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- GAZEBO ARGUMENTS --\u0026gt; \u0026lt;!-- Run Gazebo headless --\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;model_path\u0026#34; default=\u0026#34;$(find smb_gazebo)/\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_namespace\u0026#34; default=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_model_name\u0026#34; default=\u0026#34;smb\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;enable_ekf\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; ... \u0026lt;!-- Load Gazebo world --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; arg란, argument의 약자이며 launch 파일에서 인자로 작용하는 일종의 변수입니다.\narg 태그를 통해 argument를 선언하고 default를 통해 초기값을 정할 수 있습니다. argument의 선언 후 사용은 $(arg \u0026ldquo;argument name\u0026rdquo;) 입니다. roslaunch 시 argument를 바꿔 실행이 가능합니다. 예를 들어, smb_gazebo.launch 실행 시. world를 바꾸어 아래와 같이 사용이 가능합니다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school 초기 실행 시 시간이 다소 걸릴 수 있습니다.\n현재 예시에서 제공되는 world는 다음 3가지 입니다.\nroslaunch smb_gazebo smb_gazebo.launch 제작한 launch file을 다시 다른 launch file에서 불러오는 경우가 더러 있습니다.\n이때, include 태그를 사용하며, 패키지 단위를 기반으로 파일의 경로를 가져오게 됩니다.\ninclude하는 launch file의 내부에도 여러 argument들이 있을 것입니다. 이들은 arg 태그를 통해 접근할 수 있습니다.\n\u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; html과 마찬가지로 \u0026lt;!-- --\u0026gt; 사이에 오는 코드는 주석으로 무시됩니다.\n단, 주의사항 하나 있습니다. launch 파일을 사용하다보면 --가 종종 쓰이곤 하는데요. 이 경우 주석에 오류가 나니 주의하시기 바랍니다.\nLaunch File을 다루는 연습을 해봅시다.\nsmb_gazebo.launch를 다음과 같이 수정합니다.\nworld를 big_map_summer_school로 수정합니다. 로봇이 등장하는 위치를 다음과 같이 수정합니다. xyz : (-0.5, -1.0, 0.4) yaw angle : 90도 (3.1415를 1 radian으로 잡습니다.) launch file에 rospy_tutorials Package에 있는 talker Node를 추가합니다. Rqt와 RViz ROS에는 로봇의 다양한 센서 데이터들을 시각화해주는 3D 툴이 있으며, 이는 RViz라고 불립니다.\nRviz의 사용법을 알아봅시다.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 rviz 사진과 같이 Gazebo와 RViz가 잘 실행된 상황에서 강의를 따라합니다.\nrviz에서 센서 데이터를 시각화하기 전, 우선 어떤 좌표계를 기준으로 시각화할지 설정해주어야 합니다.\n같은 센서라도 원점 좌표계에서 본 모습과, 센서 좌표계에서 본 모습이 다르기 때문입니다.\nimg from : mathworks 이는 RViz의 Fixed Frame에서 설정 가능합니다. (odom으로 설정해보겠습니다.)\n이제 다양한 시각화 기능들을 사용해보려 합니다.\n기본적으로 데이터의 추가는 왼쪽 하단 Add 버튼으로 실행합니다. tf 시각화 odometry 시각화 point cloud 시각화 이렇게 잘 설정해둔 RViz는 config 포멧으로 추출하여 이후에 다시 사용할 수 있습니다.\nFile ⇒ Save Config를 통해 config를 저장하고, Open Config를 통해 저장한 config를 불러올 수 있습니다.\n아래와 같이 다양한 Plugin을 통해 여러 센서, 로봇 데이터를 시각화할 수 있으며, 자신만의 Plugin을 제작할 수도 있습니다.\n지금까지 여러분들이 만든 RViz 설정을 저장해보고, launch file에 통합해봅시다.\nRViz의 좌측 상단 File 옵션을 사용하여 config file을 저장합니다. 저장 위치는 smb_gazebo/rviz로 지정하겠습니다. (새롭게 폴더를 만들어주었습니다.) 이제, launch file을 수정합시다. 파일 하단 launch 태그가 닫히기 전 부분에 아래와 같은 라인을 추가합니다. \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find smb_gazebo)/rviz/my_config.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 이제, 다시 Gazebo launch를 해봅시다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school Rqt Tools 지금까지 사용한 ROS 툴은 rqt_graph와 RViz가 있었습니다.\n사실 ROS에는 수많은 추가 툴들이 존재하며 이들을 묶어 rqt tools라고 부릅니다.\nrqt image view image from : wiki.ros.org\nrqt multiplot image from : project march\nrqt console image from : wiki.ros.org\nrqt robot steering rqt tf tree image from : rqt tf tree\n이러한 수많은 툴들이 있어 ROS 개발을 편리하게 해주고 있으며, 함께 ROS를 공부하면서 하나씩 같이 살펴보고 사용해보려 합니다.\n참고자료\nhttp://wiki.ros.org/roslaunch https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html https://rsl.ethz.ch/education-students/lectures/ros.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture5/",
	"title": "Lecture5 - First Programming, ROS Topic",
	"tags": [],
	"description": "",
	"content": "이번 강의부터, 본격적인 프로그래밍이 시작됩니다. 첫번째로 Node의 프로그래밍을 살펴보고자 하며, 시작 전 간단한 복습을 진행하고 시작하겠습니다.\nimage from : clearpathrobotics\nWorkspace와 패키지 # WS 생성 mkdir -p catkin_ws/src cd catkin_ws catkin config --init # Package 생성 catkin_create_pkg \u0026lt;pkg-name\u0026gt; \u0026lt;depend1\u0026gt; \u0026lt;depend2\u0026gt; ... ROS Node Programming C++ 코드는 src 폴더 안에, 파이썬 코드는 scripts라는 폴더 안에 위치시키는 것이 일반적입니다. cd \u0026lt;pkg-name\u0026gt; mkdir scripts 지금부터, 직접 명령어를 한줄씩 따라치면서 실습하셔도 좋고, 제가 미리 준비해둔 Package를 사용하셔도 좋습니다.\n다음으로, 파이썬 코드를 작성하고 패키지를 빌드해봅시다.\ncd scripts # my_first_node.py 생성 첫번째 프로그래밍 코드는 Node의 기본입니다.\n모든 소스코드는 github repo에서 확인 가능합니다.\nmy_first_node.py #!/usr/bin/env python3 import rospy from std_msgs.msg import String def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # ROS safe timer rate = rospy.Rate(10) # 10hz # Loop control Example while not rospy.is_shutdown(): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. rate.sleep() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드를 새로 작성한 다음에는 습관적으로 패키지를 빌드하고 실행합니다. 파이썬 코드의 경우 파일의 실행 권한이 주어져 있어야 합니다. cd scripts chmod +x * cd ~/catkin_ws catkin build my_first_pkg 작성한 node를 실행해봅시다. 반복해서 터미널 로그가 남을 것입니다. # Terminal 1 roscore # Terminal 2 rosrun my_first_package my_first_node.py 코드 분석 첫 코드인 만큼 자세하게 분석하고 넘어가보려 합니다.\nROS Noetic은 Python 3를 사용합니다. 가상환경의 파이썬, 직접 설치한 파이썬 등 여러 버전이 설치되어 있을 것입니다. 공식 문서에서는 이러한 혼란을 방지하기 위해 코드의 제일 처음 아래 라인을 추가하는 것을 추천하고 있습니다. #!/usr/bin/env python3 Python을 사용하여 ROS를 다루기 위해 사용되는 패키지는 rospy입니다. import를 사용해도 좋고 from / import를 통해 특정 클래스만 가져올 수도 있습니다. import rospy from std_msgs.msg import String 당장 사용하지는 않지만 Test Code를 작성해야 하는 경우가 있습니다. 이러한 상황에 대비하기 위해 main 함수를 따로 두고 아래와 같이 프로그램을 시작하기를 권장합니다. if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 이제, my_first_node를 분석해 보겠습니다. Node의 실행을 위해 Master에 등록하고, 초기화하는 작업이 필요하며, 이를 위해 별도로 init_node라는 메소드를 실행해주어야 합니다. def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) ROS 시스템은 기본적으로 무한 Loop입니다. 이 Loop가 한차례 반복되는 주기를 설정하는 부분입니다. ROS의 시간 체계에 대해서는 이후 한번 더 다루겠습니다. # ROS safe timer rate = rospy.Rate(10) # 10hz rospy를 통해 실행 중인 Node의 상태를 확인할 수 있으며, is_shutdown()은 예기치 못한 에러가 발생하거나 사용자의 종료를 인지할 수 있습니다. 10Hz를 맞추기 위해 Loop마다 sleep을 걸어주고 있습니다. # Loop control Example while not rospy.is_shutdown(): ... rate.sleep() ROS에서 콘솔 로그를 얻는 방법으로 print 보다 rospy.log를 사용하기를 추천합니다. hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. ROS Timer ROS는 기본적으로 무한 Loop를 하나의 프로세스 안에서 동작시키는 프로그램입니다. Timer를 통해 일정 시간마다 동작하는 코드를 구현할 수 있습니다.\ncd my_first_pkg/scripts # spin_node.py 생성 spin_node.py #!/usr/bin/env python3 import rospy # callback method requires event, which is TimerEvent def hello_du(event=None): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) def my_first_node(): rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # Timer Class is kind of Thread. # It\u0026#39;s rule is execute sleep in certain period with given event. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드의 실행 결과는 이전과 같기 때문에 Timer와 spin에 대해서만 짚고 넘어가겠습니다.\nTimer는 크게 두가지 매개변수를 받습니다. 실행 주기와 Callback 함수입니다. 해당 주기마다 Callback 함수를 실행시킵니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) 앞으로 여러분들은 직접 while loop를 구현하기보다 rospy.spin()을 더 많이 사용하시게 될 겁니다. Timer를 선언한 이후, 하나의 Thread에서 막혀버리는 것을 방지하는 역할을 수행합니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() image from : python tutorial\nOOP Node Programming my_first_oop_node.py #!/usr/bin/env python3 import rospy class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except rospy.ROSInterruptException: pass 이후의 실습들을 위해 한가지 예시만 더 살펴보고자 합니다. 객체 지향을 사용한 ROS Node 작성방법입니다. 파이썬에서 OOP를 사용하기 위해 Class 키워드를 사용하며, self등 OOP와 관련된 내용은 모두 알고 있다는 상태에서 진행하겠습니다.\nOOP를 사용하면 main 메소드가 매우 간편해진다는 장점이 있습니다. 클래스를 생성하고, spin을 하기만 하면 됩니다. def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() OOP로 전환되면서 변경된 구현에 주목합시다. Timer의 Callback 함수로 클래스 메소드가 사용되었으며, 클래스 변수인 counter를 사용하여 구현한 점에 주목합니다. class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 앞으로, 대부분의 코드는 OOP 기반으로 작성됩니다. 파이썬의 클래스에 대해 숙지가 되어있지 않다면 꼭 복습하고 다음 강의를 청취하세요!\nROS Topic 다시 개념 학습으로 돌아와보았습니다. 아래 그림은 지난 강의의 rqt_graph입니다.\n위 그림에서 동그라미는 Node를 뜻하고, 화살표는 topic을 뜻합니다.\n이번 시간에는 이 Topic이 무엇인지 배워보고자 합니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름입니다. image from : docs.ros.org 그림에서와 같이 ROS Topic은\nPublisher(발행자) Subscriber(구독자)로 나누어 Topic의 송신, 수신자를 구분합니다. Publisher, Subscriber는 Node안에서 생성되며 별도로 사용할 수는 없습니다. Pub/Sub 사이에 Message가 전달되며, 이 길의 이름이 Topic인 것입니다. 주의할 점은, Publisher, Subscriber는 오로지 Topic의 이름으로 소통한다는 것입니다. 어떤 Node에 publish 할지 Publisher는 전혀 모르며 오로지 Topic이 같은 Subscriber가 데이터를 받게 됩니다. 더불어, Topic은 여러 Node들로 부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. ⇒ Topic의 중요한 속성이니 꼭 알아두셨으면 좋겠습니다.\nimage from : docs.ros.org Node와 Topic의 개념을 다시 한 번 다잡고 갑시다.\nNode는 실행되는 프로그램이며, ROS Master에 등록하고 관리됩니다. Node들 사이의 통신 메커니즘 중 Topic이라는 것이 있으며, 이는 Publisher와 Subscriber라는 개념을 갖고 있습니다. Publisher와 Subscriber 사이의 오가는 데이터는 특정한 타입을 갖습니다. 이를 Message라고 부릅니다. Topic Message 로봇 프로그래밍 시에는 다양한 센서 데이터들이 다뤄집니다. 센서 뿐만 아니라, 제어 데이터도 주고 받아야 합니다. ROS에서는 주로 사용되는 이러한 데이터 형식을 Message라는 이름으로 지칭하며, 여러 기본 형태를 제공합니다. 더불어 사용자가 직접 Message를 커스터마이징할 수도 있습니다.\n일전 예시의 분석을 통해 Topic과 Message에 대해 다시 한 번 살펴봅시다. # Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener 두 프로그램이 실행되고 있는 상태를 유지하면서, 아래 내용을 따라와주세요\nrostopic list를 통해 사용중인 topic들을 모두 조회 가능합니다. $ rostopic list /chatter /rosout /rosout_agg 특정 topic에 대한 자세한 정보를 알고 싶다면 rostopic info를 사용합니다. talker와 listener가 조회된 모습도 보입니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /talker_215337_1671763968667 (http://192.168.55.236:37863/) Subscribers: * /listener_215355_1671763970127 (http://192.168.55.236:44969/) 해당 topic이 사용중인 Message를 조회하기 위해 rostopic type을 사용합니다. $ rostopic type /chatter std_msgs/String rosmsg show를 통해 Message의 원형을 확인할 수 있습니다. $ rosmsg show std_msgs/String string data topic 데이터를 엿볼 수 있는 rostopic echo입니다. $ rostopic echo /chatter data: \u0026#34;hello world 1671764088.1913402\u0026#34; --- data: \u0026#34;hello world 1671764088.2913551\u0026#34; --- ... rostopic hz로 topic의 pub/sub 주기를 분석할 수 있습니다. $ rostopic hz /chatter subscribed to [/chatter] average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00014s window: 10 average rate: 9.999 min: 0.099s max: 0.100s std dev: 0.00023s window: 20 마지막으로 rqt_graph를 다시 한 번 살펴봅시다.\nrqt_graph 방금 살펴본 커멘드 라인들을 충분히 숙지하시기 바랍니다. 그러한 의미에서, 이번에는 Gazebo 예시를 분석해볼까 합니다.\n# Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun teleop_twist_keyboard teleop_twist_keyboard.py rostopic list 결과 $ rostopic list /clicked_point /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state ... 우리가 집중하고자 하는 topic은 로봇을 제어하는 /cmd_vel입니다.\nrostopic info 결과 $ rostopic info /cmd_vel Type: geometry_msgs/Twist Publishers: * /teleop_twist_keyboard (http://192.168.55.236:33903/) Subscribers: * /twist_mux (http://192.168.55.236:38201/) * /gazebo (http://192.168.55.236:33033/) rostopic type 결과 $ rostopic type /cmd_vel geometry_msgs/Twist geometry_msgs/Twist의 rosmsg show 결과 $ rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z /scan의 rostopic echo 결과 $ rostopic echo /scan header: seq: 0 stamp: secs: 204 nsecs: 678000000 frame_id: \u0026#34;rslidar\u0026#34; angle_min: -1.5707999467849731 angle_max: 1.5707999467849731 angle_increment: 0.008700000122189522 time_increment: 0.0 scan_time: 0.033330000936985016 range_min: 0.44999998807907104 range_max: 50.0 ranges: [inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, ... /scan의 rostopic hz결과 $ rostopic hz /scan subscribed to [/scan] WARNING: may be using simulated time average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 8 average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 17 rqt_graph에서 /cmd_vel을 찾아볼까요?\nrqt_graph Publisher 프로그래밍 이번 시간 사용할 Package는 py_topic_pkg 입니다. 실습 전 실행부터 해보겠습니다.\nPackage Build cd ~/catkin_ws catkin build py_topic_pkg source devel/setup.bash 예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg cmd_vel_pub.py 로봇이 아래와 같이 원을 그리며 움직일 것입니다.\ncmd_vel_pub.py #!/usr/bin/env python3 import rospy from geometry_msgs.msg import Twist class CmdVelPubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. topic queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) self.twist_ = Twist() def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) def cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: cmd_vel_node() except rospy.ROSInterruptException: pass 파이썬 ros 프로그래밍을 위한 rospy, 로봇의 속도 제어에 필요한 Message type인 Twist를 import 하고 있습니다. import rospy from geometry_msgs.msg import Twist rospy.Publisher를 통해 publisher를 생성할 수 있습니다. 이는 최소 3개의 매개변수를 필요로 합니다. topic 이름 topic type queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10)= 우리는 로봇의 제어 신호를 주기적으로 전송하고자 합니다. 따라서 Timer도 선언하였습니다. self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) 다음으로, Message Type인 geometry_msgs/Twist 값을 채웁니다. 현재 우리 로봇은 2차원 평면에서 움직이며, 로봇 형태 때문에 앞뒤 선속도와 각속도를 갖게 됩니다. ... self.twist_ = Twist() def pub_msg(self, event=None): self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 Message의 종류는 매우 많습니다. 구글을 통해 검색하면서 코딩하는 습관을 들여봅시다.\nfrom : http://docs.ros.org/ linear의 단위는 m/s 이며, angular의 단위는 rad/s 입니다. pi = 3.14\n마지막, 가장 중요한 topic publish는 생성한 Publisher의 publish() 메소드를 사용합니다. 미리 준비해둔 topic message를 사용합시다. def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) 이 Node를 실행하면, 우리의 ROS가 일정 주기에 맞추어 알맞게 topic publish를 실행시켜줄 것입니다. 우리는 정해진 구현에 맞추어 코드만 작성하면 되는 것이지요 😊\ndef cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() Subscriber 프로그래밍 이번 예시에는 로봇에 장착된 라이다 센서를 사용해보려 합니다. 예시를 실행해보겠습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg laser_scan_sub.py 실행 이후, 영상과 같이 박스를 로봇의 전방에 배치해봅시다. 터미널에 등장하는 문구에 집중해보세요. 박스가 추가되면서 출력창에 어떠한 변화가 생기나요?\n로봇에 부착된 라이다 센서는 전방 180도 사방으로 360개의 레이저를 흩뿌립니다.\n레이저의 특성상 물체를 맞고 되돌아오게 되며, 이 시간을 통해 물체와의 거리를 알 수 있습니다.\n예시의 프로그램은 로봇에 부착된 레이저에서 publish되는 데이터를 subscribe한 것입니다. 이를 프로그래밍하면서 python으로 subscriber를 다루는 방법에 대해 배워봅시다.\nlaser_scan_sub.py #!/usr/bin/env python3 import rospy from sensor_msgs.msg import LaserScan class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) def laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: laser_sub_node() except rospy.ROSInterruptException: pass 이번에 사용하는 topic message는 sensor_msgs/LaserScan입니다. import rospy from sensor_msgs.msg import LaserScan subscriber는 publisher와 달리 Timer가 필요하지 않습니다. publish되는 데이터가 없으면 아무 동작을 할 수 없으며, publish 주기에 맞추어 subscribe할 수밖에 없는 것이지요.\nsubscriber는 rospy.Subscriber로 생성하며 최소 3개의 매개변수를 요구합니다. topic 이름 topic message 이름 subscribe 마다 실행되는 callback 메소드 class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) 이 callback 메소드에서 주의해야 할 점은, 항상 callback method의 매개변수가 subscribe된 데이터라는 점입니다. 지금의 경우 LaserScan 타입의 데이터일 것입니다. # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) ... 마지막으로, 깔끔한 터미널 출력을 위해 print 함수를 사용하였습니다. print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) Subscriber 실행 시에는 항상 rospy.spin()을 잊지 말도록 합니다. spin 되지 않는다면 특정 쓰레드가 자원을 점유하기 때문에 subscriber의 상태를 갱신할 수 없습니다.\ndef laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() 과제 - 물체 회피하기 pub/sub의 개념을 잘 이해하였는지 알아볼 수 있는 과제를 준비해보았습니다. 정답이 따로 있는 것은 아니기에 부담 없이 해보시고, 저의 답안도 한번 살펴보세요.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Ternimal 2 rosrun py_topic_pkg collision_aviod.py Gazebo 예제를 실행하였다면, 로봇의 전방에 장애물을 놓아 진로를 막아봅니다. 여러분께서 구현해야 하는 것은, 라이다 센서를 사용하여 로봇이 회피 주행을 하도록 만드는 것입니다. 일종의 템플렛 코드를 첨부하였으며, my_collision_aviod.py라는 이름의 코드입니다.\n해당 코드의 TODO 부분을 작성하여 여러분만의 회피 알고리즘을 만들어 보세요!\n로봇의 라이다 데이터인 LaserScan을 Subscribe하여 Twist Type을 사용하는 scan topic으로 publish를 하게 됩니다. class CollisionAvoidNode: def __init__(self): self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.twist_ = Twist() def laser_cb(self, data): # TODO: Prevent robot from collision # make your own logic to do that return None 제가 작성한 예시를 수정하여 더욱 똑똑한 로봇을 구현하셔도 좋고, 자유롭게 실습해보시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/msg "
},
{
	"uri": "/kr/ros_basic_noetic/lecture6/",
	"title": "Lecture6 - ROS Service, Parameter",
	"tags": [],
	"description": "",
	"content": " 지난 시간 마지막 예시였던 장애물 회피 코드부터 간단하게 리뷰해보고자 합니다.\n제가 작성한 로직은 다음과 같습니다.\n과제를 해보셨다면 아시겠지만, 측정 범위를 벗어나게 되면 data.ranges는 inf 값을 갖게 됩니다. 이를 걸러내는 코드가 아래 부분입니다. for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: 저의 로직은, 정면을 기점으로 왼쪽과 오른쪽 각각 inf가 아닌 데이터의 개수를 카운팅합니다. 전체 데이터가 362개이고 마지막 데이터는 사용하기 않는 값이기 때문에, 180을 기점으로 잡았습니다. left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 이제, 제어 데이터를 만들어줍니다. ROS를 비롯하여 로봇 시스템에서는 대부분 오른손 좌표계를 사용합니다. 따라서 위에서 보았을 rospy.loginfo(hello_du)때 오른손이 감기는 반시계 방향이 + 부호를 갖게 됩니다. 이를 고려하여 각속도를 정했습니다. 180은 magic number, 일종의 변환 상수입니다. image from : 오로카\ndef laser_cb(self, data): left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 self.twist_.linear.x = 0.3 self.twist_.angular.z = (right_side_count - left_side_count) / 100 self.cmd_vel_pub_.publish(self.twist_) 지난 강의에서 이야기한 것과 같이 이 문제의 정답은 없습니다.\n다만, Topic의 Pub / Sub을 모두 사용할 수 있는지 스스로 점검해볼 수 있을 것입니다.\nROS Parameter 앞선 저의 예시에서 마지막 속도로 변환하는 부분 수식에 나누기 100이 있었던 것을 기억하시나요? 이런 상수를 직접 코드에 적는 것은 사실 추천되지 않습니다. 개발 이후 해당 상수를 변경하고자 하였을 시, 직접 코드를 수정하고 다시 실행해야 하기 때문에 불편을 야기합니다.\n이러한 문제의 해결 방법으로 ROS의 매개변수, parameter를 다루는 방법을 알아보겠습니다.\npy_param_pkg/scripts/various_params.py #!/usr/bin/env python3 import rospy class ParamNode: def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) rospy.loginfo(f\u0026#34;\u0026#34;\u0026#34; self.str_param_ = {self.str_param_} self.int_param_ = {self.int_param_} self.double_param_ = {self.double_param_} self.bool_param_ = {self.bool_param_} self.list_of_float_param_ = {self.list_of_float_param_} \u0026#34;\u0026#34;\u0026#34;) def param_node(): rospy.init_node(\u0026#39;param_node\u0026#39;, anonymous=True) param_node = ParamNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: param_node() except rospy.ROSInterruptException: pass 실행 결과는 다음과 같습니다. $ rosrun py_param_pkg various_params.py [INFO] [1672014267.630578]: self.str_param_ = hello_world self.int_param_ = 2023 self.double_param_ = 3.14 self.bool_param_ = True self.list_of_float_param_ = [1.0, 2.0, 3.0, 4.0] 매개변수를 선언하고 기본값을 지정하는 방법은 rospy.get_param을 사용하는 것입니다. 두번째 기본값을 잘 보면 어떤 타입을 사용하는지 알 수 있습니다. def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) parameter 앞에 붙는 물결 표시 (~)는 private parameter를 의미합니다. 이에 대해 궁금하다면 아래의 추가 자료를 학습해보세요. global_name = rospy.get_param(\u0026#34;/global_name\u0026#34;) relative_name = rospy.get_param(\u0026#34;relative_name\u0026#34;) private_param = rospy.get_param(\u0026#39;~private_name\u0026#39;) default_param = rospy.get_param(\u0026#39;default_param\u0026#39;, \u0026#39;default_value\u0026#39;) 추가 자료 : wiki.ros\n매개변수를 변경하는 가장 보변적인 방법은 launch file을 사용하는 것입니다. launch file의 param 태그를 사용하여 Node에 원하는 parameter를 전달할 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; ROS 프로그래밍을 하다 보면 매개변수가 아주 많이 필요한 경우가 있습니다. 이럴 때마다 launch file에 param 태그 라인을 추가하는 것은 매우 귀찮은 일입니다.\nyaml이라는 형식의 파일로 매개변수를 한번에 관리할 수 있습니다.\npy_param_pkg/param/config.yaml str_param: \u0026#34;yaml string\u0026#34; int_param: 9 double_param: 2.71828 bool_param: \u0026#34;false\u0026#34; list_of_float_param: [3., 2., 1.] py_param_pkg/launch/param_with_yaml.launch \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;rosparam command=\u0026#34;load\u0026#34; file=\u0026#34;$(find py_param_pkg)/param/config.yaml\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; launch file에 rosparam 태그를 추가하고, load command를 사용하며 사용하는 yaml 파일의 위치를 file 옵션을 통해 전달합니다.\nROS parameter Commands rostopic, rosnode와 같이 parameter 또한 터미널 명령어를 갖고 있습니다.\n접근 가능한 모든 parameter들을 나열합니다. rosparam list 특정 paramter의 값을 얻고자하면 아래 키워드를 사용합니다. rosparam get \u0026lt;parameter_name\u0026gt; 선언되어 있는 parameter의 값을 변경하고 싶은 경우 아래 키워드를 사용합니다. rosparam set \u0026lt;parameter_name\u0026gt; \u0026lt;value\u0026gt; 여러분들이 작성한 회피 프로그램에도 매개변수로 작용하는 상수들이 있을 것입니다. 이를 parameter로 변경하여 launch file과 yaml file로 업데이트하는 작업을 해보세요\nROS Service Topic에 이어 ROS의 통신 메커니즘 두번째로 Service를 배워보겠습니다.\nService가 동작하는 방식은 아래와 같습니다.\n그림과 같이 Client Node가 Server Node로 request를 주면, 해당 request에 대응하는 적절한 response가 다시 Client에게로 전달됩니다. 이 과정을 Service Call이라고 부릅니다.\nimage from : docs.ros.org\n하나의 Service Server에는 여러 Client Node가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지는 못합니다. 두 Node에서 동시에 request가 왔다면, 조금이라도 먼저 통신한 Node의 작업을 우선 진행하고, 그동안 다른 Node는 기다리고 있어야 합니다. image from : https://docs.ros.org/en/foxy/Tutorials/Services/Understanding-ROS2-Services.html\nTopic과 비교하여 Service의 특징을 알아봅시다.\n1:1 통신 : Topic publish를 하면 여러 Node가 Subscribe 가능합니다. 반면, Service는 request가 온 대상에게만 response를 줍니다. 순차적 통신 : Service Server는 동시에 여러 request를 처리할 수 없습니다. 현재 작업중인 request가 처리될 때 까지 다른 request는 기다리고 있어야 합니다. 단발성 : Topic은 대부분 지속적으로 publish를 진행하는 반면, Service는 1회성 통신입니다. 실제 로봇 프로그램에서 Service는 어떻게 사용될 수 있을지, 예시를 통해 살펴봅시다.\n예제 패키지 빌드 cd ~/catkin_ws catkin build py_service_pkg source devel/setup.bash Service Client 예제 실행 - 아르키메데스 나선 # Terminal 1 roslaunch py_service_pkg empty_gazebo.launch # Terminal 2 rosrun py_service_pkg spawn_model_client.py 방금 실행한 예시는 Gazebo에게 box를 등장시켜달라고 하는 Service Client를 포함하고 있습니다.\nBox가 등장하는 위치를 아래 사진과 같은 수식에 맞추어 설정한 것 뿐입니다.\n그럼, 코드를 분석해 볼까요?\n필요한 파이썬 패키지들을 import 합니다. import math import rospy import rospkg from geometry_msgs.msg import Pose from gazebo_msgs.srv import SpawnModel 여기서 중요한 점은 msg와 srv 부분입니다. topic에서 사용되는 데이터 타입이 Message였고, 프로그래밍 시에는 msg로 사용하였습니다.\nService에서는 msg가 아니라 srv라는 데이터 타입을 사용합니다. image from : rsl.eth\n이 srv는 msg와 다른 점이 있는데, request와 response로 나뉘어 있다는 점입니다. \u0026mdash; 표시를 기점으로 위쪽은 Server에게 전달하는 request, 아래쪽은 Server가 다시 회답하는 response 부분입니다. 이번 예시에서 사용한 gazebo_msgs/SpawnModel도 아래와 같은 구조를 갖습니다. image from : docs.ros.org\ngazebo_msgs/SpawnModel를 살펴보면 파란 글자로 geometry_msgs/Pose라는 부분이 있습니다. 이와 같이 srv는 다른 msg를 품을 수도 있고, 이렇게 만든 srv를 또다시 다른 srv에 포함시킬 수도 있습니다.\n코드 구현 관점에서, geometry_msgs/Pose는 Model을 등장시킬 초기 위치를 지정하는데 사용됩니다.\n# initial_pose initial_pose = Pose() initial_pose.position.x = 0.0 initial_pose.position.y = -1 initial_pose.position.z = 0.2 # z rotation -pi/2 to Quaternion initial_pose.orientation.z = -0.707 initial_pose.orientation.w = 0.707 Service Client의 생성과 사용은 아래와 같습니다. spawn_model_prox = rospy.ServiceProxy(\u0026#34;gazebo/spawn_urdf_model\u0026#34;, SpawnModel) ... result = spawn_model_prox( entity_name, model_xml, robot_namespace, initial_pose, reference_frame ) rospy.ServiceProxy()는 2개의 매개변수를 필요로 합니다.\nservice 이름 service 데이터 타입 (srv) 생성한 client로 request를 하기 위해서는 생성한 인스턴스에 매개변수를 전달하기만 하면 됩니다. 마치 함수 호출처럼 말이지요. 이는 ServiceProxy 내부적으로 call 메소드가 구현되어있기 때문입니다.\nservice call의 결과로 result가 반환되며, 예시에서는 성공 여부를 반환하도록 되어 있습니다.\n추가적으로, model을 불러오는 부분을 간단하게 설명하고자 합니다. # model_xml rospack = rospkg.RosPack() model_path = rospack.get_path(\u0026#34;py_service_pkg\u0026#34;) + \u0026#34;/urdf/\u0026#34; with open(model_path + model_name + \u0026#34;.urdf\u0026#34;, \u0026#34;r\u0026#34;) as xml_file: model_xml = xml_file.read().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) Gazebo는 urdf라는 파일을 전달하면 해당 파일을 기반으로 시뮬레이션에 물체를 등장시켜줍니다. 이 urdf라는 것은 로봇을 표현하기 위한 일종의 약속된 파일 확장명입니다.\nimage from : spart\n세상 모든 로봇들은 joint와 link로 표현 가능합니다. 이러한 개념을 바탕으로 로봇의 특성을 텍스트 파일로 표현하는 형식이 바로 urdf이며, 아래와 같이 여러 태그와 속성을 사용하여 작성 가능합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;link name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!-- Inertia values were calculated to be consistent with the mass and geometry size, assuming a uniform density. --\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0108\u0026#34; ixy=\u0026#34;0\u0026#34; ixz=\u0026#34;0\u0026#34; iyy=\u0026#34;0.0083\u0026#34; iyz=\u0026#34;0\u0026#34; izz=\u0026#34;0.0042\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; ROS Service Commands gazebo/spawn_urdf_model과 같은 service는 gazebo_ros를 사용할 때 자동으로 함께 실행됩니다. 이렇게 현재 어떠한 service가 존재하며, 또 구체적인 정보는 어떻게 조회하는지 알아봅시다.\n현재 사용 가능한 모든 service를 조회해봅시다. $ rosservice list /delete_entity /gazebo/describe_parameters /gazebo/get_parameter_types /gazebo/get_parameters /gazebo/list_parameters /gazebo/set_parameters ... 리눅스의 grep 명령어를 함께 사용해 보세요.\n특정 service가 어떤 srv 타입을 사용하는지 검색하고 싶다면 다음 커멘드 라인을 사용합니다. $ rosservice type /gazebo/spawn_urdf_model gazebo_msgs/SpawnModel 이렇게 검색된 srv는 rossrv show와 결합할 때 더욱 진가를 발휘합니다. $ rossrv show `rosservice type /gazebo/spawn_urdf_model` string model_name string model_xml string robot_namespace geometry_msgs/Pose initial_pose geometry_msgs/Point position float64 x float64 y float64 z geometry_msgs/Quaternion orientation float64 x float64 y float64 z float64 w string reference_frame --- bool success string status_message 특정 srv 타입에 대한 자세한 정보는 다음과 같이 조회할 수 있습니다. $ rosservice info /gazebo/spawn_urdf_model Node: /gazebo URI: rosrpc://192.168.55.236:55405 Type: gazebo_msgs/SpawnModel Args: model_name model_xml robot_namespace initial_pose reference_frame gazebo_ros에서 제공하는 다양한 service들이 있습니다. rosservice 커멘드를 사용하여 조회해보고 여러분들만의 Application을 생각해 보세요.\nService Server 예제 실행 - 긴급 정지 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_service_pkg emergency_stop.py # Terminal 3 rqt 두번째 Node 실행 시, 로봇이 원을 그리며 움직이기 시작합니다. 세번째 명령어를 통해 등장하는 rqt는 아래와 같이 사용 가능합니다. 로봇에게 긴급 정지 명령을 내려보겠습니다. 실제 로봇 개발시에도 Service는 이렇게 단발성이고, 빠르게 실행되어야 하는 동작에 주로 사용됩니다. 더불어, 지금 실행한 예시가 Service Server임을 다시 한 번 상기시켜드립니다.\nimage from : rsl.eth\n코드를 분석해 봅시다.\npy_service_pkg/scripts/emergency_stop.py from geometry_msgs.msg import Twist from std_srvs.srv import SetBool, SetBoolResponse 이번에 사용하는 데이터 타입은 크게 2 종류입니다.\n로봇 제어 topic에 사용되는 Twist 긴급 정지 service에 사용될 SetBool image from : docs.ros.org\nSetBoolResponse이라는 것은 SetBool srv 중 response 부분에 해당합니다. 기본 데이터 타입 이름 + Response를 붙여주기만 하면 사용 가능합니다.\nROS의 msg, srv는 다양한 언어와 상황을 고려하도록 만들어져 있으며, ROS 2에서는 IDL이라는 이름으로 더욱 발전하였습니다. 이후의 커스텀 데이터 타입 제작을 통해 이 과정을 다시 살펴봅시다.\n다음으로 통신 메커니즘을 생성합니다. class EmergencyStopNode(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;emergency_stop\u0026#34;, SetBool, self.stop_cb) 로봇 제어를 위한 topic publisher와 service server를 생성합니다.\nrospy.Service()를 통해 Service Server를 생성할 수 있으며 다음과 같은 매개변수를 필요로합니다.\nService 이름 srv 타입 Client로부터 request가 올 시 실행되는 callback 함수 callback 함수는 일전 subscriber에서 살펴본 바 있습니다. service server의 callback 함수는 항상 매개변수로 request srv를 받습니다. 그리고 return 값은 항상 response가 됩니다.\ndef stop_cb(self, request): ... return self.response_ request 데이터 중 boolean 값을 갖는 data의 true / false 여부에 따라 로봇의 정지 여부가 결정됩니다. if request.data is True: self.twist_msg_.linear.x = 0.0 self.twist_msg_.angular.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) self.response_.success = True self.response_.message = \u0026#34;Successfully Stopped\u0026#34; else: self.response_.success = False self.response_.message = \u0026#34;Stop Failed\u0026#34; 마지막에 사용한 rqt의 service caller는 별도의 프로그래밍이나 복잡한 터미널 명령어 없이도 손쉽게 service를 다룰 수 있게 해주는 ROS의 툴입니다.\n지금까지 ROS Service에 대해 배워보았습니다. Topic과 더불어 많이 사용되는 통신 메커니즘이므로 잘 숙지하고 복습하시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ko.wikipedia.org/wiki/아르키메데스_와선 https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/Services "
},
{
	"uri": "/kr/ros_basic_noetic/lecture7/",
	"title": "Lecture7 - Rqt Tools and rosbag, ROS Time",
	"tags": [],
	"description": "",
	"content": " 강의 초반, 다양한 rqt tool들을 살펴본 바 있습니다. 이제는 Topic과 Service에 모두 익숙해졌기 때문에, rqt의 많은 기능들을 사용할 수 있습니다. 다시 한 번 rqt를 살펴보면서 편리한 툴들의 사용법을 익혀봅시다.\nMessage Publisher \u0026amp; Topic Monitor 강의자를 따라 다음과 같이 화면을 구성합니다.\nplugins ⇒ topics ⇒ Message Publisher pulgins ⇒ topics ⇒ Topic Monitor message publisher를 사용하면 코딩 없이 cmd_vel을 publish가 가능합니다. Topic Msg에 원하는 데이터를 채워넣은 뒤, 주기를 선택한 후 체크박스를 클릭하면 로봇이 움직이기 시작합니다. Topic Monitor를 사용하면, 여러 데이터들을 효과적으로 모니터링 가능합니다. Topic Publisher와 동일하게 체크박스를 눌러 topic을 선택한 뒤, 변하는 데이터를 확인해봅시다. 코딩 없이 간단히 값의 확인과 동작 여부를 확인할 수 있는 툴들이었습니다.\nRQT Multiplot 수치 데이터를 그래프로 보고싶은 경우 rqt의 multiplot이 유용하게 사용됩니다.\nsudo apt install ros-noetic-rqt-multiplot rosrun rqt_multiplot rqt_multiplot /odom topic의 X,Y position을 기준으로 그래프를 그려보도록 하겠습니다. 아래의 gif를 통해 모든 과정을 기록하였으니 차근차근 따라와주세요.\nRQT Console 지금까지 ROS의 콘솔 로그를 위해 rospy.loginfo()를 사용하였습니다. 사실 ROS에는 loginfo말고도 다양한 level의 logger level이 존재합니다. 실습을 통해 살펴봅시다.\nrospy logger level # Terminal 1 roscore # Terminal 2 rosrun my_first_package logger_level.py 코드의 내용과 함께 예시를 살펴봅시다. def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.logdebug(hello_du) rospy.loginfo(hello_du) rospy.logwarn(hello_du) rospy.logerr(hello_du) rospy.logfatal(hello_du) self.counter_ += 1 ROS는 총 5가지의 logger level을 갖추고 있으며, Debug 부터 Fatal로 갈수록 더 높은 level을 갖는다고 보시면 됩니다. Info level 부터 콘솔 출력이 이루어지며, Python의 stdout를 사용합니다.\nimage from : 51CTO 상황에 따라 각기 다른 level의 log를 사용하도록 하면, 실제 로봇 개발시에도 큰 도움이 됩니다.\nrqt에는 이러한 다양한 level을 갖는 ros의 log를 필터링하는 rqt console이라는 툴이 있습니다. 사용 방법을 함께 알아봅시다.\n그 밖에도 수많은 rqt 도구들이 있지만, 모두 살펴보는 대신 링크로 대체하겠습니다. \u0026gt; ROS Wiki\nROS Bags rqt 툴에 속하지는 않지만, 개발 시 매우 유용한 ROS의 기능을 하나 더 소개시켜드리고자 합니다.\nrosbag은 프로그램 동작 중 발생하는 message 데이터를 기록하고 복기할 수 있게 해주는 툴입니다. 로봇 알고리즘을 개발할 때, 같은 상황에 대해 성능을 비교하는 경우, 혹은 교육 목적으로 데이터셋을 제공하는 경우 등에 매우 유용하게 사용할 수 있습니다.\nrosbag 사용법을 함께 실습해보겠습니다.\nsmb gazebo를 실행합니다. roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school rosbag의 사용 시 여러 옵션들이 있습니다. -o 옵션으로 rosbag의 이름을 지정합니다. -a 옵션 사용 시 모든 topic을 저장합니다. rosbag의 종료는 ctrl + c를 사용합니다. rosbag record -o first_rosbag /scan /tf /tf_static /tf와 /tf_static은 왜 저장하는 것일까요? 생각해봅시다.\nrosbag info를 통해 저장을 마친 rosbag의 정보를 조회할 수 있습니다. $ rosbag info first_rosbag_\u0026lt;time-format-sth\u0026gt;.bag path: first_rosbag_2022-12-27-15-51-55.bag version: 2.0 duration: 4.8s start: Jan 01 1970 09:07:35.31 (455.31) end: Jan 01 1970 09:07:40.12 (460.12) size: 83.8 KB messages: 49 compression: none [1/1 chunks] types: sensor_msgs/LaserScan [90c7ef2dc6895d81024acba2ac42f369] topics: /scan 49 msgs : sensor_msgs/LaserScan 저장 완료된 rosbag을 다시 복기해봅시다. $ rosbag play first_rosbag_2022-12-27-15-56-23.bag [ INFO] [1672124296.822088842]: Opening first_rosbag_2022-12-27-15-56-23.bag Waiting 0.2 seconds after advertising topics... done. ... rviz를 통해 시각화까지 해봅시다. rosbag은 기본적으로 topic을 저장합니다.\nrviz 화면을 살펴보면 아래와 같은 Warning이 발생할 것입니다. 그런데 이 문구, 익숙하지 않나요?\n[ WARN] [1672124550.336965013]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336981403]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336991753]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.337003964]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.356035553]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame base_link at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356945321]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356960231]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356970561]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.076000 according to authority unknown_publisher ROS Time 일전 강의에서 언급한 바와 같이, 이번 강의에 ROS의 시간 체계에 대해서 다잡고 가고자 합니다.\nrospy.loginfo를 통해 콘솔에 출력되는 시간과 같이 ROS에서 기본적으로 사용되는 시간의 기준은 PC의 Clock입니다. (이를 wall timer라고 부릅니다.) ROS 프로그램은 일정 주기를 갖고 무한히 반복되는 상황이 잦습니다. 이때 사용하는 주기가 정확해야 할 것입니다. 우리는 2023년 00월 00일이라는 시간체계를 사용하지만, Gazebo와 같은 시뮬레이션 툴은 시작되는 시점이 곧 0분 0초가 됩니다. 이러한 시간의 차이로 인해 warning과 error가 빈번하게 발생합니다. 그럼, 실질적으로 ROS에서 시각과 주기, 시간은 어떻게 다루는지 예시와 함께 python 코드를 살펴봅시다.\nros_time.py $ rosrun my_first_package ros_time.py [INFO] [1672127477.793024]: Current time 1672127477 792964935 [INFO] [1672127477.793593]: Current time to_sec 1672127477 [INFO] [1672127477.794082]: Past time 1672127477 292964935 [INFO] [1672127477.893132]: Current time 1672127477 893082141 [INFO] [1672127477.893684]: Current time to_sec 1672127477 [INFO] [1672127477.894148]: Past time 1672127477 393082141 ... 코드는 다음 위치에서 확인이 가능합니다. \u0026gt; https://github.com/RB2023ROS/du2023-ros1/blob/main/my_first_package/scripts/ros_time.py\nrospy Time instance rospy에서는 Time이라는 클래스로 시간을 표현합니다. 가장 많이 사용되는 현재 시간은 rospy.Time.now() 로 파악할 수 있으며, 이는 sec와 nsec등의 클래스 변수를 갖고 있습니다.\ndef hello_du(self, event=None): now = rospy.Time.now() seconds = now.to_sec() rospy.loginfo(\u0026#34;Current time %i %i\u0026#34;, now.secs, now.nsecs) rospy.loginfo(\u0026#34;Current time to_sec %i\u0026#34;, seconds) rospy Time Duration 시간 간격을 나타내는 클래스로 Duration이 사용되며, Time 인스턴스와 +,- 연산이 가능합니다.\ndelta = rospy.Duration(0.5) past = now - delta rospy.loginfo(\u0026#34;Past time %i %i\u0026#34;, past.secs, past.nsecs) rospy Rate while loop와 Rate를 사용하여 일정 주기다마 반복되는 구현이 가능합니다. 이때 사용되는 시간 기준은 PC의 Clock입니다.\nr = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): time_ex.hello_du() r.sleep() Topic vs Service and Action 지금까지 ROS의 통신 메커니즘으로 Topic과 Service에 대해 배워보았습니다. 그런데, 사실 ROS의 통신 메커니즘에는 Action이라는 한가지가 더 있습니다.\nAction은 Topic과 Service 모두의 특징을 갖고 있는 진보된 통신 메커니즘입니다. Action은 Feedback이라는 것으로 Goal Request 이후 계속적인 데이터 송수신이 가능합니다. Action은 ROS 2 강의에서 살펴볼 예정으로 어떻게 사용될 수 있을지 한번 고민해보세요.\nimage from : docs.rog.org 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://docs.ros.org/en/foxy/index.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture8/",
	"title": "Lecture8 - Deal with Open Source Projects, Custom Interfaces",
	"tags": [],
	"description": "",
	"content": "Deal with Open Source Projects 이번 시간에는 오픈 소스 프로젝트를 사용하는 방법에 대해 배워보겠습니다. 보다 실질적인 사용 방법을 보여드리기 위해 저 또한 여러분들과 같은 상황에서 처음부터 하나씩 같이 해보겠습니다.\n오늘 데모하고자 하는 로봇 소프트웨어는 드론 시뮬레이션입니다. 지금까지 지상을 움직이는 바퀴 로봇만을 다루었기 때문에 새로운 플렛폼을 동작시켜보고자 합니다.\n항상 시작은 구글링부터!! 검색 결과 원하는 패키지를 찾은 것 같습니다. \u0026gt; https://github.com/RAFALAMAO/hector-quadrotor-noetic 목적에 부합하는 오픈소스를 찾기 위해서 아래와 같은 기본적인 내용을 고려해야 합니다.\n버전 호환성 구체적인 목표에 부합하는지 Star, Fork를 통해 검증된 소스코드임을 확인 Issue를 통해 사용 중 문제가 있지는 않은지 Readme를 따라 package build를 진행하고 최초 실행을 해보겠습니다.\n# Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun hector_ui ui_hector_quad.py 동작에는 문제가 없어보입니다. 그럼 이 프로젝트가 내부적으로 어떻게 구현되어있는지 분석해봅시다.\nrqt_graph 로봇의 위치를 알려주는 topic인 /ground_truth/state와 /ground_truth_to_tf/pose를 파악할 수 있습니다. gazebo에서 물체의 절대적인 위치를 알려주기 때문에 이를 ground truth라고 부르고 있습니다.\n이번에는 조종 프로그램의 소스코드를 확인해봅시다. (hector_quadrotor_noetic/hector_ui/src에 위치하고 있습니다.) #Callback de pose y orientacion simulador def pose_callback(data): x_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.x)) y_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.y)) z_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.z)) def rot_callback(data): z_o.set(\u0026#34;{0:.2f}\u0026#34;.format( math.degrees(quaterionToRads(data)) )) rospy.init_node(\u0026#39;HectorQ_GUI\u0026#39;, anonymous=False) #Subscribers posicionLider_sub = rospy.Subscriber(\u0026#34;/ground_truth/state\u0026#34;, Odometry , pose_callback) orientaLider_sub = rospy.Subscriber(\u0026#34;/ground_truth_to_tf/pose\u0026#34;, PoseStamped , rot_callback) 두 종류의 subscriber가 존재하며 각각 UI의 상태를 업데이트하는 것 같이 보입니다.\n이번에는 launch file을 분석해봅시다 - hector_quadrotor/hector_quadrotor_gazebo/launch/quadrotor_empty_world.launch \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; gazebo_ros의 empty_world.launch, hector_quadrotor_gazebo의 spawn_quadrotor.launch가 실행되며, model이라는 argument를 갖습니다.\nspawn_quadrotor.launch에는 다음과 같은 node들이 실행됩니다.\nspawn_model robot_state_publisher ground_truth_to_tf controller.launch ⇒ controller_spawner 이렇게 rqt 툴들과 코드의 구조를 파헤치면서 전체 구조를 파악할 수 있으며 원하는 부분만을 고치면서 Package를 발전시켜나가는 것입니다.\nlaunch file의 응용을 실습해봅시다. 일전 배워본 husky gazebo와 hector gazebo를 함께 사용해보는 것입니다.\nhusky gazebo 는 다음과 같은 내용을 담고 있었습니다. gazebo_ros를 실행시키고 husky model을 spawn하는 또다른 launch file을 include 하였습니다. \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; default=\u0026#34;worlds/empty.world\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_name)\u0026#34;/\u0026gt; \u0026lt;!-- world_name is wrt GAZEBO_RESOURCE_PATH environment variable --\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/spawn_husky.launch\u0026#34;\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/launch\u0026gt; 그럼, 겹치는 부분을 제외하고 quadrotor_empty_world.launch의 내용을 추가하여 새로운 launch file을 만들어 봅시다. (hetero_spawn.launch 생성) \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 아래와 같은 오류가 발생하네요, 이는 robot_state_publisher node가 중복되기 때문에 발생하는 문제입니다. RLException: roslaunch file contains multiple nodes named [/robot_state_publisher]. Please check all \u0026lt;node\u0026gt; \u0026#39;name\u0026#39; attributes to make sure they are unique. Also check that $(anon id) use different ids. The traceback for the exception was written to the log file 이를 해결하기 위해서, 저는 다른 launch file(spawn_two_quadrotors.launch)을 참고해보았습니다. group 태그를 사용하면 같은 로봇의 중복 선언을 namespace를 통해 구분할 수 있게됩니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;group ns=\u0026#34;uav2\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 이제, hetero_spawn.launch를 최종 수정해봅시다. \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;name\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;tf_prefix\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(arg model)\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;z\u0026#34; value=\u0026#34;1.0\u0026#34; /\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 실행 후 topic을 조회해보면, 아래와 같이 quadrotor의 topic 앞에 namespace가 추가되어 있는 모습이 확인 가능합니다. 여러 로봇을 사용하게 되면 /cmd_vel, /scan등 사용하는 topic의 이름이 중복될 수 있어 namespace를 추가 설정하는 것이 일반적입니다.\n$ rostopic list /clock /cmd_vel /husky_velocity_controller/cmd_vel /husky_velocity_controller/odom /husky_velocity_controller/parameter_descriptions /husky_velocity_controller/parameter_updates /imu/data /odometry/filtered ... /uav1/aerodynamics/wrench /uav1/cmd_vel /uav1/command/motor /uav1/command/twist /uav1/command/wrench /uav1/fix_velocity ... 마지막으로, 로봇을 제어해보면서 이번 세션을 마무리해보겠습니다. gazebo의 world를 바꾸거나, husky가 아닌 smb로 모델을 바꾸는 등 응용 예시들을 직접 해보면서 launch file의 사용에 익숙해지시기 바랍니다.\n# husky 제어 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # quadrotor 제어 rosrun hector_ui ui_hector_quad_leader.py ROS Custom Interfaces ROS에서 기본 제공되는 msg와 srv도 훌륭하지만, 상황에 따라 나만의 custom msg/srv를 사용해야 하는 경우가 있습니다. 이번 시간에는 custom interface를 만들어보고, 사용해보겠습니다.\n드론의 이착륙을 제어하는 srv를 만들어보고자 합니다.\n이륙/착륙을 구분하는 string이 필요할 것이며, 기준은 시간을 사용하고자 합니다. ( ex - 2초간 이륙 ) service request는 성공 여부인 bool type으로 해보겠습니다. custom interface를 만들기 위해 저는 별도의 package를 생성하였습니다. cd ~/catkin_ws/src/du2023-ros1 catkin_create_pkg custom_interfaces package 내부에 msg 혹은 srv라는 폴더를 만들고, custom interface를 정의하는것이 추천됩니다. cd custom_interfaces mkdir srv # QuadrotorControl.srv 생성 string command uint8 seconds --- bool success custom_interfaces package의 package.xml을 수정합니다. \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt; custom_interfaces package의 CMakeLists.txt를 수정합니다. # 1. find_package 수정 find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) # 2. catkin_package 주석 해제 후 수정 catkin_package( ... CATKIN_DEPENDS message_runtime ... ...) # 3. add_service_files에 파일 반영 add_service_files( FILES QuadrotorControl.srv ) # 4. generate_messages 주석 해제 후 수정 generate_messages( DEPENDENCIES std_msgs # Or other packages containing msgs ) custom interface를 빌드하고 생성을 확인해봅시다. $ catkin build custom_interfaces $ rossrv show custom_interfaces/QuadrotorControl string command uint8 seconds --- bool success 지금 생성한 QuadrotorControl은 catkin_ws에서만 사용 가능한 srv라는 점에 유의합니다. 다른 workspace에서는 QuadrotorControl에 대해 알 길이 없습니다.\nCustom Interfaces 사용해보기 작성한 QuadrotorControl를 사용하여 Service Server를 만들어봅시다! 정해진 시간동안 takeoff와 land 움직임을 수행하는 Service입니다. # Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun py_service_pkg quadrotor_custom_srv.py # Terminal 3 rqt 소스 코드는 이 링크에서 확인이 가능합니다.\ncustom_interfaces package에서 QuadrotorControl srv를 import 하며, 로봇의 제어를 위해 Twist msg도 import 하였습니다. import rospy from geometry_msgs.msg import Twist from custom_interfaces.srv import QuadrotorControl, QuadrotorControlResponse Service Server와 Topic Publisher를 생성합시다. class QuadRotorUpDown(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;up_down\u0026#34;, QuadrotorControl, self.up_down_cb) self.twist_msg_ = Twist() self.response_ = QuadrotorControlResponse() rospy.loginfo(\u0026#34;Quadrotor Up-Down Server Started\u0026#34;) callback 함수인 up_down_cb입니다. command가 land/takeoff일 때의 경우를 나누고, 그 이외의 입력은 오류로 판명합니다. def up_down_cb(self, request): if request.command == \u0026#34;land\u0026#34;: self.twist_msg_.linear.z = -0.5 self.response_.success = True elif request.command == \u0026#34;takeoff\u0026#34;: self.twist_msg_.linear.z = 0.5 self.response_.success = True else: rospy.logwarn(\u0026#34;Unknown Command\u0026#34;) self.response_.success = False return self.response_ request의 seconds 시간동안 로봇이 움직여야 할 것이며, 이를 위해 now를 갱신하며 지나간 시간을 계속해서 tracking 합니다. start = rospy.Time.now() now = rospy.Time.now() while (now - start).secs \u0026lt; request.seconds: now = rospy.Time.now() self.cmd_vel_pub_.publish(self.twist_msg_) 모든 동작이 완료된 이후에는 로봇을 다시 정지시킵니다. rospy.loginfo(f\u0026#34;{request.command} done, quadrotor stop\u0026#34;) self.twist_msg_.linear.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) return self.response_ Husky Move Base ROS 1에서 로봇 자율주행을 위해 사용하는 스택을 Move Base라고 지칭합니다. ROS 1 noetic에서 husky 로봇을 통해 Move Base를 실습해보겠습니다.\n예시를 위해 필요한 패키지를 다운받습니다. sudo apt-get install ros-noetic-husky-navigation slam 예시를 실행합니다. # Terminal 1 export HUSKY_LMS1XX_ENABLED=1; roslaunch husky_gazebo husky_playpen.launch # Terminal 2 roslaunch husky_viz view_robot.launch # Terminal 3 roslaunch husky_navigation gmapping_demo.launch 사진과 같은 world와 함께 husky가 등장할 것입니다.\nrviz에서 map topic을 추가합니다. rviz의 2D Nav Goal을 사용하면 로봇을 특정 위치로 이동시킬 수 있습니다. 해당 예시는 slam과 navigation을 동시에 실행하는 예시입니다. rqt_graph를 통해 살펴본 현 상황의 node들과 topic입니다. 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://github.com/RAFALAMAO/hector-quadrotor-noetic https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyMove.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture9/",
	"title": "Lecture9 - ROS TF and Examples",
	"tags": [],
	"description": "",
	"content": " 대부분의 로보틱스 과정들에서 가장 먼저 다루는 것이 바로 좌표계 변환(Transformation) 입니다. 로봇은 수많은 joint와 link로 이루어져 있기 때문에 좌표계를 다루는 일이 매우 빈번합니다.\nROS에서는 TF라는 특수한 형태로 이 좌표계와 시간을 함께 다루고 있습니다. 예시와 설명을 통해 ROS의 TF에 대해 배워봅시다 😊\nimage from : eth robot dynamics lecture notes ROS는 오픈소스이니만큼 사용자들이 원하는 기능들에 맞추어 변화가 빠릅니다. 하지만 이것이 단점이 되는 경우도 있는데, 이전 버전과 최신 버전의 호환성 문제가 종종 발생합니다.\ntf 또한 tf2로 개편되면서 코드의 수정이 있었으며, 이번 강의에서는 tf2를 중심으로 살펴보겠습니다.\nimage from : wiki.ros 예시를 먼저 살펴봅시다.\ntf broadcaster # setup example catkin build py_tf2_tutorial source devel/setup.bash roscore # Terminal 1 rosrun turtlesim turtlesim_node # Terminal 2 rosrun py_tf2_tutorial turtle_tf2_broadcaster.py # Terminal 3 rosrun turtlesim turtle_teleop_key # Terminal 4 rviz rviz를 실행한 뒤 아래와 같이 설정합니다. rviz에서 보이는 세가지 색상의 막대가 바로 tf 입니다.\nx,y,z의 각 축을 각기 다른 색으로 표현하였으며, 연관된 좌표계끼리는 노란 선을 통해 연결한 모습이 보입니다.\nTerminal 1에서 실행시킨 프로그램은 turtlesim이라는 것으로, 2차원 평면에서 거북이 형태의 로봇을 시뮬레이션한 프로그램입니다. 이제, Terminal 3에 커서를 두고 거북이를 움직이면서, rviz와 turtlesim의 변화를 살펴보세요. 거북이를 조종함에 따라 변화하는 rviz 화면을 확인할 수 있습니다.\n전체 코드는 아래 링크에서 확인할 수 있으며, 지금은 필요한 부분만 집중적으로 분석해보겠습니다.\nhttps://github.com/RB2023ROS/du2023-ros1/blob/main/py_tf2_tutorial/scripts/turtle_tf2_broadcaster.py\ntf 또한 하나의 Package입니다. 이에 따라 관련된 python import가 필요합니다. import rospy # Because of transformations import tf_conversions import tf2_ros import geometry_msgs.msg import turtlesim.msg tf의 데이터 송출은 broadcast라고 부릅니다. topic의 publisher와 같이 tf에서는 TransformBroadcaster를 사용하며 sendTransform이라는 메소드를 사용합니다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() ... br.sendTransform(t) TransformBroadcaster가 사용하는 데이터 타입은 geometry_msgs.msg.TransformStamped입니다. 해당 데이터 타입에는 3차원 좌표계에서의 위치, 방향, 그리고 시간이 포함되어 있습니다. image from : docs.ros.org\n해당 데이터 타입에 적절한 값을 채워넣어준 다음, 최종 broadcast가 진행됩니다. 주의할 점으로 쿼터니언 각도 체계를 사용했다는 점입니다. # prepare tf msg t = geometry_msgs.msg.TransformStamped() t.header.stamp = rospy.Time.now() t.header.frame_id = \u0026#34;world\u0026#34; t.child_frame_id = turtlename t.transform.translation.x = msg.x t.transform.translation.y = msg.y t.transform.translation.z = 0.0 q = tf_conversions.transformations.quaternion_from_euler(0, 0, msg.theta) t.transform.rotation.x = q[0] t.transform.rotation.y = q[1] t.transform.rotation.z = q[2] t.transform.rotation.w = q[3] 쿼터니언은 직관적으로 이해하기는 힘든 각도 체계입니다. 계산의 편의를 위해 다음과 같은 사이트를 사용할 수 있습니다. \u0026gt; 3D Rotation Converter\ntf의 사용 시 주의해야 할 점을 언급하고자 합니다.\nturtle_tf2_broadcaster.py 수정 - Experiment라고 되어 있는 부분을 주석 해제한 다음 다시 실행해봅시다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() # prepare tf msg t = geometry_msgs.msg.TransformStamped() # t.header.stamp = rospy.Time.now() # Experiment, Late tf2 t.header.stamp = rospy.Time.now() - rospy.Duration(60) t.header.frame_id = \u0026#34;world\u0026#34; rviz를 실행시킨 터미널에서 아래와 같은 에러가 발생합니다. [ WARN] [1671940248.738235698]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame turtle1 at time 1671940148.738096 according to authority unknown_publisher tf에는 시간 데이터가 포함되어 있습니다. 따라서 현재 시간과 tf에 담기 시간의 차이가 크다면 ROS는 이를 안정적이지 못한 것으로 판단해 무시합니다. (위 에러는 아마 로봇 개발을 하면서 마주치게 되는 Warning Top3안에 들지 않을까 싶습니다.)\n이번 예시에는 터미널이 4개나 필요하였습니다. 예시의 빠른 실행을 위해 launch file을 만들 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find py_tf2_tutorial)/rviz/turtlesim_tf.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; tf listener tf broadcaster의 다음으로 tf listener에 대해 배워봅시다.\nturtlesim follow demo roslaunch py_tf2_tutorial follow_demo.launch 사진과 같이 우리가 조종하는 첫번째 거북이를 두번째 거북이가 따라오게 됩니다. rviz를 통해 tf들 사이에 어떠한 변화가 있는지도 직접 확인해보세요 launch 파일은 다음과 같은 내용을 포함하고 있습니다.\n\u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;turtle2_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle2\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_listener.py\u0026#34; name=\u0026#34;listener\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; turtlesim 실행 teleop key 실행 turtle1의 tf broadcaster turtle2의 tf broadcaster tf listener 이번 예제에서 살펴보고자 하는 것은 tf listener입니다.\nTransformListener 클래스는 생성되는 순간부터 /tf topic에 귀기울이기 시작합니다. Buffer는 정해진 사이즈만큼 tf 데이터를 품게 되며, TransformListener에 전달하게 되면, tf topic data를 받아 Buffer에 쌓아두는 것입니다. if __name__ == \u0026#39;__main__\u0026#39;: rospy.init_node(\u0026#39;tf2_turtle_listener\u0026#39;) tfBuffer = tf2_ros.Buffer() listener = tf2_ros.TransformListener(tfBuffer) Buffer의 lookup_transform 메소드는 두 frame 사이의 translation, rotation 변환을 계산해줍니다. while not rospy.is_shutdown(): try: # calculate transformation btw two dynamic tfs # those tfs were broadcasted from TransformBroadcaster trans = tfBuffer.lookup_transform(turtle_name, \u0026#39;turtle1\u0026#39;, rospy.Time(), rospy.Duration(1.0)) except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException): rate.sleep() continue lookup_transform 메소드의 원형은 다음과 같습니다. image from : docs.ros2.org lookup_transform의 계산 결과를 직접 살펴보고자 print 문을 추가하였으며, 캡쳐 사진을 통해 간단히 함께 살펴봅시다.\ntranslation은 두 거북이의 frame사이 수평 거리를 보여주며 rotation은 두 frame사이 회전을 쿼터니언으로 보여줍니다. 기준이 되는 frame과 목표 frame은 id로 구분하며, 현재 turtle1, turtle2로 구분하고 있습니다. 현 상황을 그림으로 간단히 정리하자면 다음과 같습니다.\nlookup_transform의 계산 결과는 target frame인 turtle2의 위치가 source frame인 turtle1 기준에서는 어떠한 좌표를 갖는지를 포함합니다.\nimage from : CMU Qatar 로보틱스에서 이러한 좌표 변환은 매우 자주 사용되며, 일반적으로 Homogeneous Matrix의 형태로 표현합니다.\nfrom : eth robotics lecture notes 그 밖에, 코드에서 구현된 기능을 간단히 살펴보며 마무리하겠습니다.\n두번째 거북이를 등장시키는 service client # Spawn second turtle rospy.wait_for_service(\u0026#39;spawn\u0026#39;) spawner = rospy.ServiceProxy(\u0026#39;spawn\u0026#39;, turtlesim.srv.Spawn) turtle_name = rospy.get_param(\u0026#39;turtle\u0026#39;, \u0026#39;turtle2\u0026#39;) spawner(4, 2, 0, turtle_name) 거북이를 제어하기 위한 Twist msg topic publisher # turtle2 controller turtle_vel = rospy.Publisher(\u0026#39;%s/cmd_vel\u0026#39; % turtle_name, geometry_msgs.msg.Twist, queue_size=1) rate = rospy.Rate(50.0) while not rospy.is_shutdown(): ... turtle_vel.publish(msg) rate.sleep() 이렇게 tf에 대해서 turtlesim 예시와 함께 살펴보았습니다. 로보틱스에서 자주 사용되는 좌표계와 그들 사이의 변환을 시간 데이터와 함께 표현하는 것이 ROS의 tf2입니다.\n다음 강의에 계속 이어집니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture10/",
	"title": "Lecture10 - TF2 Examples, Outro",
	"tags": [],
	"description": "",
	"content": "tf2 사례 제가 강조해서 자꾸 좌표계가 tf가 중요하다고 말하고 있는데, 그 이유를 예시와 함께 좀 더 자세히 살펴보고자 합니다.\nhusky slam # 예시 종속성 설치 sudo apt install ros-noetic-slam-gmapping # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 roslaunch py_tf2_tutorial slam_gmapping.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # [option] rviz (이전 예시에서 rviz를 추가하였다면 넘어가셔도 좋습니다.) rviz rviz를 다음과 같이 세팅합니다. 이제 teleop을 통해 로봇을 이동시키면서, rviz 화면의 변화를 확인해봅시다. 로봇이 움직이면서 자신의 위치를 파악함과 동시에 지도를 생성하는 예시입니다.\n마지막으로, rqt를 실행하여 tf tree를 실행시킵니다. tf tree는 tf 관련 상태를 시각화하여 한번에 볼 수 있게 해주는 고마운 툴입니다. tree를 확대해서 살펴보자면, slam_gmapping은 map → odom으로의 tf broadcast를 담당하고 있습니다. 더불어 map은 모든 tf의 최상단에 존재하고 있습니다. 이러한 이유로 rviz에서 fixed frame을 map으로 설정한 것입니다. 퀴즈: 만약 tf tree가 온전히 연결되어 있지 않다면 어떤 일이 발생할까요?\nimage from : answers.ros.org 센서 입장에서도 tf는 매우 중요합니다.\n같은 데이터라도 그 기준이 어딘지에 따라서 전혀 다른 의미를 가질 수 있기 때문입니다.\n예를 들어, 라이다의 tf를 180도 반대로 설정해버리면 후방에 있는 장애물을 전방 장애물로 잘못 인식할 수 있습니다.\nimage from : answers.ros.org 더불어, 로봇 팔과 같은 관절로봇에게도 tf는 무척 중요한 의미를 갖습니다. 각 joint의 상태를 통해 tf를 계산하고 이를 통해 최종적으로 로봇 팔의 끝점이 어디에 위치하는지 계산할 수 있습니다.\nMoveIt! 실습해보기 이번 시간에는 조금 쉬어가는 느낌으로 유용한 ROS Package를 소개해드리고자 합니다.\nimage from : moveit github MoveIt은 다관절 로봇의 모션 제어를 위한 프레임워크입니다. 이름만 들어서는 감이 잘 오지 않지요? 간단한 예시를 통해 살펴봅시다.\n우리 인간은 팔을 이용하여 물건을 잡는 것이 매우 쉽고 간단하지만, 사실 이는 기구학적으로, 동역학적으로, 에너지 차원에서 매우 최적화된 움직임입니다. 로봇 팔의 경우 장착된 모터의 방향각이 제한된 경우도 있고, 자기 자신과 얽혀버리는 문제도 발생할 수 있으며, 같은 목표를 갖더라고 다양한 경로로 움직일 수 있기 때문에 최적의 경로에 대한 기준도 고려해야 합니다. image from : mecademic 로봇 팔의 주요 구성 Base : 고정된 지지부 Arm : 실질적인 로봇 팔 End Effector : Arm 끝에 부착되는 기구의 통칭, 일반적으로 물체를 잡고 놓는 동작을 수행 MoveIt은 관절 로봇의 기본 구성과 Mass Matrix, 각 모터의 제한과 원하는 움직임을 지정해주면 이에 따라 각 관절의 위치, 속도, 가속도 경로를 최적화(Planning) 해주는 프레임워크이며, 그 밖에도, 물체 인지, 장애물 회피, End Effector에 가해지는 힘까지 고려 가능한 거대한 오픈소스 프로젝트입니다.\nMoveIt Motion Planning Framework\n이번 예제로 저와 함께 MoveIt의 가장 기본적인 데모를 함께 실행해보겠습니다. 예시에 사용되는 로봇은 FRANKA EMIKA의 PANDA라는 로봇입니다. FRANKA EMIKA - PANDA\n아래 커멘드 라인을 함께 따라와주세요.\napt 패키지 설치 sudo apt install ros-noetic-moveit-setup-assistant sudo apt install ros-noetic-moveit sudo apt install ros-noetic-gazebo-ros-control joint-state-publisher sudo apt install ros-noetic-controller-manager sudo apt install ros-noetic-ros-controllers sudo apt install ros-noetic-ros-control sudo apt install ros-noetic-robot-state-publisher 예제 패키지 Clone cd ~/catkin_ws git clone https://github.com/ros-planning/moveit_tutorials.git -b master git clone https://github.com/ros-planning/panda_moveit_config.git -b noetic-devel 관련 종속성 설치 - rosdep 추가 설명 cd ~/catkin_ws/src rosdep install -y --from-paths . --ignore-src --rosdistro noetic 패키지 빌드 cd ~/catkin_ws catkin build source devel/setup.bash 데모 실행 roslaunch panda_moveit_config demo_gazebo.launch 여기까지 잘 따라오셨나요? 그렇다면 강의자의 설명에 따라 RViz Motion Planning Plugin을 사용해봅니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ros-planning.github.io/moveit_tutorials/ http://wiki.ros.org/tf/Tutorials "
},
{
	"uri": "/kr/advanced_contents_ros1/lecture1/",
	"title": "Lecture1 - ROSCPP",
	"tags": [],
	"description": "",
	"content": "roscpp Programming ros는 다양한 언어를 지원하고 있습니다. 지금까지 살펴보았던 rospy는 가장 쉽고 빠르게 배울 수 있어서 사용하였지만, UDPROS, Nodelet, Plugin과 같은 Advanced ROS 개발을 위해서는 C++ 프로그래밍을 통한 Node 개발이 필요합니다.\nimage from : wikipedia rospy를 통해 개념을 모두 익혔기 때문에 이번 강의에서는 개발 API를 위주로 roscpp을 배워보겠습니다.\n가장 기초가 되는 Node 프로그래밍부터 차이점을 살펴봅시다. rospy roscpp #!/usr/bin/env python3 import rospy from std_msgs.msg import String def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # ROS safe timer rate = rospy.Rate(10) # 10hz # Loop control Example while not rospy.is_shutdown(): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. rate.sleep() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;std_msgs/String.h\u0026gt; int main(int argc, char** argv){ ros::init(argc, argv, \u0026#34;basic_node\u0026#34;); ros::NodeHandle nh; ros::Rate r(5); while ( ros::ok() ) { ROS_INFO(\u0026#34;This is Basic Node\u0026#34;); // ros::spinOnce(); r.sleep(); } return 0; } 간단히 표를 통해 비교해보면 아래와 같이 상당 부분 반복되는 점들을 확인할 수 있습니다.\nrospy roscpp Client Library import rospy #include \u0026lt;ros/ros.h\u0026gt; initialization rospy.init_node ros::init interface import from std_msgs.msg import String #include \u0026lt;std_msgs/String.h\u0026gt; logging rospy.loginfo() ROS_INFO() spin rospy.spin() ros::spin() rate rospy.Rate() ros::Rate() rospy와의 차이점으로, roscpp은 NodeHandle이라는 클래스를 사용합니다. roscpp은 NodeHandle을 통해 parameter, publisher, subscriber, serviceServer들을 생성하며, 매개변수로 namespace를 받습니다.\ncmd_vel_pub 예시코드에 namespace를 설정한 뒤 topic값의 변화를 살펴봅시다.\nros::NodeHandle nh(\u0026#34;my_namespace\u0026#34;); 더불어, NodeHandle은 ROS Node lifecycle 중 “start”의 트리거가 됩니다. Node의 Lifecycle에 대한 자세한 설명은 링크로 대체하겠습니다.\nimage from : Initialization and Shutdown NodeHandle은 반드시 ros::init 보다 뒤에 생성되어야 합니다\nROS C++ Package Build C++로 작성된 코드는 빌드가 필요하며 caktin 시스템에서는 CMake가 빌드를 도와줍니다.\n빌드 시에 필요한 공유 라이브러리, 외부 라이브러리들, 빌드 속성과 같은 상세 내용들이 CMakeLists.txt에 위치합니다.\n본 강의에서는 CMake에 대해서는 자세히 다루지 않고, 프로그래밍 시 알아야 하는 부분만 살펴보겠습니다.\nfind_package - ROS에서 기본 제공하는 패키지들을 손쉽게 추가할 수 있습니다. ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages find_package(catkin REQUIRED COMPONENTS roscpp geometry_msgs sensor_msgs ) 컴파일 옵션 - add_executable과 add_dependencies를 적용하고, 빌드 결과가 위치하는 지점을 catkin workspace의 build 폴더로 지정해야 합니다. ## Declare a C++ executable ## With catkin_make all packages are built within a single CMake context ## The recommended prefix ensures that target names across packages don\u0026#39;t collide add_executable(cmd_vel_pub_node src/cmdvel_pub.cpp) add_executable(laser_sub_node src/laser_sub.cpp) ... add_dependencies(cmd_vel_pub_node ${cmd_vel_pub_node_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) add_dependencies(laser_sub_node ${laser_sub_node_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) ... target_link_libraries(cmd_vel_pub_node ${catkin_LIBRARIES} ) target_link_libraries(laser_sub_node ${catkin_LIBRARIES} ) 이후 catkin build와 실행은 rospy와 동일합니다. (executable name에 주의합니다.) catkin build \u0026lt;pkg-name\u0026gt; source devel/setup.bash rosrun \u0026lt;pkg-name\u0026gt; \u0026lt;executable-name\u0026gt; roscpp Topic roscpp의 예시들은 rospy와 동일한 기능을 하도록 작성하였습니다. 코드의 API에 집중하여 비교, 분석해보겠습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Example 1 rosrun cpp_topic_pkg cmd_vel_pub # Example 2 rosrun cpp_topic_pkg laser_scan_sub cmd_vel_pub code python c\u0026#43;\u0026#43; #!/usr/bin/env python3 import rospy from geometry_msgs.msg import Twist class CmdVelPubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. topic queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) self.twist_ = Twist() def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) def cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: cmd_vel_node() except rospy.ROSInterruptException: pass #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;geometry_msgs/Twist.h\u0026gt; class CmdVelPubNode { private: ros::Publisher cmd_vel_pub_; ros::Timer timer_; geometry_msgs::Twist twist_msg_; public: CmdVelPubNode(ros::NodeHandle *nh) { ROS_INFO(\u0026#34;Publisher and Subscriber initialized\u0026#34;); timer_ = nh-\u0026gt;createTimer(ros::Duration(0.1), \u0026amp;CmdVelPubNode::timerCallback, this); cmd_vel_pub_ = nh-\u0026gt;advertise\u0026lt;geometry_msgs::Twist\u0026gt;(\u0026#34;cmd_vel\u0026#34;, 10); } void timerCallback(const ros::TimerEvent\u0026amp; event){ twist_msg_.linear.x = 0.5; twist_msg_.angular.z = 0.5; cmd_vel_pub_.publish(twist_msg_); } }; int main(int argv, char** argc) { ros::init(argv, argc, \u0026#34;cmd_vel_node\u0026#34;); // ros::NodeHandle nh(\u0026#34;my_namespace\u0026#34;); ros::NodeHandle nh; CmdVelPubNode cmd_pub_node(\u0026amp;nh); ros::spin(); return 0; } laser_scan_sub code python c\u0026#43;\u0026#43; #!/usr/bin/env python3 import rospy from sensor_msgs.msg import LaserScan class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) def laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: laser_sub_node() except rospy.ROSInterruptException: pass #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;geometry_msgs/Twist.h\u0026gt; #include \u0026lt;sensor_msgs/LaserScan.h\u0026gt; class LaserSubNode { private: ros::Subscriber laser_sub_; ros::Timer timer_; public: LaserSubNode(ros::NodeHandle *nh) { ROS_INFO(\u0026#34;Publisher and Subscriber initialized\u0026#34;); // TCPROS // laser_sub_ = nh-\u0026gt;subscribe(\u0026#34;scan\u0026#34;, 10, \u0026amp;LaserSubNode::laserSubCallback, this); // UDPROS laser_sub_ = nh-\u0026gt;subscribe(\u0026#34;scan\u0026#34;, 10, \u0026amp;LaserSubNode::laserSubCallback, this, ros::TransportHints() .unreliable() .reliable() .maxDatagramSize(1000) .tcpNoDelay() ); } void laserSubCallback(const sensor_msgs::LaserScanConstPtr data){ ROS_INFO_STREAM(\u0026#34;data.ranges[0]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[0]); ROS_INFO_STREAM(\u0026#34;data.ranges[90]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[90]); ROS_INFO_STREAM(\u0026#34;data.ranges[179]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[179]); ROS_INFO_STREAM(\u0026#34;data.ranges[270]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[270]); ROS_INFO_STREAM(\u0026#34;data.ranges[360]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[360]); // std::cout \u0026lt;\u0026lt; std::to_string(data.ranges[0]) \u0026lt;\u0026lt; std::endl; ROS_INFO(\u0026#34;Publisher and Subscriber initialized\u0026#34;); } }; int main(int argv, char** argc) { ros::init(argv, argc, \u0026#34;laser_sub_node\u0026#34;); // ros::NodeHandle nh(\u0026#34;my_namespace\u0026#34;); ros::NodeHandle nh; LaserSubNode laser_sub_node(\u0026amp;nh); ros::spin(); return 0; } rospy roscpp Publisher rospy.Publisher(topic_name, Message-Type, queue_size) advertise(topic_name, queue_size) Subscriber rospy.Subscriber(topic_name, Message-Type, callback) subscribe(topic_name, queue_size, callback) C++로 OOP 코드 작성 시, boost를 통한 binding이 필요함에 유의합니다. CmdVelPubNode(ros::NodeHandle *nh) { ROS_INFO(\u0026#34;Publisher and Subscriber initialized\u0026#34;); timer_ = nh-\u0026gt;createTimer(ros::Duration(0.1), \u0026amp;CmdVelPubNode::timerCallback, this); cmd_vel_pub_ = nh-\u0026gt;advertise\u0026lt;geometry_msgs::Twist\u0026gt;(\u0026#34;cmd_vel\u0026#34;, 10); } 파이썬과 마찬가지로 sub callback의 첫번째 매개변수는 topic msg data이며, std::shared_ptr가 사용됩니다. void sub_callback(const sensor_msgs::LaserScanConstPtr \u0026amp;data ){ ROS_INFO_STREAM(\u0026#34;data.ranges[0]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[0]); } roscpp에서는 Logger 사용 시 c_str 포멧으로 변환해줘야 한다는 단점이 있습니다. 이를 간편하게 하기 위해 저는 ROS_INFO_STREAM를 애용합니다. ROS_INFO_STREAM(\u0026#34;data.ranges[0]: \u0026#34; \u0026lt;\u0026lt; data-\u0026gt;ranges[0]); ROSUDP ROS Topic 통신을 위해 Publisher와 Subscriber간의 negotiation이 이루어지며, 이 시점에서 Subscriber에 의해 TCP/UDPROS 중 어떠한 통신이 사용될 지 결정됩니다. Subscriber 코드를 수정하여 UDPROS를 사용해봅시다.\nsubscribe 예시를 다음과 같이 수정하고 빌드 후 다시 실행시켜봅시다. laser_sub_ = nh-\u0026gt;subscribe(\u0026#34;scan\u0026#34;, 10, \u0026amp;LaserSubNode::laserSubCallback, this, ros::TransportHints() .unreliable() .reliable() .maxDatagramSize(1000) .tcpNoDelay() ); 위 코드에서, unreliable은 UDPROS를, reliable은 TCPROS를 뜻합니다. UDPROS를 사용하는 경우, maxDatagramSize를 지정할 수 있으며, TCPROS를 사용하는 경우 tcpNoDelay를 사용 가능합니다. 위 코드는 UDPROS 통신을 먼저 시도한 뒤, 응답이 없다면 TCPROS를 사용하게 됩니다.\n이 같은 설정에 대한 상세 내용은 링크를 확인합시다. ⇒ 참고링크 : ros::TransportHints Class Reference\n소스코드 빌드 후 다시 실행 catkin build cpp_topic_pkg source devel/setup.bash rosrun cpp_topic_pkg laser_scan_sub rosnode info를 통해 transport 상태를 확인합니다. ⇒ UDPROS를 사용하고 있음을 알 수 있습니다. $ rosnode info /laser_sub_node -------------------------------------------------------------------------------- ... * topic: /scan * to: /pointcloud_to_laserscan (http://192.168.55.236:39875/) * direction: inbound * transport: UDPROS roscpp Service service 예시들도 rospy와 동일한 기능을 갖습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Example 1 rosrun cpp_service_pkg emergency_stop # Example 2 rosrun cpp_service_pkg spawn_model_client emergency_stop code python c\u0026#43;\u0026#43; #! /usr/bin/env python3 import rospy from roslaunch.pmon import start_process_monitor from geometry_msgs.msg import Twist from std_srvs.srv import SetBool, SetBoolResponse class EmergencyStopNode(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;emergency_stop\u0026#34;, SetBool, self.stop_cb) self.pm_ = start_process_monitor() self.twist_msg_ = Twist() self.response_ = SetBoolResponse() rospy.loginfo(\u0026#34;E Stop Server Started\u0026#34;) self.twist_pub() rospy.sleep(0.1) def twist_pub(self): self.twist_msg_.linear.x = 0.5 self.twist_msg_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_msg_) def stop_cb(self, request): if request.data is True: self.twist_msg_.linear.x = 0.0 self.twist_msg_.angular.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) self.response_.success = True self.response_.message = \u0026#34;Successfully Stopped\u0026#34; else: self.response_.success = False self.response_.message = \u0026#34;Stop Failed\u0026#34; return self.response_ def main(): rospy.init_node(\u0026#34;emergency_stop_node\u0026#34;) e_stop_node = EmergencyStopNode() rospy.sleep(1.0) e_stop_node.twist_pub() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: main() except rospy.ROSInterruptException: pass #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;std_srvs/SetBool.h\u0026gt; #include \u0026lt;geometry_msgs/Twist.h\u0026gt; using SetBool = std_srvs::SetBool; class EmergencyStopNode { private: ros::ServiceServer service_; ros::Publisher cmd_vel_pub_; geometry_msgs::Twist twist_msg_; public: EmergencyStopNode(ros::NodeHandle *nh){ service_ = nh-\u0026gt;advertiseService(\u0026#34;emergency_stop\u0026#34;, \u0026amp;EmergencyStopNode::eStopCallback, this); cmd_vel_pub_ = nh-\u0026gt;advertise\u0026lt;geometry_msgs::Twist\u0026gt;(\u0026#34;cmd_vel\u0026#34;, 10); ROS_INFO_STREAM(\u0026#34;EmergencyStopNode Started\u0026#34;); } void moveRobot(){ twist_msg_.linear.x = 0.5; twist_msg_.angular.z = 1.0; cmd_vel_pub_.publish(twist_msg_); } bool eStopCallback(SetBool::Request \u0026amp;req, SetBool::Response \u0026amp;res){ if(req.data == true){ twist_msg_.linear.x = 0.0; twist_msg_.angular.z = 0.0; cmd_vel_pub_.publish(twist_msg_); res.success = true; res.message = \u0026#34;Successfully Stopped\u0026#34;; return true; } else { res.success = false; res.message = \u0026#34;Stop Failed\u0026#34;; return false; } } }; int main(int argc, char **argv) { ros::init(argc, argv, \u0026#34;emergency_stop_node\u0026#34;); ros::NodeHandle nh; EmergencyStopNode e_stop_service(\u0026amp;nh); auto start_time = ros::Time::now(); auto cur_time = ros::Time::now(); while( (cur_time - start_time) \u0026lt; ros::Duration(3.0)){ e_stop_service.moveRobot(); cur_time = ros::Time::now(); } ros::spin(); ros::shutdown(); return 0; } spawn_model_client code python c\u0026#43;\u0026#43; #! /usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; referenced from programcreek url : https://www.programcreek.com/python/example/93572/rospkg.RosPack \u0026#34;\u0026#34;\u0026#34; import math import rospy import rospkg from geometry_msgs.msg import Pose from gazebo_msgs.srv import SpawnModel def spawn_helix(): rospy.init_node(\u0026#34;gazebo_spawn_model\u0026#34;) # model_name model_name = \u0026#34;box\u0026#34; # model_xml rospack = rospkg.RosPack() model_path = rospack.get_path(\u0026#34;py_service_pkg\u0026#34;) + \u0026#34;/urdf/\u0026#34; with open(model_path + model_name + \u0026#34;.urdf\u0026#34;, \u0026#34;r\u0026#34;) as xml_file: model_xml = xml_file.read().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) # robot_namespace robot_namespace = \u0026#34;\u0026#34; # initial_pose initial_pose = Pose() initial_pose.position.x = 0.0 initial_pose.position.y = -1 initial_pose.position.z = 0.2 # z rotation -pi/2 to Quaternion initial_pose.orientation.z = -0.707 initial_pose.orientation.w = 0.707 # reference_frame reference_frame = \u0026#34;world\u0026#34; theta = 0.0 spawn_model_prox = rospy.ServiceProxy(\u0026#34;gazebo/spawn_urdf_model\u0026#34;, SpawnModel) for i in range(100): # service call initial_pose.position.x = theta * math.cos(theta) initial_pose.position.y = theta * math.sin(theta) theta += 0.2 entity_name = model_name + str(i) result = spawn_model_prox( entity_name, model_xml, robot_namespace, initial_pose, reference_frame ) \u0026#34;\u0026#34;\u0026#34; result fromat bool success string status_message \u0026#34;\u0026#34;\u0026#34; rospy.loginfo(result) if __name__ == \u0026#39;__main__\u0026#39;: try: spawn_helix() except rospy.ROSInterruptException: pass #include \u0026lt;fstream\u0026gt; // ros.h doesn\u0026#39;t contain this lib #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;ros/package.h\u0026gt; #include \u0026lt;geometry_msgs/Pose.h\u0026gt; #include \u0026lt;gazebo_msgs/SpawnModel.h\u0026gt; void addXml(gazebo_msgs::SpawnModel\u0026amp; model_in, const std::string\u0026amp; file_path ){ std::ifstream file(file_path); std::string line; while (!file.eof()){ std::getline(file, line); model_in.request.model_xml += line; } file.close(); } class SpawnModelClient { private: ros::ServiceClient spawn_model_prox; int model_num_ = 0; double theta_ = 0.0; public: SpawnModelClient(ros::NodeHandle *nh){ spawn_model_prox = nh-\u0026gt;serviceClient\u0026lt;gazebo_msgs::SpawnModel\u0026gt;(\u0026#34;gazebo/spawn_urdf_model\u0026#34;); for(auto i = 0; i \u0026lt; 100; i++){ this-\u0026gt;serviceCall(); } } void serviceCall(){ gazebo_msgs::SpawnModel model; // add roslib in find_package() auto file_path = ros::package::getPath(\u0026#34;cpp_service_pkg\u0026#34;) + \u0026#34;/urdf/box.urdf\u0026#34;; addXml(model, file_path); model.request.model_name = \u0026#34;box\u0026#34; + std::to_string(model_num_++); model.request.reference_frame = \u0026#34;world\u0026#34;; model.request.initial_pose = getPose(); // ServiceClient.call() =\u0026gt; return bool type if (spawn_model_prox.call(model)){ auto response = model.response; ROS_INFO(\u0026#34;%s\u0026#34;, response.status_message.c_str()); // Print the result given by the service called } else { ROS_ERROR(\u0026#34;Failed to call service /trajectory_by_name\u0026#34;); ros::shutdown(); } model_num_++; } geometry_msgs::Pose getPose(){ geometry_msgs::Pose initial_pose; initial_pose.position.x = theta_ * cos(theta_); initial_pose.position.y = theta_ * sin(theta_); theta_ += 0.2; initial_pose.position.z = 0.2; initial_pose.orientation.z = -0.707; initial_pose.orientation.w = 0.707; return initial_pose; } }; int main(int argc, char** argv){ ros::init(argc, argv, \u0026#34;gazebo_spawn_model\u0026#34;); ros::NodeHandle nh; SpawnModelClient spawn_model_client(\u0026amp;nh); ros::shutdown(); return 0; } Service Server와 Client를 생성하는 코드 API 차이를 비교해봅시다. rospy roscpp Server rospy.Service(service_name, srv_type, callback) advertiseService(service_name, srv_type, callback) Client rospy.ServiceProxy(server_name, srv_type) serviceClient\u0026lt;srv_type\u0026gt;(service_name) Time rospy.Time.now() ros::Time::now() rospack rospkg.RosPack().get_path() ros::package::getPath() 실제 로봇 프로그래밍시에는 python보다 c++가 우세하게 사용됩니다. 하지만 우리는 이미 rospy를 통해 통신 메커니즘에 대해 이해하였기 때문에 간단히 짚고 넘어갔으며, 관련된 추가 개발은 강의 노트를 통해 지속 업데이트할 예정입니다.\n참고자료\nhttp://wiki.ros.org/roscpp/Overview/Publishers and Subscribers http://docs.ros.org/ "
},
{
	"uri": "/kr/advanced_contents_ros1/lecture2/",
	"title": "Lecture2 - More About ROS System",
	"tags": [],
	"description": "",
	"content": " ROS Node가 실행되고 Topic 통신이 이루어지기 위해서 Master에게 자신을 등록하고 Master에 의한 Node간 TCPROS / UDPROS 연결이 이루어져야 합니다.\n개념 정리와 예시, 그리고 데모를 통해 ROS의 통신 시스템에 대해 배워봅시다.\nXMLRPC Extensible Markup Language - XML이란, 웹 서비스에서 데이터를 표현하기 위해 사용하는 마크업 언어입니다. (such as HTML), 모든 데이터를 구조화해서 transport하기 때문에 검색과 재사용에 유리합니다. ROS에서 사용하는 launch file도 xml을 사용하고 있으므로 ROS 개발자들에게는 익숙한 문법일 것입니다. image from : xml 파일의 비밀 RPC - remote procedure call 란, 분산 네트워크 환경에서의 프로그래밍을 용이하게 하기 위해 등장한 기술로, 원격에 정의된 함수를 로컬에서 호출하는 식으로 사용이 가능합니다.\nimage from : RPC란? 이 둘을 결합한 XML-RPC는 RPC 기술 과정에서 XML을 사용하는 것입니다. 서버-클라이언트 정보가 XML 문서로 만들어져 응답하게 됩니다.\nXML-RPC Request Format Example - HTTP Header를 포함한 예시이며, /xmlrpc라는 서버에 circleArea라는 method를 request 하는 경우입니다. POST /xmlrpc HTTP 1.0 User-Agent: myXMLRPCClient/1.0 Host: 192.168.124.2 Content-Type: text/xml Content-Length: 169 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;circleArea\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt;\u0026lt;double\u0026gt;2.41\u0026lt;/double\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; XML-RPC Response Format Example - Request와 유사한 구조를 갖지만 methodCall 대신 methodResponse가 사용되며, methodName가 없다는 차이를 갖습니다. Header는 성공, 실패 유무와 상관 없이 200 OK를 반환한다는 점에 유의합니다. HTTP/1.1 200 OK Date: Sat, 06 Oct 2001 23:20:04 GMT Server: Apache.1.3.12 (Unix) Connection: close Content-Type: text/xml Content-Length: 124 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;methodResponse\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt;\u0026lt;double\u0026gt;18.24668429131\u0026lt;/double\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodResponse\u0026gt; ROS는 Topic, Service 통신을 위해 standard TCP/UDP socket에 기반하여 독자적인 Header와 프로토콜을 가진 TCPROS/UDPROS를 만들었습니다. 이들에 대해 하나씩 살펴보겠습니다.\nConnection Header Connection Header는 Node간 통신이 이루어지기 위한 typing, routing 데이터를 포함하고 있으며 TCPROS와 UDPROS 별도 다른 형태를 갖고 있습니다. 공식 문서에서 명확히 밝히고 있는 TCPROS의 Connection Header를 분석해봅시다.\nEncoding Format은 다음과 같습니다. 4-byte length + [4-byte field length + field=value ]* * All length fields are little-endian integers * Field names and values are strings. rostopic pub /chatter std_msgs/String \u0026quot;hello” 에 대한 hex output은 아래와 같습니다. 전체 header 길이 176 바이트 ⇒ (b0 00 00 00, little-endian 사용)\nb0 00 00 00 20 00 00 00 6d 65 73 73 61 67 65 5f 64 65 66 69 6e 69 74 69 6f 6e 3d 73 74 72 69 6e 67 20 64 61 74 61 0a 0a 25 00 00 00 63 61 6c 6c 65 72 69 64 3d 2f 72 6f 73 74 6f 70 69 63 5f 34 37 36 37 5f 31 33 31 36 39 31 32 37 34 31 35 35 37 0a 00 00 00 6c 61 74 63 68 69 6e 67 3d 31 27 00 00 00 6d 64 35 73 75 6d 3d 39 39 32 63 65 38 61 31 36 38 37 63 65 63 38 63 38 62 64 38 38 33 65 63 37 33 63 61 34 31 64 31 0e 00 00 00 74 6f 70 69 63 3d 2f 63 68 61 74 74 65 72 14 00 00 00 74 79 70 65 3d 73 74 64 5f 6d 73 67 73 2f 53 74 72 69 6e 67 09 00 00 00 05 00 00 00 68 65 6c 6c 6f message_definition 필드는 아래와 같이 해석됩니다. - 길이 32 bytes (20 00 00 00) 6d 65 73 73 61 67 65 5f 64 65 66 69 6e 69 74 69 6f 6e 3d 73 74 72 69 6e 67- m e s s a g e _ d e f i n i t i o n = s t r i n g- 20 64 61 74 61 0a 0a d a t a \\n \\n callerid 필드는 아래와 같이 해석됩니다. - 길이 37 bytes (25 00 00 00) 63 61 6c 6c 65 72 69 64 3d 2f 72 6f 73 74 6f 70 69 63 5f 34 37 36 37 5f 31 33- c a l l e r i d = / r o s t o p i c _ 4 7 6 7 _ 1 3- 31 36 39 31 32 37 34 31 35 35 37 1 6 9 1 2 7 4 1 5 5 7 latching 필드는 아래와 같이 해석됩니다. - 길이 10 bytes (0a 00 00 00) 6c 61 74 63 68 69 6e 67 3d 31 l a t c h i n g = 1 md5sum 필드는 아래와 같이 해석됩니다. - 길이 39 bytes (27 00 00 00) 6d 64 35 73 75 6d 3d 39 39 32 63 65 38 61 31 36 38 37 63 65 63 38 63 38 62 64- m d 5 s u m = 9 9 2 c e 8 a 1 6 8 7 c e c 8 c 8 b d- 38 38 33 65 63 37 33 63 61 34 31 64 31 8 8 3 e c 7 3 c a 4 1 d 1 topic 필드는 아래와 같이 해석됩니다. - 길이 14 bytes (0e 00 00 00) 74 6f 70 69 63 3d 2f 63 68 61 74 74 65 72 t o p i c = / c h a t t e r message type 필드는 아래와 같이 해석됩니다. - 길이 20 bytes (14 00 00 00) 74 79 70 65 3d 73 74 64 5f 6d 73 67 73 2f 53 74 72 69 6e 67 t y p e = s t d _ m s g s / S t r i n g hello라는 데이터 response는 5 bytes를 갖고, message body 필드 길이는 9 bytes이며, std_msgs/String 타입을 갖습니다. 09 00 00 00 05 00 00 00 68 65 6c 6c 6f h e l l o 이렇게 Topic response는 특정 필드와 데이터로 구성되어 있습니다.\n사용되는 모든 필드에 대한 데이터는 링크로 대체하겠습니다.\n참고링크 : http://wiki.ros.org/ROS/Connection Header TCPROS TCPROS는 ROS의 Topic, Service 통신 시 Inbound connection으로 TCP 소켓을 사용하는 방식입니다. 일전 살펴본 Connection Header에서와 같이 특정 필드들을 결합하여 Header와 Data를 송수신합니다.\n만약 header가 \u0026rsquo;topic\u0026rsquo; 필드를 포함하고 있다면 ROS Topic 연결로 이루어지고 \u0026lsquo;service\u0026rsquo; 필드를 포함하고 있다면 ROS Service 연결로 이루어지는 방식입니다.\n각각의 필드들에 대한 간략한 나열은 아래와 같습니다. TCPROS subscriber의 Request\nmessage_definition: full text of message definition callerid: subscriber node name topic: name of the topic the subscriber is connecting to md5sum: md5sum of the message type type: message type md5sum 이란? 파일을 다운받거나, 이동하거나, 복사한 후에 원본파일과 동일한 파일인지 확인하는 목적으로 쓰이는 해시 알고리즘입니다. (ex - git의 SHA-1)\nTCPROS publisher의 Response\nmd5sum: md5sum of the message type type: message type TCPROS service client의 Request\ncallerid: node name of service client service: name of the topic the subscriber is connecting to md5sum: md5sum of the message type type: service type optional 필드들\ntcp_nodelay: 이 값이 \u0026lsquo;1\u0026rsquo; 일 시 topic 통신에 TCP_NODELAY 옵션을 적용합니다. latching: latch를 사용하면 마지막으로 메시지가 저장되고 이후 연결 시 이 데이터를 전송합니다. 지도와 같이 정적이고 느린 데이터를 다룰 때 유용합니다. 이 값이 \u0026lsquo;1\u0026rsquo; 이면 publish하는 데이터가 latch라는 것을 의미합니다. persistent: 이 값이 \u0026lsquo;1\u0026rsquo; 일 시, Service Server는 여러 Request에 대응하여 계속 통신을 열어둬야 한다는 것을 의미합니다. error: 통신 실패 시 등장하는 human-readable error message입니다. ok: Service Response에서 사용되는 값으로 이 값이 \u0026lsquo;1\u0026rsquo; 일 시, response가 성공적으로 통신되지만, 이 값이 \u0026lsquo;0\u0026rsquo; 일 시, serialized string 타입의 에러 메세지가 이어집니다. 경우에 따라 return false로 인해 비어있을 수 있습니다. UDPROS UDPROS는 ROS의 Topic, Service 통신 시 Inbound connection으로 UDP 소켓을 사용하는 방식입니다. UDPROS는 standard UDP datagram과 serialized된 message data를 사용하며, 로봇의 제어와 센서 데이터를 다루는 것과 같이 빠른 통신에 사용됩니다.\nUDPROS header format은 아래와 같으며 TCPROS에 비해 훨씬 간단합니다.\n+---------------------------------+ | Connection ID | +---------------------------------+ |Opcode | Msg ID | Block # | +---------------------------------+ Connection ID - 32-bit value로 connection negotiation 중 결정됩니다. Opcode - UDPROS는 여러 datagram type을 지원하는데, 이들을 명시하는 코드입니다. DATA0 (0) - ROS message의 가장 처음에 전송됩니다. DATAN (1) - 첫 전송 이후 계속해서 이 타입이 사용됩니다. PING (2) - heartbeat packet입니다. ERR (3) - 갑작스런 connection 단절 시 사용됩니다. Message ID - 새 메시지가 전송될 때마다 증가되며 데이터가 삭제되었는지 여부를 확인하는 데 사용되는 8비트 값입니다. Block # - opcode가 DATAN인 경우, 현재 datagram 번호가 되며, opcode가 DATA0이 아닌 이상 0을 갖고, 전체 ROS message의 개수를 나타냅니다. 추가 특징\nROS messages는 다수의 Subscriber를 가질 수 있습니다. 첫 datagram은 전체 datagrams의 수를 담게 됩니다. connection negotiation 중 사용할 최대 message per datagram이 결정됩니다. ROS의 통신 시스템 총정리 ROS Master와 Node에 의해 Topic과 Service가 이루어지는 과정을 총정리해봅시다.\nroscore 명령어를 통해 Node간 접속을 주관하고 URI 주소/포트를 등록받는 ROS Master를 구동시킵니다. rosrun 혹은 roslaunch에 의해 Node가 실행됩니다. Subscriber Node가 구동되는 과정에서, Node 자신의 이름, Topic 이름, Message Type, URI 주소와 포트가 주고 받아집니다. 다음으로, Publisher Node가 구동되며 Subscriber와 마찬가지로 Topic 등록을 위해 Master와 각종 데이터를 주고 받습니다. ROS Master가 Subscriber Node에게 Publisher의 정보를 전달하고, 이때, XML-RPC를 이용하여 통신합니다. Subscriber Node는 ROS Master로부터 Publisher의 정보를 받아 해당 Node에게 직접 접속 요청을 합니다. Node 이름, Topic 이름, 방식(TCPROS 또는 UDPROS)과 같은 정보를 XMLRPC 를 이용하여 통신하게 됩니다. Publisher Node는 Subscriber Node에게 접속 응답을 하게 되고, 자신의 TCP 서버의 정보인 URI주소와 포트를 XMLRPC 를 이용하여 전달하게 됩니다. Subscriber Node는 TCPROS를 통해 클라이언트를 만들고, Publisher Node와 직접 연결합니다. 이제부터, Publisher Node는 Subscriber Node에게 정해진 메시지를 전송하게 됩니다. Service의 경우 Topic과 달리 1회성 연결이기 때문에, 접속, 서비스 요청, 서비스 응답이 수행되고 서로간의 접속을 끊게 됩니다. 이후 Service 통신을 다시 진행해야 하는 경우 처음부터 다시 진행해야 합니다. Topic 접속의 종료 시, Node의 종료 시에도 각 Node들은 ROS Master에게 XML-RPC를 통해 종료 Message를 주고받습니다. ROS Packet Analysis Demo ROS 내부의 통신이 이루어지는 과정을 배운 만큼 WireShark를 통해 실제 오가는 패킷을 분석해 봅시다.\nWireshark 설치 sudo apt update sudo apt install wireshark sudo wireshark ROS Master는 기본적으로 11311 포트를 사용하도록 설정되어있습니다. 현재 IP의 11311 포트 패킷을 분석하여 roscore 실행 시 오가는 패킷들을 살펴보겠습니다. ip.addr == \u0026lt;my-ip-addr\u0026gt; || tcp.port == 11311 # Terminal roscore TCP handshake가 이루어진 뒤 parameter server, logger, roslaunch, rosgraph, statistics_window_max_size를 비롯하여 다양한 서비스가 Request, Response를 통해 초기화됩니다. ROS Master를 종료할 시에도 실행되고 있는 모든 서비스들은 11311포트를 통해 종료 신호를 Request-Response 합니다.\n이번에는 Publisher를 실행한 뒤, ROS Master와 오가는 패킷을 살펴봅시다. rostopic pub /chatter std_msgs/String \u0026#34;hello\u0026#34; 패킷을 살펴보면, XMLRPC를 통해 Topic Publisher의 포트와 이름, Topic 이름과 Message type 정보를 확인할 수 있습니다. Packet - 1 Packet - 2 \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt; registerService \u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rostopic_18957_1673097448137 \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rostopic_18957_1673097448137/get_loggers \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; rosrpc://166.104.135.89:44311 \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; http://166.104.135.89:33575/ \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; \u0026lt;?xml version=\u0026#39;1.0\u0026#39; ?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt; registerPublisher \u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rostopic_18957_1673097448137 \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /chatter \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; std_msgs/String \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; http://166.104.135.89:33575/ \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; Connection Header를 실제로 확인해보겠습니다. rostopic echo를 실행한 뒤 패킷의 data field를 살펴봅니다. $ rostopic echo /chatter data: \u0026#34;hello\u0026#34; --- 실제 /chatter topic의 정보를 조회해보면 data 필드의 결과와 일치하는 것을 확인 가능합니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /rostopic_18957_1673097448137 (http://166.104.135.89:33575/) Subscribers: None /chatter Topic Subscriber를 실행하고, topic publisher의 포트(현재는 33575)로 오가는 패킷을 분석해보겠습니다. ip.addr == \u0026lt;my-ip-addr\u0026gt; || tcp.port == 33575 (/chatter publisher의 포트가 33575였음) Topic echo를 통해 Subscriber를 실행합니다. $ rostopic echo /chatter data: \u0026#34;hello\u0026#34; --- 우선, 생성된 Subscriber 정보는 아래와 같습니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /rostopic_18957_1673097448137 (http://166.104.135.89:33575/) Subscribers: * /rostopic_21890_1673098174449 (http://166.104.135.89:36479/) 패킷을 살펴보면, Subscriber에 대한 정보와 데이터 타입에 대한 정보가 XML-RPC를 통해 오고 간 것을 확인할 수 있습니다. Packet - 1 Packet - 2 \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt; registerPublisher \u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rostopic_21890_1673098174449 \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rosout \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; rosgraph_msgs/Log \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; http://166.104.135.89:36479/ \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; \u0026lt;methodResponse\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt; \u0026lt;data\u0026gt; \u0026lt;value\u0026gt; \u0026lt;int\u0026gt; 1 \u0026lt;/int\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; current system state \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt; \u0026lt;data\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt; \u0026lt;data\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rosout_agg \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; rosgraph_msgs/Log \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt; \u0026lt;data\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /rosout \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; rosgraph_msgs/Log \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt; \u0026lt;data\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; /chatter \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;value\u0026gt; \u0026lt;string\u0026gt; std_msgs/String \u0026lt;/string\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodResponse\u0026gt; 다음으로, turtlesim을 통해 topic message data의 변화를 살펴보고자 합니다.\nturtlesim을 실행시킨 뒤 rosnode info를 통해 각종 정보들을 조회합니다. 사용중인 통신 방법 (TCPROS), Node의 포트 번호 등 다양한 정보들이 조회됩니다. $ rosrun turtlesim turtlesim_node $ rosnode info /turtlesim -------------------------------------------------------------------------------- Node [/turtlesim] Publications: * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] Subscriptions: * /turtle1/cmd_vel [unknown type] Services: * /clear * /kill * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative * /turtlesim/get_loggers * /turtlesim/set_logger_level contacting node http://166.104.135.89:39875/ ... Pid: 29120 Connections: * topic: /rosout * to: /rosout * direction: outbound (33435 - 166.104.135.89:60856) [26] * transport: TCPROS rostopic info를 통해 cmd_vel topic에 대한 정보를 조회하였습니다. 사용중인 포트 번호를 확인한 뒤 wireshark를 통해 해당 포트로 오가는 패킷을 분석합니다. $ rostopic info /turtle1/cmd_vel Type: geometry_msgs/Twist Publishers: None Subscribers: * /turtlesim (http://166.104.135.89:39875/) wireshark 필터 조건문 ip.addr == \u0026lt;my-ip\u0026gt; || tcp.port == 39875 teleop key를 통해 거북이의 조종을 준비하고, 해당 작업 중 발생한 패킷을 분석합니다. rosrun turtlesim turtle_teleop_key XML-RPC 통신들이 이루어진 뒤로, TCP 통신이 이어지는 모습을 확인할 수 있습니다.\nTCP Data 필드의 내용에는 아래와 같은 데이터가 포함되어 있습니다.\ncallerid=/teleop_turtle latching=0\u0026#39;md5sum=acffd30cd6b6de30f120938c17c593fbjmessage_definition=## ## Severity level constants ## byte DEBUG=1 #debug level byte INFO=2 #general level byte WARN=4 #warning level byte ERROR=8 #error level byte FATAL=16 #fatal/critical level ## ## Fields ## Header header byte level string name # name of the node string msg # message string file # file the message came from string function # function the message came from uint32 line # line the message came from string[] topics # topic names that the node publishes ================================================================================ MSG: std_msgs/Header # Standard metadata for higher-level stamped data types. # This is generally used to communicate timestamped data # in a particular coordinate frame. # # sequence ID: consecutively increasing ID uint32 seq #Two-integer timestamp that is expressed as: # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called \u0026#39;secs\u0026#39;) # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called \u0026#39;nsecs\u0026#39;) # time-handling sugar is provided by the client library time stamp #Frame this data is associated with string frame_id topic=/rosouttype=rosgraph_msgs/Log callerid=/teleop_turtle latching=0\u0026#39;md5sum=9f195f881246fdfa2798d1d3eebca84armessage_definition=# This expresses velocity in free space broken into its linear and angular parts. Vector3 linear Vector3 angular ================================================================================ MSG: geometry_msgs/Vector3 # This represents a vector in free space. # It is only meant to represent a direction. Therefore, it does not # make sense to apply a translation to it (e.g., when applying a # generic rigid transformation to a Vector3, tf2 will only apply the # rotation). If you want your data to be translatable too, use the # geometry_msgs/Point message instead. float64 x float64 y float64 z topic=/turtle1/cmd_veltype=geometry_msgs/Twist teleop key에서 앞/뒤/CW/CCW와 같이 다양한 조종 신호를 publish해보고 이때의 TCP Data가 어떻게 변화하는지 확인해봅시다. ⇒ 기본적으로 sequence / timestamp가 변화하며, 미묘하게 data가 다른 것을 알 수 있습니다.\n이렇게 topic message는 serialization이 되어 있으며, 공식 문서화 같이 MD5 sum을 사용합니다. image from : roswiki ROS URI 설정 ROS에는 다양한 환경 변수들이 존재합니다. 이들 중 Master가 사용할 IP와 Port를 설정하는 환경 변수가 있으며, 이는 아래와 같이 조회 가능합니다. $ echo $ROS_MASTER_URI http://192.168.0.1:11311 서로 다른 디바이스에서 동작하는 ROS 시스템일지라도 같은 MASTER URI를 갖도록 하면 원격 통신이 가능합니다. 이를 통해 원격 시각화와 원격 제어를 주로 실행합니다.\nimage from : turtlebot3 git ROS_MASTER_URI를 사용하는 방법은 다음과 같습니다.\nROS_MASTER_URI=http://master-ip-addr:master-ip-port ROS_IP=\u0026lt;현재 디바이스의 ip-addr\u0026gt; ROS_HOSTNAME=\u0026lt;현재 디바이스의 hostname\u0026gt; ROS_IP와 ROS_HOSTNAME는 서로 양립할 수 없고, 둘 중 하나를 사용할 수 있습니다.\nbashrc의 수정을 해두면, 새로운 터미널을 실행할 때마다 변경된 내용이 반영될 수 있어 편리합니다. 강의 초반, 저의 셋업을 따라오셨다면, ~/ros_menu/config.yaml을 수정하여 손쉽게 변경하실 수 있습니다. Config: menu_enable: true ros_option: menu default_ros_domain_id: 30 Menu: ROS 1 noetic: option_num: 1 ROS_version: 1 distro_name: noetic ros1_path: /opt/ros/noetic master_ip: # set if roscore isn\u0026#39;t on this computer cmds: # - source ${HOME}/catkin_ws/devel/setup.${shell} # - source_plugin openvino_bashrc 같은 네트워크를 사용하는 두 PC를 사용해서 원격으로 로봇을 조종해보는 실습을 진행해봅시다. # PC 1 - ROS Master를 실행시키고 로봇 등장시키기 roslaunch smb_gazebo smb_gazebo.launch # PC 2 - Master URI 변경 후 로봇 조종 rosrun teleop_twist_keyboard teleop_twist_keyboard.py image from : robots.nootrix 자료출처\nhttps://www.tutorialspoint.com/xml-rpc/xml_rpc_fault.htm http://wiki.ros.org/ROS/Connection Header http://wiki.ros.org/ROS/TCPROS 로봇 운영체제 강좌 : ROS 개념 정리 (오픈소스 소프트웨어 \u0026amp; 하드웨어: 로봇 기술 공유 카페 (오로카)) http://wiki.ros.org/ROS/EnvironmentVariables#ROS_IP.2FROS_HOSTNAME "
},
{
	"uri": "/kr/advanced_contents_ros2/lecture3/",
	"title": "Lecture12 - SROS2",
	"tags": [],
	"description": "",
	"content": "sros2 DDS는 기본적으로 보안이 적용되어 있지는 않습니다. 대신, 아래와 같이 5가지의 보안 기능이 표준 정의에 포함되어 있습니다. 사용자는 이들을 Plugin 형태로 추가하여 사용하게 되며, 주로 Vendor단에서 패치 형태로 제공합니다.\nAuthentication: 같은 네트워크를 사용하고, 특정 domain내에 존재하는 participant 사이의 신원을 검사합니다. (x.509 인증서와 특정 Public Key Infrastructure - PKI를 사용합니다. ) Access control: participant의 동작, 혹은 리소스를 제한합니다. (apparmor나 cgroup이 아니라 특정 participant를 특정 DDS 도메인으로 제한하거나, participant가 특정 DDS 항목을 읽거나 쓸 수 있도록 하는 형태입니다.) Cryptography: encryption/decryption/signing/hashing/digital signatures와 같은 암호화 관련 작업을 담당합니다. (Authentication과 Access control plugin에서 모두 이 기능을 사용하게 되고, DDS의 Topic Message를 암호화합니다.) Logging: DDS의 보안 관련 이벤트를 로깅합니다. Data tagging: data에 추가 label을 달수 있습니다. 이를 통해 데이터의 보안 측면 분류를 할 수 있으며, 더욱 개선된 access control이 가능합니다. 아래 2종류는 필수 표준이 아니기 때문에 대부분의 Vendor들은 제공하고 있지 않습니다.\nROS 2 Security Working Group (SWG)은 DDS와 ROS 2의 보안과 관련된 오픈 그룹입니다. 해당 그룹에서는 DDS의 보안 취약점을 분석하였는데요, 그 결과 총 13종류의 보안 취약점을 발견하였습니다.\n이러한 13가지 취약성은 CVE(Common Vulnerabilities and Exposure)로 등록되었고, 이 중 7개는 CVSS(Common Vulnerability Scoring System) v3를 기준으로 \u0026lsquo;High\u0026rsquo; 등급을 판정받았으며, 나머지 5개 또한 \u0026lsquo;Medium\u0026rsquo; 등급을 판정받았습니다.\n이러한 분석 결과로 US Cybersecurity and Infrastructure Security Agency (CISA)는 DDS 시스템에 보안 권고 경고 ICS Advisory (ICSA-21-315-02)를 내렸고, 그 결과 각 DDS 벤더들은 현재 보안에 계속해서 신경쓰고 있는 상황입니다.\n=\u0026gt; 해당 13종의 보안 취약점에 대해서 간단히 리뷰를 해보겠습니다.\nNetwork-based vulnerabilities Network Layer에서 고의적인 RTPS packet 전송을 통해 DoS 공격이 가능한 점 불충분한 IP Check (기본 Domain Multicast IP 등) 관련 DDS 표준 - CVE-2021-38425, CVE-2021-38429, CVE-2021-38487, CVE-2021-43547 관련 위험 코드 - Common Weakness CWE-406 Configuration-based vulnerabilities DDS의 셋업 파일은 XML, JSON, YAML과 같은 보편적인 형태를 사용하므로 위험하다고 판단 ex1) DDS 시스템 중 보안이 취약한 XML 라이브러리를 파고들어 액세스 권한을 탈취할 수 있음 ex2) 특정 XML Pasrse 내 부적절한 값을 전달하여 buffer overflow를 발생시킬 수 있음 ⇒ 이러한 이유로 현재 대부분의 DDS Vendor들은 보안 Patch를 배포한 상황입니다.\nFast DDS https://github.com/eProsima/Fast-DDS Open DDS https://opendds.org/ rti DDS https://www.rti.com/products/dds-standard 아래 첨부 파일에는 Ubuntu를 관리하는 Canonical 재단에서 배포한 ROS 사용자를 위한 보안 강화 전략들이 담겨 있습니다. 라즈베리파이와 TurtleBot 로봇을 통해 각종 보안 테스트를 한 결과로 얻게 된 인사이트가 담겨 있습니다.\nDisabling USB Remove default users such as “ubuntu” SSH hardening Disabling Internet Protocol v6 Unattended upgrades Example Packages Securing ROS_WhitePapaer_10.03.20.pdf (325 ) SROS2 ROS 1의 sros와 마찬가지로 sros2는 ROS 2의 보안을 위한 도구들의 집합입니다.\nCA 인증서 자동 생성, x.509에 기반한 keypair 생성 keypairs, governance and permissions files등이 담기는 keystore 생성 DDS traffic을 암호화하는 governance file 제공 SROS2 공식 레퍼런스에서 제공하는 기본 예시들을 함께 실행해보고, 패킷 분석도 진행해보겠습니다.\nsros2 setup sudo apt update \u0026amp;\u0026amp; sudo apt install libssl-dev sudo apt install ros-foxy-demo-nodes-cpp -y sudo apt install ros-foxy-demo-nodes-py -y mkdir ~/sros2_demo cd ~/sros2_demo 각종 인증 관련 파일들이 위치하게 될 keystore를 생성합니다. $ ros2 security create_keystore demo_keystore creating keystore: demo_keystore creating new CA key/cert pair creating governance file: demo_keystore/enclaves/governance.xml creating signed governance file: demo_keystore/enclaves/governance.p7s all done! enjoy your keystore in demo_keystore cheers! 생성된 keystore 폴더는 다음과 같은 폴더 형태를 취하고 있습니다. ├── enclaves │ ├── governance.p7s │ └── governance.xml ├── private │ ├── ca.key.pem │ ├── identity_ca.key.pem -\u0026gt; ca.key.pem │ └── permissions_ca.key.pem -\u0026gt; ca.key.pem └── public ├── ca.cert.pem ├── identity_ca.cert.pem -\u0026gt; ca.cert.pem └── permissions_ca.cert.pem -\u0026gt; ca.cert.pem 아래 예시와 같이 각종 인증키가 생성되는 것을 확인 가능합니다.\nca.key.pem -----BEGIN PRIVATE KEY----- MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgiXuds0wpQA1F7Cnv +533UuaPWKnZBYscqvHoyo00XOqhRANCAATI2CRyvxYccuxaWGTKDDe5b2dmdqH5 pBBbeHXXD1QRt7khzpX11InLr9jjpmaotgNIl6oap5d5IF1cIQUXuF1Y -----END PRIVATE KEY----- Authentication Example 첫번째 예시에서는 인증 keypair를 가진 topic publisher와 subscriber를 생성해보려 합니다. 더불어 wireshark를 통해 암호화된 topic message도 확인해보겠습니다.\nsros2 키워드를 사용하여 두 세트의 인증서를 생성합니다. ros2 security create_key demo_keystore /talker_listener/talker ros2 security create_key demo_keystore /talker_listener/listener keystore 폴더 내부에 인증서와 permission이라는 config 파일이 추가되었습니다. ├── enclaves │ ├── governance.p7s │ ├── governance.xml │ └── talker_listener │ ├── listener │ │ ├── cert.pem │ │ ├── governance.p7s -\u0026gt; ../../governance.p7s │ │ ├── identity_ca.cert.pem -\u0026gt; ../../../public/identity_ca.cert.pem │ │ ├── key.pem │ │ ├── permissions_ca.cert.pem -\u0026gt; ../../../public/permissions_ca.cert.pem │ │ ├── permissions.p7s │ │ └── permissions.xml │ └── talker │ ├── cert.pem │ ├── governance.p7s -\u0026gt; ../../governance.p7s │ ├── identity_ca.cert.pem -\u0026gt; ../../../public/identity_ca.cert.pem │ ├── key.pem │ ├── permissions_ca.cert.pem -\u0026gt; ../../../public/permissions_ca.cert.pem │ ├── permissions.p7s │ └── permissions.xml ├── private │ ├── ca.key.pem │ ├── identity_ca.key.pem -\u0026gt; ca.key.pem │ └── permissions_ca.key.pem -\u0026gt; ca.key.pem └── public ├── ca.cert.pem ├── identity_ca.cert.pem -\u0026gt; ca.cert.pem └── permissions_ca.cert.pem -\u0026gt; ca.cert.pem 예제를 실행하기 전, 일반적인 Topic 통신 시 String data가 패킷에 노출되는 모습을 살펴보겠습니다. wireshark를 실행시킨 뒤, 커멘드 라인을 실행시키고 패킷을 수집합니다.\n# Terminal 1 ros2 run demo_nodes_cpp talker # Terminal 2 ros2 run demo_nodes_cpp listener ⇒ RTPS Heartbeat 패킷을 살펴보면, Hello World 라는 데이터가 고스란히 노출되어 있는 모습을 확인 가능합니다.\n이제 보안 옵션을 적용해보겠으며, sros2에서는 다양한 환경 변수를 통해 보완 관련 옵션을 변경할 수 있도록 하고 있습니다. security를 enable 시켜보겠습니다. export ROS_SECURITY_KEYSTORE=~/sros2_demo/demo_keystore export ROS_SECURITY_ENABLE=true export ROS_SECURITY_STRATEGY=Enforce 다음으로, 사용한 RMW DDS를 변경해줍니다. 안타깝게도 CycloneDDS의 Debian Package는 보안 plugin을 제공하지 않기 때문에 보안 옵션 적용 시 아래와 같은 에러가 발생합니다. (소스 코드 빌드를 하면 해결됩니다.) $ ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker [INFO] [1674150011.742615669] [rcl]: Found security directory: /home/kimsooyoung/sros2_demo/demo_keystore/enclaves/talker_listener/talker 1674150011.756184 [19] talker: Could not load Authentication library: dds_security_auth: cannot open shared object file: No such file or directory 1674150011.756216 [19] talker: Could not load Authentication plugin. 1674150011.756221 [19] talker: Could not load security [ERROR] [1674150011.757250268] [rmw_cyclonedds_cpp]: rmw_create_node: failed to create DDS participant \u0026gt;\u0026gt;\u0026gt; [rcutils|error_handling.c:108] rcutils_set_error_state() This error state is being overwritten: ... 따라서, 이번 예시를 위해 Fast DDS로 RMW를 변경하겠습니다. export RMW_IMPLEMENTATION=rmw_fastrtps_cpp 서로 다른 Vendor 끼리는 보안 plugin이 호환되지 않습니다. (보안은 표준이 아닙니다.)\nrmw_connextdds ( rit DDS )는 유료 사용 시 보안 옵션을 사용 가능하며 30일 무료판을 사용하셔도 됩니다. ⇒ https://www.rti.com/free-trial\n이제 pub-sub 예시를 실행해보겠습니다. # Terminal 1 $ cd ~/sros2_demo/ $ export RMW_IMPLEMENTATION=rmw_fastrtps_cpp $ ros2 run demo_nodes_cpp talker --ros-args --enclave /talker_listener/talker [INFO] [1674150302.868609218] [rcl]: Found security directory: /home/kimsooyoung/sros2_demo/demo_keystore/enclaves/talker_listener/talker [INFO] [1674150303.901477001] [talker]: Publishing: \u0026#39;Hello World: 1\u0026#39; [INFO] [1674150304.901496377] [talker]: Publishing: \u0026#39;Hello World: 2\u0026#39; # Terminal 2 $ cd ~/sros2_demo/ $ export RMW_IMPLEMENTATION=rmw_fastrtps_cpp $ ros2 run demo_nodes_cpp listener ??? $ ros2 run demo_nodes_cpp listener --ros-args --enclave /talker_listener/listener 보안 옵션을 적용하지 않았기 때문에 Publisher가 동작하지 않습니다.\n현 상황에서 다시금 wireshark를 실행하여 패킷을 수집해보겠습니다. 사진과 같이 이제는 RTPS가 아닌, TLSv1.2 프로토콜을 사용하여 데이터가 오가게 됩니다. 해당 패킷을 열어보면 아래와 같이 암호화가 되어있습니다. 더불어, RTPS 프로토콜 패킷을 살펴보면, enclave 옵션이 적용된 것도 확인 가능합니다. 만약, 서로 다른 머신끼리 통신을 하고 싶다면, demo_keystore를 두 머신 모두 동일하게 소유하고 있어야 합니다. 옆자리에 다른 PC가 있다면 직접 실습해보세요\nmkdir -p ~/sros2_demo/demo_keystore scp -r talker USERNAME@oldschool.local:~/sros2_demo/demo_keystore Access Control 시스템의 보안 수준을 높이기 위해 각 노드가 수행할 수 있는 작업을 제한하는 Access Control을 정의할 수 있습니다. 이번 예시에서는 특정 topic만 사용 가능하도록 profile을 지정해보겠습니다.\nROS 2에서 기본 제공하는 policy 예시를 복사합니다. sudo apt update \u0026amp;\u0026amp; sudo apt install subversion cd ~/sros2_demo svn checkout https://github.com/ros2/sros2/trunk/sros2/test/policies clone한 policy를 바탕으로 node의 action을 제한하는 description을 생성합니다. cd ~/sros2_demo ros2 security create_permission demo_keystore /talker_listener/talker policies/sample.policy.xml ros2 security create_permission demo_keystore /talker_listener/listener policies/sample.policy.xml 위 작업은 talker / listener의 cert.pem이 있어야 실행 가능합니다.\n일전 예시를 다시 실행시켜보겠습니다. 얼핏 보기에는 달라진 점이 전혀 없어 보입니다. # Terminal 1 ros2 run demo_nodes_cpp talker --ros-args -e /talker_listener/talker # Terminal 2 ros2 run demo_nodes_py listener --ros-args -e /talker_listener/listener 하지만, argument를 통해 사용하는 topic을 다른 것으로 바꾸는 순간, not found in allow rule라는 명령어와 함께 Node가 생성되지 않습니다. # Terminal 1 ros2 run demo_nodes_cpp talker --ros-args -e /talker_listener/talker # Terminal 2 ros2 run demo_nodes_py listener --ros-args -r chatter:=not_chatter -e /talker_listener/listener [INFO] [1674152415.259964110] [rcl]: Found security directory: /home/kimsooyoung/sros2_demo/demo_keystore/enclaves/talker_listener/listener 2023-01-20 03:20:15.303 [SECURITY Error] rt/not_chatter topic not found in allow rule. (/tmp/binarydeb/ros-foxy-fastrtps-2.1.2/src/cpp/security/accesscontrol/Permissions.cpp:1271) -\u0026gt; Function check_create_datareader 2023-01-20 03:20:15.303 [SECURITY Error] Error checking creation of local reader bb.dd.19.9c.75.22.60.e0.55.c1.c0.3a|0.0.11.4 (rt/not_chatter topic not found in allow rule. (/tmp/binarydeb/ros-foxy-fastrtps-2.1.2/src/cpp/security/accesscontrol/Permissions.cpp:1271)) -\u0026gt; Function register_local_reader 2023-01-20 03:20:15.303 [PARTICIPANT Error] Problem creating associated Reader -\u0026gt; Function createSubscriber 이번 예시에서 사용한 policy file입니다. - policies/sample.policy.xml topic publisher와 subscriber는 오직 /chatter topic만을 사용할 수 있게 access limit 걸리게 됩니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;policy version=\u0026#34;0.2.0\u0026#34; xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34;\u0026gt; \u0026lt;enclaves\u0026gt; \u0026lt;xi:include href=\u0026#34;talker_listener.policy.xml\u0026#34; xpointer=\u0026#34;xpointer(/policy/enclaves/*)\u0026#34;/\u0026gt; \u0026lt;xi:include href=\u0026#34;add_two_ints.policy.xml\u0026#34; xpointer=\u0026#34;xpointer(/policy/enclaves/*)\u0026#34;/\u0026gt; \u0026lt;xi:include href=\u0026#34;minimal_action.policy.xml\u0026#34; xpointer=\u0026#34;xpointer(/policy/enclaves/*)\u0026#34;/\u0026gt; \u0026lt;enclave path=\u0026#34;/sample_policy/admin\u0026#34;\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile ns=\u0026#34;/\u0026#34; node=\u0026#34;admin\u0026#34;\u0026gt; \u0026lt;xi:include href=\u0026#34;common/node.xml\u0026#34; xpointer=\u0026#34;xpointer(/profile/*)\u0026#34;/\u0026gt; \u0026lt;actions call=\u0026#34;ALLOW\u0026#34; execute=\u0026#34;ALLOW\u0026#34;\u0026gt; \u0026lt;action\u0026gt;fibonacci\u0026lt;/action\u0026gt; \u0026lt;/actions\u0026gt; \u0026lt;services reply=\u0026#34;ALLOW\u0026#34; request=\u0026#34;ALLOW\u0026#34;\u0026gt; \u0026lt;service\u0026gt;add_two_ints\u0026lt;/service\u0026gt; \u0026lt;/services\u0026gt; \u0026lt;topics publish=\u0026#34;ALLOW\u0026#34; subscribe=\u0026#34;ALLOW\u0026#34;\u0026gt; \u0026lt;topic\u0026gt;chatter\u0026lt;/topic\u0026gt; \u0026lt;/topics\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/enclave\u0026gt; \u0026lt;/enclaves\u0026gt; \u0026lt;/policy\u0026gt; 참고자료\nhttps://canonical.com/blog/security-vulnerabilities-on-the-data-distribution-service-dds https://github.com/ros2/sros2 https://canonical.com/blog/what-is-sros-2 "
},
{
	"uri": "/kr/advanced_contents_ros1/lecture3/",
	"title": "Lecture3 - SROS",
	"tags": [],
	"description": "",
	"content": " 이전 데모를 통해 ROS의 보안 취약성에 대해 살펴보았습니다. 이러한 취약점들을 개선하기 위한 방법으로 SROS에 대해 배워보겠습니다.\nsros는 마지막 commit 2018년 이후 개발이 사실상 멈춘 프로젝트입니다. ROS 개발자들이 보안을 위해 어떠한 노력을 들였는지 정도만 살펴보고, 데모와 자세한 내용은 ROS 2 강의에서 이어나가도록 하겠습니다.\nUDPROS가 roscpp만 지원했던 것처럼, sros도 rospy와 사용할 시 제한이 있습니다. TCPROS UDPROS rospy X O roscpp O O rosjava O O sros는 ROS의 client 라이브러리 소스 코드에 보안을 적용하여 새롭게 개발한 ROS Client Library입니다. sros가 사용되는 절차는 다음과 같습니다. sros 빌드 (기존 ROS 코드가 아닌) sroskeyserver 실행 sroscore 실행 sroslaunch를 통해 응용 프로그램 실행 sros에서 제공되는 기능들은 다음과 같습니다.\n소켓 전송에 대한 Native TLS 지원 ROS 노드단에서 자동 생성된 node key pairs 관리 리눅스 커널 단에서의 보안 강화 (AppArmor profile library) x.509 인증서 사용 지원 etc… SROS는 ROS 내의 보안 강화를 위한 방법들의 집합을 지칭하며, 크게 3 계층의 보안을 제공합니다. 각 계층들에 대한 간단한 설명을 해보겠습니다.\nTransport Security Access Control Process Profile Transport Security and ROS SROS는 TLS를 활용하여 ROS 관련 트래픽을 보호합니다. 이를 통해 악의적인 행위자의 redirection, 메시지를 탈취하여 중간에 수정한다거나 Spoofing을 막을 수 있습니다. 또한 시스템/물리적 수준 액세스를 통해 로봇이 손상되더라도 TLS에서 제공하는 Forward Secrecy 덕분에 이전에 기록된 트래픽도 보호할 수 있습니다.\nSROS가 TLS를 적용한 방법은, 네트워크 스택과 ROS 클라이언트 라이브러리 사이에 TLS를 끼워 넣는 것입니다. 이를 통해 SROS는 모든 Socket 수준의 ROS 통신을 Wrapping할 수 있으며, 사용자는 기존 ROS 프로그램 코드를 수정하지 않고도 SROS의 모든 이점을 적용할 수 있습니다.\nimage from : hpbn.co SROS Keyserver Keyserver는 ROS node에게 인증된 key를 분배하고 관리하는 역할을 합니다. Keyserver는 ROS와 독립적으로 실행되며, 다른 기기에서 실행되어도 무관합니다. 만약 자신만의 PKI 방식을 갖고 있다면 기본 제공되는 keyserver를 대체할 수 있습니다.\nSROS는 기본적으로 보안에 익숙치 않고, TLS 시스템을 구축하는 개념에 서투른 사용자를 대상으로 만들어졌습니다.\nKeyserver를 통한 Node configuration과 실행은 아래 링크를 참고합니다. How is a Keyserver used in SROS\nRunning Keyserver SROS의 Node들은 실행 전 Keyserver를 통한 key 생성과 CA를 통한 인증이 필요합니다. 이 과정 없이 생성된 node들은 rosmaster와의 연결이 거부됩니다.\nkeyserver 실행 $ sroskeyserver Starting an XML-RPC server to bootstrap SSL key distribution... Certificate generated: root Certificate generated: master sleeping until keyserver has generated the initial keyring... Horray, the keyserver is now open for business. SROS는 ~/.ros 폴더 내 자신만의 configuration을 구축합니다. 이 내부에는 인증에 필요한 각종 파일들이 위치하게 됩니다. $ tree ~/.ros/sros /root/.ros/sros ├── config │ ├── keyserver_config.yaml │ └── policy_config.yaml └── keystore ├── ca │ ├── master │ │ ├── master.cert │ │ └── master.pem │ └── root │ ├── root.cert │ └── root.pem ├── capath │ ├── d11d170d.0 -\u0026gt; /root/.ros/sros/keystore/ca/root/root.cert │ └── f4ad5f10.0 -\u0026gt; /root/.ros/sros/keystore/ca/master/master.cert └── utils └── keyserver ├── keyserver.cert └── keyserver.pem 8 directories, 10 files 초기 실행 시 로딩된 configuration 파일은 keyserver에 CA를 로드하도록 지시하고, keystore에 존재하지 않는 경우 방법을 지시합니다. root와 중간 Master CA가 초기화되면 keyserver는 자체 transport 인증서와 keypair 로딩을 요청받습니다. keyserver는 자체 key를 사용하여 자신에게 연결을 시도하고, keyserver의 API 끝이 온라인 상태이며 작동 중인지 확인합니다. 이 작업이 모두 완료되면 keyserver가 연결 Node의 요청을 받을 준비가 됩니다. Access Control Access Control을 통해 ROS에서 사용하는 리소스와 Action을 제어할 수 있습니다. SROS 튜토리얼에서는 아래와 같은 ROS API들에 대하여 Access Control 설정이 가능하다고 이야기하고 있습니다.\ntopics publish subscribe parameters read write services advertise call ROS API master calls slave calls Access Control의 실제 구현 방식에 있어 SROS에서 제안하는 두가지 방법을 간략히 정리해보았습니다.\nCertificate Embedding SROS는 Node간 보안 네트워크 소켓 연결(TLS 핸드셰이크) 시 X.509 인증서를 사용합니다. 검증된 방식을 사용하고 계산 효율이 좋다는 장점이 있지만, 이러한 방식은 Policy data가 public 이기 때문에 node, topic 이름이 노출될 염려가 있습니다. Online Arbiter 중앙 집중식으로 데이터 통신을 중재할 수 있습니다. global policy에 대한 정보를 알고 있는 중앙 통제 프로세스가 요청된 Node와 접촉하고 허용여부를 판단합니다. 이는 ROS Master Node가 사용하는 기존 DNS 방식과 유사하지만 네임스페이스 대신 access control restriction을 사용한다는 차이점이 있습니다. Linux Security Modules AppArmor(애플리케이션 Armor)는 프로그램 프로파일로 프로그램의 기능을 제한할 수 있도록 하는 리눅스 커널 보안 모듈입니다. SROS 튜토리얼에서는 AppArmor의 ROS 호환 프로파일 예시를 제공하고 있습니다.\nimage from : https://wiki.apparmor.net/ AppArmor를 활용하여 ROS 프로세스를 격리하고 보호할 수 있으며, 이를 통해 악의적이거나 오작동하는 Node가 Host 시스템과 다른 Node에 미칠 수 있는 영향을 제한할 수 있습니다.\n예를 들면, 특정 IMU Node에 대해 전용 Bus를 예약하고 노드가 해당 Serial Port를 사용하지 못하도록 할 수 있습니다. 이와 같이 특정 노드에 대한 프로파일을 지정하고 예약된 장치에만 읽고 쓸 수 있는 권한을 지정할 수 있습니다.\nAppArmor 설치 sudo apt-get install apparmor apparmor-utils AppArmor를 사용하기 위해 프로파일 configuration file을 작성해야 합니다. github를 통해 ROS를 위한 프로파일 예시를 제공하고 있으며, 이를 AppArmor의 설정 폴더로 복사합니다. git clone https://github.com/ros-infrastructure/apparmor_profiles sudo cp --recursive apparmor_profiles/profiles /etc/apparmor.d 각 프로파일들에 대한 설명은 아래와 같습니다. $ tree apparmor_profiles/profiles/ apparmor_profiles/profiles/ ├── ros # root profile library folder │ ├── base # base networking and signal abstractions for ROS │ ├── node # node abstractions executables needed for ros nodes │ ├── nodes # additional node specific abstractions │ │ └── roslaunch # additional file and signal abstractions for roslaunch │ └── python # node abstractions needed for python nodes └── tunables # root tunables folder for AppArmor profile variables ├── ros # path abstractions executables needed for ros nodes └── ros.d # additional distro specific abstractions └── kinetic # path definition for default kinetic install 프로파일을 변경하게 되면, AppArmor를 새롭게 재시작해야 합니다. 이는 아래 키워드를 사용합니다. sudo service apparmor restart SROS Tutorial에서는 Topic을 사용하는 talker - listener에 대한 프로파일과 실행 예시를 제공하고 있습니다. Custom 프로파일의 작성법과 실행 방법은 링크로 대체합니다.\nCustomizing AppArmor Profiles for ROS 참고자료\nhttp://wiki.ros.org/SROS/CommandLineTools http://wiki.ros.org/SROS/Concepts/PolicyDissemination http://wiki.ros.org/SROS/Tutorials/TrasportSecurityAndROS "
},
{
	"uri": "/kr/ros_and_gazebo/lecture1/",
	"title": "Lecture1 - Gazebo and Robot",
	"tags": [],
	"description": "",
	"content": "FusionBot 소개 이번 실습을 위해 모바일 로봇에서 가장 많이 사용되는 타입의 로봇, FusionBot을 준비하였습니다. FusionBot을 통해 ROS에서의 로봇 표현 방법을 익힌 뒤, 실제 CAD 파일에서 Gazebo 상의 로봇을 구현하는 실습을 진행해봅시다.\n실습을 위한 git repo를 clone한 뒤 종속성들을 설치합시다. cd ~/ros2_ws/src git clone https://github.com/RB2023ROS/du2023-gz.git cd du2023-gz ./setup_scripts.sh URDF와 Robot Description 일반적으로, 로봇은 Links와 Joints 두가지 요소로 이루어집니다.\nLink : 단단하게 고정된 강체(rigid-body)이며, 사람의 골격에 해당합니다. Joint : link 사이를 결합해주고 이들 사이 운동을 결정짓습니다. 사람의 관절에 해당합니다. 다양한 종류의 joint들이 존재하지만, 이론적으로 이들은 결국 prismatic + revolute joint의 결합으로 설명될 수 있습니다.\nrevolute joint : 회전 운동을 갖는 joint prismatic joint : 수평 병진 운동을 갖는 joint 그리고 ROS에서는 개발 상 편의를 위해 크게 6가지의 joint를 사용하고 있지요.\nrevolute - 각도 제한을 가진 회전 continuous - 각도 제한이 없는 회전 prismatic - 수평 운동 fixed - 고정 강체 floating - 6 DOF joint로 gazebo에선 사용 불가 Planar – 평면을 미끄러지는 운동 (물리적 구성이 쉽지 않아 거의 사용되지 않음) Link와 Joint로 결합된 로봇을 결국 텍스트로 표현할 수 있지 않겠냐는 기본 전제 하에, 로봇 공학자들은 URDF - Unified Robot Description Format라는 표준을 만들게 됩니다. 실제로 urdf만 있다면 시뮬레이터 종류에 상관 없이 동일한 로봇 외형을 등장시킬 수 있게 됩니다.\nimage from : Martin Androvich URDF는 XML 문법을 사용하고 있으며 ROS 1의 launch file과 같이 다양한 tag를 통해 로봇을 표현하게 됩니다. 예시를 통해 URDF에 대한 이해도를 가져봅시다.\nURDF의 link가 가질 수 있는 속성들은 다음과 같습니다.\ninertial : 해당 link의 질량, 관성 모멘트와 같은 물성치를 포함합니다. visual : 로봇이 겉으로 보여지는 시각적인 요소를 설정합니다. STL과 같은 3D 모델링 파일을 사용할 수 있습니다. collision : visual은 겉으로 보여지는 모습일 뿐, 실제 해당 link가 자치하는 부피는 collision에서 지정됩니다. Visual과 collision을 일치시킬수록 좋기 때문에 3D 모델링 파일을 사용하기도 합니다. 종종 계산 단순화를 위해 간소화된 모델을 사용하기도 합니다. \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;mass value=\u0026#34;8.3\u0026#34; /\u0026gt; \u0026lt;inertia ixx=\u0026#34;5.249466E+13\u0026#34; ixy=\u0026#34;-1.398065E+12\u0026#34; ixz=\u0026#34;-3.158592E+12\u0026#34; iyy=\u0026#34;5.786727E+13\u0026#34; iyz=\u0026#34;-5.159120E+11\u0026#34; izz=\u0026#34;3.114993E+13\u0026#34; /\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0\u0026#34; rpy=\u0026#34;0 3.1415 3.1415\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://neuronbot2_description/meshes/neuronbot2/base_link.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34; /\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin xyz=\u0026#34;0 0 0.125\u0026#34; rpy=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;0.25 0.25 0.25\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34; /\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; URDF의 Joint가 가질 수 있는 속성들은 다음과 같습니다.\nname : joint의 이름은 후에 tf publish 시 그대로 사용되기 때문에 혼란을 야기하지 않도록 설정해야 합니다. type : 예시에서 사용중인 joint type은 fixed와 continuous로. fixed는 단단히 결합된 joint를, continuous는 무한히 돌아갈 수 있는 joint를 뜻합니다. origin : parent link의 원점을 기준으로 한 joint의 위치를 지정하게 되며, 이러한 수치는 모델링 파일을 통해 미리 조사된 이후 URDF로 변환됩니다. axis : 회전하는 joint의 경우 어떠한 축을 기준으로 회전되는지 설정이 필요합니다. parent, child : 해당 joint의 전, 후 link를 설정합니다. 기타 속성들 (limit, dynamics, calibration, mimic, safety_controller …) : 각종 역학적인 속성을 표현합니다. \u0026lt;joint name=\u0026#34;r_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;wheel_right_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0.0 -0.09 0.0415\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;l_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;wheel_left_link\u0026#34;/\u0026gt; \u0026lt;origin xyz=\u0026#34;0.0 0.109 0.0415\u0026#34; rpy=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; urdf의 joint는 절대 좌표를 기준으로 하는 extrinsic 체계를 갖습니다.\n기타 속성들\norigin : 해당 요소의 원점을 기준으로, 위치와 방향을 결정합니다. 3축 직교 좌표계를 기준으로 x,y,z 축과 roll pitch yaw 회전각을 사용하고 있습니다. geometry : visual과 collision의 기하학적 요소를 결정하는 태그입니다. urdf에서는 box, cylinder, sphere와 같이 단순한 도형을 제공하고 있습니다. 별도 stl 파일을 사용해도 되지만 로봇을 단순화하고 싶은 경우 이를 통해 간소화가 가능합니다. material : color, texture등을 지정할 수 있으며, 외향적인 디자인을 위한 요소입니다. Xacro URDF 스크립트를 사람이 모두 작성하기는 매우 비효율적입니다. 더불어, Gazebo에서만 사용하는 속성을 따로 분리하고 싶은 경우, 파일을 나누어 관리하고 싶을 것입니다. 이러한 욕구를 충족시키기 위해서 ROS는 URDF의 작성을 보다 편하게 해주는 XML Macro, Xacro를 지원하고 있습니다.\n특히 xacro는 수식, 조건을 사용 가능하기 때문에 로봇 파일을 다루기 매우 용이하며, 특정 요소를 모듈화 후 재사용하는 등 효율적인 URDF 작성이 가능하도록 도와줍니다.\n\u0026lt;xacro:macro name=\u0026#34;pr2_arm\u0026#34; params=\u0026#34;suffix parent reflect\u0026#34;\u0026gt; \u0026lt;pr2_upperarm suffix=\u0026#34;${suffix}\u0026#34; reflect=\u0026#34;${reflect}\u0026#34; parent=\u0026#34;${parent}\u0026#34; /\u0026gt; \u0026lt;pr2_forearm suffix=\u0026#34;${suffix}\u0026#34; reflect=\u0026#34;${reflect}\u0026#34; parent=\u0026#34;elbow_flex_${suffix}\u0026#34; /\u0026gt; \u0026lt;/xacro:macro\u0026gt; \u0026lt;xacro:pr2_arm suffix=\u0026#34;left\u0026#34; reflect=\u0026#34;1\u0026#34; parent=\u0026#34;torso\u0026#34; /\u0026gt; \u0026lt;xacro:pr2_arm suffix=\u0026#34;right\u0026#34; reflect=\u0026#34;-1\u0026#34; parent=\u0026#34;torso\u0026#34; /\u0026gt; ... \u0026lt;pr2_upperarm suffix=\u0026#34;left\u0026#34; reflect=\u0026#34;1\u0026#34; parent=\u0026#34;torso\u0026#34; /\u0026gt; \u0026lt;pr2_forearm suffix=\u0026#34;left\u0026#34; reflect=\u0026#34;1\u0026#34; parent=\u0026#34;elbow_flex_left\u0026#34; /\u0026gt; \u0026lt;pr2_upperarm suffix=\u0026#34;right\u0026#34; reflect=\u0026#34;-1\u0026#34; parent=\u0026#34;torso\u0026#34; /\u0026gt; \u0026lt;pr2_forearm suffix=\u0026#34;right\u0026#34; reflect=\u0026#34;-1\u0026#34; parent=\u0026#34;elbow_flex_right\u0026#34; /\u0026gt; CMake를 통해 손쉽게 Xacro 파일들을 URDF로 자동 변환하는 작업을 실습해봅시다.\n해당 패키지 빌드 colcon build --packages-select fusionbot_description source install/setup.bash 패키지 빌드가 발생하면 모든 관련 파일들의 symbolic link가 workspace의 install//share 폴더에 생성됩니다. CMake는 이 share 폴더 내에 있는 symbolic link를 위주로 작업하므로 새로운 파일이 생겼다면 주기적으로 colcon build를 실행하는 것을 추천합니다.\nCMakelists.txt 수정 - 주석되어 있는 라인을 주석 해제합니다. find_package(xacro REQUIRED) # Xacro files file(GLOB xacro_files urdf/*.urdf.xacro) foreach(it ${xacro_files}) # remove .xacro extension string(REGEX MATCH \u0026#34;(.*)[.]xacro$\u0026#34; unused ${it}) set(output_filename ${CMAKE_MATCH_1}) # create a rule to generate ${output_filename} from {it} xacro_add_xacro_file(${it} ${output_filename}) list(APPEND urdf_files ${output_filename}) endforeach(it) add_custom_target(media_files ALL DEPENDS ${urdf_files}) 패키지를 다시 빌드하면, 자동으로 생성된 urdf 파일을 확인할 수 있습니다. sudo apt install ros-foxy-xacro -y colcon build --packages-select fusionbot_description \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;!-- | This document was autogenerated by xacro from /home/swimming/nav2_ws/src/nav2_rosdevday_2021/djhrd_ros2/fusionbot_description/urdf/fusionbot.urdf.xacro | --\u0026gt; \u0026lt;!-- | EDITING THIS FILE BY HAND IS NOT RECOMMENDED | --\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34;\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.700 0.700 0.700 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; ... 기존 fusionbot.urdf를 제거한 뒤 자동 생성되는 모습을 확인해보세요.\nCMake는 사용자의 편의를 위해 추가해둔 것일 뿐 키워드를 통해 Xacro ⇒ URDF로의 변환도 가능합니다. 편한 방법을 사용하시기 바랍니다. (workspace를 sourcing 하셔야 실행 가능합니다.)\nxacro fusionbot.urdf.xacro \u0026gt; fusionbot.urdf joint state publisher와 robot state publisher urdf를 모두 작성했다면, 이제 ROS에게 이 정보를 전달해야 합니다. 이를 담당하는 패키지인 joint state publisher와 robot state publisher에 대해 학습해 봅시다.\n개념 학습 이전, 예시를 먼저 실행해보겠습니다. ros2 launch fusionbot_description description.launch.py WSL2 + Windows 시스템에서는 로봇 외관이 보이지 않을 수 있습니다.\nrviz 상에 로봇이 등장했으며, 로봇과 tf를 확인할 수 있습니다. joint state publisher gui라는 작은 창이 등장하며, 이 안에 위치한 작은 슬라이드바를 움직이면 로봇의 바퀴에 박힌 tf도 회전합니다. ROS에서는 이렇게 tf와 description의 형태로 로봇을 인지합니다. joint state publisher joint state publisher는 로봇 내 존재하는 다양한 joint 값들을 실시간으로 갱신하여 /joint_states라는 topic으로 publish 합니다. 해당 topic은 sensor_msgs/msg/JointState msg를 사용하며, 각 joint들의 이름, 현재 위치, 속도와 힘을 배열 형태로 담게 됩니다.\n$ ros2 interface show sensor_msgs/msg/JointState # This is a message that holds data to describe the state of a set of torque controlled joints. # # # The state of each joint (revolute or prismatic) is defined by: # * the position of the joint (rad or m), # * the velocity of the joint (rad/s or m/s) and # * the effort that is applied in the joint (Nm or N). # ... std_msgs/Header header string[] name float64[] position float64[] velocity float64[] effort joint state publisher gui 예제 실행 시 등장했던 조그만 창은 joint_state_publisher_gui라고 불리며, 로봇 내 조작이 가능한 joint들을 간단하게 제어할 수 있도록 해주는 작은 프로그램입니다. 이를 통해 구성한 URDF의 방향은 알맞게 설정되었는지, 원점은 잘 맞는지 등을 확인 가능합니다.\ntopic echo를 실행시킨 뒤, joint_state_publisher_gui를 조작해보면서 변화를 살펴봅시다. $ ros2 topic echo /joint_states header: stamp: frame_id: \u0026#39;\u0026#39; name: - right_wheel_joint - left_wheel_joint position: - 1.918884792812646 - -1.409318464400381 velocity: [] effort: [] --- ⇒ right_wheel_joint는 위치 1.9188를 갖고 있으며, 속도와 힘은 제어되고 있지 않고 있습니다.\n⇒ left_wheel_joint는 위치 -1.4093를 갖고 있으며, 속도와 힘은 제어되고 있지 않고 있습니다.\n이렇게 joint state publisher는 현재 로봇이 가진 움직일 수 있는 모든 joint들을 예의주시하고 topic으로 publish하는 node입니다.\nrobot state publisher URDF의 joint는 joint state publisher가 담당했다면, robot state publisher는 모든 link와 joint 값을 지속적으로 Subscribe하여 전체 로봇의 구조를 tf 형식으로 publish합니다. 더불어, robot state publisher가 publish하는 /robot_description topic은 rviz에서 로봇의 시각화를 위해 사용되고, gazebo에서 로봇을 등장시키기 위해 사용됩니다.\n참고로, ROS 2에서 tf tree를 얻기 위해서는 아래와 같은 커멘드 라인을 사용합니다. (몇 초간 tf listen을 거친 뒤 pdf 형태로 tf tree를 도출해줍니다.)\n$ ros2 run tf2_tools view_frames.py 지금까지 배운 내용들을 복습해봅시다.\n로봇 모델이 ROS에게 전달되기 위해 urdf를 사용했고, 이는 link와 joint로 이루어졌습니다. 로봇 내 joint는 joint state publisher가 담당하며, robot state publisher는 joint state와 함께 link를 결합하여 최종 tf를 broadcast했습니다. 각 Node간 연결을 rqt_graph를 통해 살펴보면 아래와 같습니다.\nLaunch file 분석 description.launch.py를 분석해봅시다.\nrviz description을 위해 필요한 Node는 총 3가지입니다. (현재는 joint_state_publish_gui가 사용되고 있지만 이후에는 일반 joint_state_publisher가 사용됩니다.) return LaunchDescription([ joint_state_publisher_gui, robot_state_publisher, TimerAction( period=5.0, actions=[rviz] ), ]) joint_state_publisher_gui는 일반적인 Node 실행 옵션과 동일합니다. # Joint State Publisher joint_state_publisher_gui = Node( package=\u0026#39;joint_state_publisher_gui\u0026#39;, executable=\u0026#39;joint_state_publisher_gui\u0026#39;, name=\u0026#39;joint_state_publisher_gui\u0026#39; ) robot_state_publisher는 urdf를 argument로 요구합니다. urdf 파일의 위치는 os.path.join를 통해 전달하고 있으며, 여기서의 path는 src 폴더가 아닌 install 폴더의 symbolic link를 참조한다는 것에 주의합니다. # Prepare Robot State Publisher Params urdf_file = os.path.join(description_pkg_path, \u0026#39;urdf\u0026#39;, \u0026#39;fusionbot_description.urdf\u0026#39;) # Robot State Publisher robot_state_publisher = Node( package=\u0026#39;robot_state_publisher\u0026#39;, executable=\u0026#39;robot_state_publisher\u0026#39;, name=\u0026#39;robot_state_publisher\u0026#39;, output=\u0026#39;screen\u0026#39;, parameters=[{\u0026#39;use_sim_time\u0026#39;: True}], arguments=[urdf_file], ) 마지막으로 rviz를 3초 후 실행되도록 합니다. 이는 launch.actions에서 제공하는 TimerAction 기능을 사용한 것으로, urdf의 내용이 너무 많으면 joint state와 robot state를 로드하는데 시간이 소요되기 때문에 적당한 Delay를 갖도록 한 것입니다. # Launch RViz rviz_config_file = os.path.join(description_pkg_path, \u0026#39;rviz\u0026#39;, \u0026#39;description.rviz’) rviz = Node( package=\u0026#39;rviz2\u0026#39;, executable=\u0026#39;rviz2\u0026#39;, name=\u0026#39;rviz2\u0026#39;, output=\u0026#39;screen\u0026#39;, arguments=[\u0026#39;-d\u0026#39;, rviz_config_file] ) ... TimerAction( period=3.0, actions=[rviz] ), Make a Mobile Robot 지금까지의 예시들은 모두 제가 미리 작성해둔 xacro를 사용하였는데요, 그럼 이런 xacro와 urdf는 어떻게 만들 수 있는지, 설계된 모바일 로봇을 바탕으로 Gazebo, ROS와 연동하는 방법에 대해 알아보겠습니다.\n로봇을 설계하기 위한 수많은 설계 프로그램들이 존재합니다. 이번 예시는 무료 사용이 가능한 Autodesk의 Fusion 360을 사용하였으며, Fusion 360에 Third Party ADD_IN을 추가하여 URDF를 생성하고, 생성된 URDF파일을 사용하여 Rviz 및 Gazebo와 연동하고자 합니다.\n사용한 Add In 링크는 다음과 같습니다. ⇒ https://github.com/syuntoku14/fusion2urdf\n링크를 통해 FusionBot의 외형을 확인할 수 있습니다. ⇒ https://a360.co/3gdOajr\n완성된 로봇으로부터 URDF를 추출하면 첨부파일과 같은 패키지를 얻을 수 있습니다.\n📂 fusionbot_description.zip\nROS 1의 경우 바로 사용이 가능하지만, ROS 2는 몇가지 추가 설정들이 필요합니다. 따라서, 이번 예시에서는 ROS 2 환경을 기준으로 설정을 변경해보면서 URDF와 ROS 연동에 대해 학습해보겠습니다.\n실습을 위해 새로운 ROS 2 패키지를 생성합니다. (ament_cmake 이용) $ ros2 pkg create --build-type ament_cmake \u0026lt;package_name\u0026gt; ros2 pkg create --build-type ament_cmake temp_description 결국 우리가 만들고자 하는 패키지는 제가 배포한 fusionbot_description과 동일합니다. 예제를 따라오시면서 발생하는 문제는 fusionbot_description을 참고하여 해결하시면 됩니다.\n새롭게 생성한 ROS 2 패키지에 fusionbot_description의 meshes와 urdf 폴더를 이동시킵니다. (meshes에는 표면 질감 등 시각화 관련 파일들이 담겨 있습니다.) urdf 폴더 내부의 파일들을 수정해봅시다.\nfusionbot.gazebo을 아래와 같이 수정합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_control.so\u0026#34; name=\u0026#34;control\u0026#34;/\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.1\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.1\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;gravity\u0026gt;true\u0026lt;/gravity\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;lidar_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_wheel_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;100000.0\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;100000.0\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;left_wheel_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;1500\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;1500\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; libgazebo_ros_control는 ros control의 gazebo 버전입니다. ros control interface를 통해 gazebo 상의 로봇과 실제 로봇의 움직임을 별도의 추가 개발 없이 편리하게 Swap 가능합니다.\nmu1, mu2는 마찰력과 관련된 변수로 자세한 설명은 아래 링크를 참고하세요.\n=\u0026gt; https://answers.gazebosim.org//question/13083/explain-gazebo-friction-coefficients-mu-and-mu2/\n다음으로, 아래 작업들을 수행합니다.\n=\u0026gt; fusionbot.trans를 삭제합니다. 해당 파일은 ROS 1에서만 필요한 파일입니다. 이는 ros_control을 gazebo에서 실행할 때 필요한 파일로 ROS 1 시간에 함께 살펴보겠습니다.\n=\u0026gt; fusionbot.xacro를 fusionbot.urdf.xacro으로 이름을 변경합니다. (이후 자동 URDF 생성을 위함입니다.)\n=\u0026gt; 변경한 fusionbot.urdf.xacro를 수정합니다.\n이제, fusionbot.urdf.xacro에서 fusionbot.trans 부분을 삭제합니다. \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/materials.xacro\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/fusionbot.trans\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/fusionbot.gazebo\u0026#34; /\u0026gt; ȸ��7 과 같이 잘못 인코딩된 joint 이름을 적절히 수정합니다. # From \u0026lt;joint name=\u0026#34;��ü3\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 0.0 0.11\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;lidar_1\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;ȸ��7\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 -1.0 0.0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;ȸ��8\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 1.0 0.0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; # To \u0026lt;joint name=\u0026#34;lidar_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 0.0 0.11\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;lidar_1\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;right_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 -1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;left_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; joint 축 방향을 수정합니다. \u0026lt;joint name=\u0026#34;right_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;left_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; 파일 상단 base_footprint link를 추가하고 base_footprint와 base_link를 연결하는 joint를 추가합니다. base_footprint는 추후 자율주행 시 필요한 tf ID로 로봇 중심에서 바닥면에 projection한 위치를 뜻합니다. \u0026lt;link name=\u0026#39;base_footprint\u0026#39; /\u0026gt; ... \u0026lt;joint name=\u0026#39;base_link_joint\u0026#39; type=\u0026#39;fixed\u0026#39;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_footprint\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; mesh 파일의 uri와 xacro 라인의 package명을 여러분의 패키지로 수정합니다. # From \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/materials.xacro\u0026#34; /\u0026gt; ... \u0026lt;mesh filename=\u0026#34;package://fusionbot_description...\u0026#34; /\u0026gt; # To \u0026lt;xacro:include filename=\u0026#34;$(find temp_description)/urdf/materials.xacro\u0026#34; /\u0026gt; ... \u0026lt;mesh filename=\u0026#34;package://temp_description...\u0026#34; /\u0026gt; 색상을 입히고 싶다면 materials.xacro를 수정합니다. (Gazebo는 고유한 색상 체계를 갖고 있습니다. 이는 링크를 참고합니다.) \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34;\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.700 0.700 0.700 1.000\u0026#34; /\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;white\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;1 1 1 0.6\u0026#34; /\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0 0 0 0.7\u0026#34; /\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;1 0 0 1\u0026#34; /\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;material name=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0 0 0.8 1\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; \u0026lt;/robot\u0026gt; CMakeLists.txt를 수정합니다. ament_package() 이전 아래 코드를 추가하시면 됩니다. ## Install install(DIRECTORY meshes urdf DESTINATION share/${PROJECT_NAME} ) ** ament_package() 작업을 마친 뒤, colcon build를 한차례 실시합니다. cd ~/ros2_ws colcon build --packages-select temp_description source install/local_setup.bash CMakeLists.txt에 다음 라인을 추가한 뒤 다시 한 번 colcon build를 실시합니다. find_package(xacro REQUIRED) # Xacro files file(GLOB xacro_files urdf/*.urdf.xacro) foreach(it ${xacro_files}) # remove .xacro extension string(REGEX MATCH \u0026#34;(.*)[.]xacro$\u0026#34; unused ${it}) set(output_filename ${CMAKE_MATCH_1}) # create a rule to generate ${output_filename} from {it} xacro_add_xacro_file(${it} ${output_filename}) list(APPEND urdf_files ${output_filename}) endforeach(it) add_custom_target(media_files ALL DEPENDS ${urdf_files}) ⇒ 이 과정이 필요한 이유는 다음과 같습니다.\n첫번째 colcon build로 필요 파일들의 symbolic link가 install 폴더 내 생성됩니다. 두번째 colcon build 시 CMakeLists.txt에 작성한 xacro 빌드 스크립트를 통해 xacro ⇒ urdf로 변환되며, 이 과정에서 CMake는 install 폴더 내 symbolic link들을 필요로 합니다. 만약 첫번째 작업이 없다면, mesh, urdf 관련 파일이 없다는 에러가 발생합니다. 위 과정을 마치면 자동으로 fusionbot.urdf가 생성되며, 이후 해당 urdf는 description과 gazebo 등 다양한 목적으로 사용할 수 있습니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;!-- | This document was autogenerated by xacro from /home/kimsooyoung/ros2_ws/src/du2023-gz/test_description/urdf/fusionbot.urdf.xacro | --\u0026gt; \u0026lt;!-- | EDITING THIS FILE BY HAND IS NOT RECOMMENDED | --\u0026gt; \u0026lt;!-- =================================================================================== --\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34;\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34;\u0026gt; \u0026lt;color rgba=\u0026#34;0.700 0.700 0.700 1.000\u0026#34;/\u0026gt; \u0026lt;/material\u0026gt; ... Description launch 실행해보기 robot state publisher와 joint_state_publisher_gui를 통해 robot_description topic을 생성하고 rviz를 통해 이를 시각화해봅시다.\n예시를 위해 아래와 같은 폴더 구조가 필요합니다. (launch 폴더와 rviz 폴더를 추가하였습니다.) launch 폴더를 생성하고, 해당 폴더 내부에 launch 파일을 작성해볼 것입니다. 필요한 Node는 아래와 같은 3개 이며, fusionbot_description.launch.py를 참고하여 직접 launch file을 작성해보세요! return LaunchDescription([ joint_state_publisher_gui, robot_state_publisher, rviz, ]) rviz 폴더도 생성하고 기존 fusionbot_description에서 config 파일을 가져옵니다. 새로운 폴더가 추가되면 항상 CMakeLists.txt를 수정해야 합니다. ## Install install(DIRECTORY meshes urdf launch rviz DESTINATION share/${PROJECT_NAME} ) 패키지를 빌드한 뒤, 여러분이 작성한 launch file을 실행해보세요! colcon build --symlink-install --packages-select temp_description source install/local_setup.bash ros2 launch temp_description description.launch.py "
},
{
	"uri": "/kr/ros_and_gazebo/lecture2/",
	"title": "Lecture2 - Gazebo and Robot(2)",
	"tags": [],
	"description": "",
	"content": "FusionBot과 Gazebo Description 예시를 통해 URDF에 대해 습득하였다면, 이제 Gazebo에 로봇을 등장시키고, 이동, 센싱을 구현할 차례입니다. FusionBot을 통해 실습을 진행해보고, 이전 예시에서의 로봇들도 함께 분석해 보겠습니다.\n강의에서는, Gazebo에서 로봇을 등장시키는 2가지 방법을 제시하고자 합니다.\nXacro 파일을 통한 로봇 Spawn URDF 파일을 통한 로봇 Spawn 두 방식 모두 launch file에서 실행되는 Node들은 동일합니다.\ngazebo_ros를 통해 gazebo server와 client를 실행하고 robot_state_publisher와 joint_state_publisher를 통해 robot_description topic을 준비합니다. 마지막으로, gazebo_ros에서 제공하는 spawn_entity라는 Node를 통해 로봇을 Gazebo 상에 등장시킵니다. 저는 새로운 예시를 위해 패키지를 분리하고, launch file의 이름을 empty_gazebo.launch.py로 설정하였습니다. LaunchDescription은 아래와 같습니다. (여러분은 패키지를 분리하지 않으셔도 좋습니다.)\nreturn LaunchDescription([ start_gazebo_server_cmd, start_gazebo_client_cmd, robot_state_publisher, joint_state_publisher, spawn_entity, ]) Xacro 파일을 통한 로봇 Spawn Gazebo는 package://를 통한 파일 접근을 인식할 수 없습니다. 따라서, fusionbot.urdf.xacro 파일 안의 관련된 부분을 모두 $(find pkg) 형태로 변형해줍니다. # From \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0038631391370923516 -1.6603718341471133e-17 0.05277089743549162\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;2.3225264704023765\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.00792\u0026#34; ixy=\u0026#34;-0.0\u0026#34; ixz=\u0026#34;-0.000339\u0026#34; iyy=\u0026#34;0.008432\u0026#34; iyz=\u0026#34;-0.0\u0026#34; izz=\u0026#34;0.014814\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;package://temp_description/meshes/base_link.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; # To \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0038631391370923516 -1.6603718341471133e-17 0.05277089743549162\u0026#34;/\u0026gt; \u0026lt;mass value=\u0026#34;2.3225264704023765\u0026#34;/\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.00792\u0026#34; ixy=\u0026#34;-0.0\u0026#34; ixz=\u0026#34;-0.000339\u0026#34; iyy=\u0026#34;0.008432\u0026#34; iyz=\u0026#34;-0.0\u0026#34; izz=\u0026#34;0.014814\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;$(find temp_description)/meshes/base_link.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; xacro 파일의 경로를 탐색한 뒤, robot_description과 호환을 위한 몇가지 변경을 적용하여 argument를 준비합니다. xacro_file = os.path.join(description_pkg_path, \u0026#39;urdf\u0026#39;, \u0026#39;fusionbot.urdf.xacro\u0026#39;) robot_description_content = Command( [ PathJoinSubstitution([FindExecutable(name=\u0026#34;xacro\u0026#34;)]), \u0026#34; \u0026#34;, xacro_file, \u0026#34; \u0026#34;, \u0026#34;name:=fusionbot\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;prefix:=\u0026#39;\u0026#39;\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;is_sim:=true\u0026#34;, ] ) robot_description = {\u0026#34;robot_description\u0026#34;: robot_description_content} 항상 정적 파일이 수정된 다음에는 colcon build를 잊지 맙시다!\nURDF 파일을 통한 로봇 Spawn urdf를 생성하고, 이를 통해 gazebo에서 로봇을 등장시킬 수 있습니다. xacro file ⇒ URDF로의 변환을 진행합니다. cd ~/ros2_ws/src/du2023-gz/\u0026lt;your-pkg\u0026gt;/urdf xacro fusionbot.urdf.xacro \u0026gt; fusionbot.urdf # 혹은 colcon build를 사용해도 됩니다. colcon build --packages-select temp_description 이렇게 만들어진 URDF 파일은 아래와 같이 절대 경로가 삽입되기 때문에 여러분의 환경에서만 사용 가능함에 유의합니다. \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;-0.05 -0.0 -0.11\u0026#34;/\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;/home/kimsooyoung/ros2_ws/install/test_description/share/test_description/meshes/lidar_1.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; URDF 파일을 robot_state_publisher에게 전달하는 방법은 아래와 같습니다. xacro 패키지의 내장 함수를 통해 손쉬운 변환이 가능합니다. urdf_file = os.path.join(description_pkg_path, \u0026#39;urdf\u0026#39;, \u0026#39;fusionbot.urdf\u0026#39;) doc = xacro.parse(open(urdf_file)) xacro.process_doc(doc) robot_description = {\u0026#39;robot_description\u0026#39;: doc.toxml()} 이렇게 두가지 방법을 배우는 까닭은 실제 오픈소스를 사용하다보면 xacro와 urdf를 혼용하여 배포하기 때문입니다.\n이제, 완성된 launch 파일을 통해 gazebo상에 로봇을 등장시켜봅시다. ros2 launch temp_description empty_gazebo.launch.py 지금 등장시킨 로봇은 색도 없고 제어기, 센서도 없기 때문에 단순 질량 덩어리에 불과합니다. 이제부터 로봇에 여러 요소들을 추가하여 실제 로봇과 유사하게 변신시켜보겠습니다.\nGazebo Plugins Gazebo에서 인식할 수 있는 색상을 지정하고, 센서와 제어기를 연동하여 실제 로봇 시뮬레이션을 완성해보고자 합니다. 지금부터 fusionbot.gazebo 파일을 수정하여 이를 구현해봅시다.\n우선, 비교적 쉬운 색상 변경부터 진행해봅시다.\n파일 최상단 여러 색상을 변수로 지정합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;lidar_color\u0026#34; value=\u0026#34;Gazebo/Blue\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;wheel_color\u0026#34; value=\u0026#34;Gazebo/Black\u0026#34; /\u0026gt; 각 Link 내 material 태그 속성으로 선언한 변수를 할당합니다. \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.1\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.1\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;gravity\u0026gt;true\u0026lt;/gravity\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;lidar_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${lidar_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_wheel_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${wheel_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;100000.0\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;100000.0\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; ... 패키지를 빌드한 후 다시 Gazebo launch file을 실행시켜봅시다. 지금부터 다양한 Gazebo Plugin들을 사용하여 로봇과 ROS 사이의 실질적인 연동을 해보겠습니다. 이를 위해 xacro 파일에 새로운 link들을 추가할 예정입니다.\nMono Camera fusionbot.urdf.xacro 수정 - camera_link와 camera_joint 추가 \u0026lt;link name=\u0026#34;camera_link\u0026#34;\u0026gt; \u0026lt;pose\u0026gt;0 0 0 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;/link\u0026gt; ... \u0026lt;joint name=\u0026#34;camera_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.1 0.0 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;camera_link\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 0.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; urdf 폴더 안에 sensors라는 폴더를 추가한 뒤, mono_cam.gazebo를 추가합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;gazebo reference=\u0026#34;camera_link\u0026#34;\u0026gt; \u0026lt;sensor name=\u0026#34;front_camera\u0026#34; type=\u0026#34;camera\u0026#34;\u0026gt; \u0026lt;update_rate\u0026gt;30.0\u0026lt;/update_rate\u0026gt; \u0026lt;visualize\u0026gt;false\u0026lt;/visualize\u0026gt; \u0026lt;always_on\u0026gt;1\u0026lt;/always_on\u0026gt; \u0026lt;camera name=\u0026#34;front_camera\u0026#34;\u0026gt; \u0026lt;!-- math.atan(320 / 687.8065795898438) * 2 --\u0026gt; \u0026lt;horizontal_fov\u0026gt;0.8709216071359963\u0026lt;/horizontal_fov\u0026gt; \u0026lt;image\u0026gt; \u0026lt;width\u0026gt;1280\u0026lt;/width\u0026gt; \u0026lt;height\u0026gt;720\u0026lt;/height\u0026gt; \u0026lt;format\u0026gt;R8G8B8\u0026lt;/format\u0026gt; \u0026lt;!-- \u0026lt;format\u0026gt;B8G8R8\u0026lt;/format\u0026gt; --\u0026gt; \u0026lt;/image\u0026gt; \u0026lt;clip\u0026gt; \u0026lt;near\u0026gt;0.02\u0026lt;/near\u0026gt; \u0026lt;far\u0026gt;300\u0026lt;/far\u0026gt; \u0026lt;/clip\u0026gt; \u0026lt;noise\u0026gt; \u0026lt;type\u0026gt;gaussian\u0026lt;/type\u0026gt; \u0026lt;mean\u0026gt;0.0\u0026lt;/mean\u0026gt; \u0026lt;stddev\u0026gt;0.00007\u0026lt;/stddev\u0026gt; \u0026lt;/noise\u0026gt; \u0026lt;/camera\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_camera.so\u0026#34; name=\u0026#34;camera_controller\u0026#34;\u0026gt; \u0026lt;ros\u0026gt; \u0026lt;!-- \u0026lt;namespace\u0026gt;custom_ns\u0026lt;/namespace\u0026gt; --\u0026gt; \u0026lt;remapping\u0026gt;image_raw:=image_raw\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;camera_info:=camera_info\u0026lt;/remapping\u0026gt; \u0026lt;/ros\u0026gt; \u0026lt;camera_name\u0026gt;front_camera\u0026lt;/camera_name\u0026gt; \u0026lt;frame_name\u0026gt;camera_link\u0026lt;/frame_name\u0026gt; \u0026lt;hack_baseline\u0026gt;0.07\u0026lt;/hack_baseline\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/sensor\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; update_rate data publish rate visualize 시각화 옵션 horizontal_fov 카메라의 화각 image 화질 옵션 noise 센서 노이즈 remapping topic 이름 재설정 camera_name topic의 namespace가 됩니다. frame_name camera가 장착되는 link hack_baseline stereo camera 사용 시 카메라 사이 거리 ⇒ 이렇게 xml 형태의 스크립트를 추가하여 gazebo plugin을 사용할 수 있습니다.\nfusionbot.gazebo 수정 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;lidar_color\u0026#34; value=\u0026#34;Gazebo/Blue\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;wheel_color\u0026#34; value=\u0026#34;Gazebo/Black\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find temp_description)/urdf/sensors/mono_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_control.so\u0026#34; name=\u0026#34;control\u0026#34;/\u0026gt; \u0026lt;/gazebo\u0026gt; 예제 재실행 colcon build --symlink-install --packages-select temp_description source install/local_setup.bash ros2 launch temp_description empty_gazebo.launch.py rviz를 통해 카메라 데이터를 확인해봅시다.\nDepth Camera fusionbot.urdf.xacro 수정 - depth_camera_link와 depth_camera_optical_joint 추가 \u0026lt;link name=\u0026#34;depth_camera_link\u0026#34;\u0026gt; \u0026lt;pose\u0026gt;0 0 0 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;/link\u0026gt; ... \u0026lt;joint name=\u0026#34;depth_camera_optical_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;-1.57079632679 0 -1.57079632679\u0026#34; xyz=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;depth_camera_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;depth_camera_optical_link\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 0.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; urdf 폴더 안에 sensors라는 폴더를 추가한 뒤, depth_cam.gazebo를 추가합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;gazebo reference=\u0026#34;depth_camera_link\u0026#34;\u0026gt; \u0026lt;sensor name=\u0026#34;front_depth_camera\u0026#34; type=\u0026#34;depth\u0026#34;\u0026gt; \u0026lt;update_rate\u0026gt;30.0\u0026lt;/update_rate\u0026gt; \u0026lt;visualize\u0026gt;false\u0026lt;/visualize\u0026gt; \u0026lt;always_on\u0026gt;1\u0026lt;/always_on\u0026gt; \u0026lt;camera name=\u0026#34;front_depth_camera\u0026#34;\u0026gt; \u0026lt;!-- math.atan(320 / 687.8065795898438) * 2 --\u0026gt; \u0026lt;horizontal_fov\u0026gt;0.8709216071359963\u0026lt;/horizontal_fov\u0026gt; \u0026lt;image\u0026gt; \u0026lt;width\u0026gt;1280\u0026lt;/width\u0026gt; \u0026lt;height\u0026gt;720\u0026lt;/height\u0026gt; \u0026lt;format\u0026gt;R8G8B8\u0026lt;/format\u0026gt; \u0026lt;!-- \u0026lt;format\u0026gt;B8G8R8\u0026lt;/format\u0026gt; --\u0026gt; \u0026lt;/image\u0026gt; \u0026lt;clip\u0026gt; \u0026lt;near\u0026gt;0.02\u0026lt;/near\u0026gt; \u0026lt;far\u0026gt;300\u0026lt;/far\u0026gt; \u0026lt;/clip\u0026gt; \u0026lt;noise\u0026gt; \u0026lt;type\u0026gt;gaussian\u0026lt;/type\u0026gt; \u0026lt;mean\u0026gt;0.0\u0026lt;/mean\u0026gt; \u0026lt;stddev\u0026gt;0.00007\u0026lt;/stddev\u0026gt; \u0026lt;/noise\u0026gt; \u0026lt;/camera\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_camera.so\u0026#34; name=\u0026#34;camera_controller\u0026#34;\u0026gt; \u0026lt;ros\u0026gt; \u0026lt;!-- \u0026lt;namespace\u0026gt;custom_ns\u0026lt;/namespace\u0026gt; --\u0026gt; \u0026lt;remapping\u0026gt;front_depth_camera/image_raw:=front_depth_camera/image_raw\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;front_depth_camera/image_depth:=front_depth_camera/image_depth\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;front_depth_camera/camera_info:=front_depth_camera/camera_info\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;front_depth_camera/camera_info_depth:=front_depth_camera/camera_info_depth\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;front_depth_camera/points:=front_depth_camera/points\u0026lt;/remapping\u0026gt; \u0026lt;/ros\u0026gt; \u0026lt;camera_name\u0026gt;front_depth_camera\u0026lt;/camera_name\u0026gt; \u0026lt;frame_name\u0026gt;depth_camera_optical_link\u0026lt;/frame_name\u0026gt; \u0026lt;hack_baseline\u0026gt;0.07\u0026lt;/hack_baseline\u0026gt; \u0026lt;min_depth\u0026gt;0.001\u0026lt;/min_depth\u0026gt; \u0026lt;max_depth\u0026gt;300.0\u0026lt;/max_depth\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/sensor\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; sensor type depth min_depth, max_depth depth 탐지거리 ⇒ depth camera는 camera 좌표계를 사용하기 때문에 별도 joint를 지정해줘야 합니다.\nfusionbot.gazebo 수정 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;lidar_color\u0026#34; value=\u0026#34;Gazebo/Blue\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;wheel_color\u0026#34; value=\u0026#34;Gazebo/Black\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find temp_description)/urdf/sensors/mono_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_gazebo)/urdf/sensors/depth_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_control.so\u0026#34; name=\u0026#34;control\u0026#34;/\u0026gt; \u0026lt;/gazebo\u0026gt; 예제 재실행 colcon build --symlink-install --packages-select temp_description source install/local_setup.bash ros2 launch temp_description empty_gazebo.launch.py ⇒ rviz를 통해 카메라 데이터를 확인해봅시다.\n2D Lidar urdf sensors 폴더 안에 lidar_2d.gazebo를 추가합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;M_PI\u0026#34; value=\u0026#34;3.1415926535897931\u0026#34; /\u0026gt; \u0026lt;gazebo reference=\u0026#34;lidar_1\u0026#34;\u0026gt; \u0026lt;sensor name=\u0026#34;lidar\u0026#34; type=\u0026#34;ray\u0026#34;\u0026gt; \u0026lt;pose\u0026gt;0 0 0 0 0 0\u0026lt;/pose\u0026gt; \u0026lt;always_on\u0026gt;true\u0026lt;/always_on\u0026gt; \u0026lt;visualize\u0026gt;false\u0026lt;/visualize\u0026gt; \u0026lt;update_rate\u0026gt;10\u0026lt;/update_rate\u0026gt; \u0026lt;ray\u0026gt; \u0026lt;scan\u0026gt; \u0026lt;horizontal\u0026gt; \u0026lt;samples\u0026gt;360\u0026lt;/samples\u0026gt; \u0026lt;resolution\u0026gt;1.000000\u0026lt;/resolution\u0026gt; \u0026lt;min_angle\u0026gt;-${M_PI}\u0026lt;/min_angle\u0026gt; \u0026lt;max_angle\u0026gt;${M_PI}\u0026lt;/max_angle\u0026gt; \u0026lt;/horizontal\u0026gt; \u0026lt;/scan\u0026gt; \u0026lt;range\u0026gt; \u0026lt;min\u0026gt;0.15\u0026lt;/min\u0026gt; \u0026lt;max\u0026gt;12.0\u0026lt;/max\u0026gt; \u0026lt;resolution\u0026gt;0.5\u0026lt;/resolution\u0026gt; \u0026lt;/range\u0026gt; \u0026lt;noise\u0026gt; \u0026lt;type\u0026gt;gaussian\u0026lt;/type\u0026gt; \u0026lt;mean\u0026gt;0.0\u0026lt;/mean\u0026gt; \u0026lt;stddev\u0026gt;0.01\u0026lt;/stddev\u0026gt; \u0026lt;/noise\u0026gt; \u0026lt;/ray\u0026gt; \u0026lt;plugin name=\u0026#34;gazebo_ros_head_hokuyo_controller\u0026#34; filename=\u0026#34;libgazebo_ros_ray_sensor.so\u0026#34;\u0026gt; \u0026lt;ros\u0026gt; \u0026lt;remapping\u0026gt;~/out:=scan\u0026lt;/remapping\u0026gt; \u0026lt;/ros\u0026gt; \u0026lt;output_type\u0026gt;sensor_msgs/LaserScan\u0026lt;/output_type\u0026gt; \u0026lt;frame_name\u0026gt;lidar_1\u0026lt;/frame_name\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/sensor\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; horizontal 라이다의 탐지 범위와 샘플 수를 지정합니다. range 탐지거리의 범위입니다. output_type ROS 2에서 사용하는 2D 라이다 데이터입니다. ⇒ 해당 데이터 스펙은 실제 판매중인 rplidar a1을 구현하였습니다.\nfusionbot.gazebo 수정 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;lidar_color\u0026#34; value=\u0026#34;Gazebo/Blue\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;wheel_color\u0026#34; value=\u0026#34;Gazebo/Black\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find temp_description)/urdf/sensors/mono_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_gazebo)/urdf/sensors/depth_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find temp_description)/urdf/sensors/lidar_2d.gazebo\u0026#34; /\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_control.so\u0026#34; name=\u0026#34;control\u0026#34;/\u0026gt; \u0026lt;/gazebo\u0026gt; 예제 재실행 colcon build --symlink-install --packages-select temp_description source install/local_setup.bash ros2 launch temp_description empty_gazebo.launch.py ⇒ rviz를 통해 라이다 데이터를 확인해봅시다.\n비슷한 맥락에서, 3D lidar와 GPS, IMU 등 다양한 센서를 추가할 수 있습니다.\ngps : https://github.com/RB2023ROS/du2023-gz/blob/main/fusionbot_gazebo/urdf/sensors/gps.gazebo imu : https://github.com/RB2023ROS/du2023-gz/blob/main/fusionbot_gazebo/urdf/sensors/imu.gazebo 3d lidar : https://github.com/RB2023ROS/du2023-gz/blob/main/fusionbot_gazebo/urdf/sensors/lidar_3d.gazebo 이렇게 센서를 추가하는 방법은 gazebo_ros_pkg의 wiki 페이지를 참고하였습니다. 해당 페이지에는 ROS 1과 ROS 2에서의 사용법 차이점, 그리고 예시 world까지 안내하고 있습니다. ⇒ gazebo_ros_pkgs\nDiff Drive Controller 로봇 청소기와 같이 제자리 회전이 가능하며, 양쪽 바퀴 회전수 차이로 로봇을 이동시키는 타입을 DD Type이라고 부릅니다. gazebo_ros에서 제공되는 DD controller를 사용하여 Fusionbot이 이동할 수 있게 해보겠습니다.\nurdf 폴더 내부에 diff_drive.gazebo 파일을 추가한 뒤, 아래 내용을 붙여넣기 합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin name=\u0026#39;fusionbot_joint_state\u0026#39; filename=\u0026#39;libgazebo_ros_joint_state_publisher.so\u0026#39;\u0026gt; \u0026lt;ros\u0026gt; \u0026lt;remapping\u0026gt;~/out:=joint_states\u0026lt;/remapping\u0026gt; \u0026lt;/ros\u0026gt; \u0026lt;update_rate\u0026gt;30\u0026lt;/update_rate\u0026gt; \u0026lt;joint_name\u0026gt;right_wheel_joint\u0026lt;/joint_name\u0026gt; \u0026lt;joint_name\u0026gt;left_wheel_joint\u0026lt;/joint_name\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin name=\u0026#39;differential_drive_controller\u0026#39; filename=\u0026#39;libgazebo_ros_diff_drive.so\u0026#39;\u0026gt; \u0026lt;update_rate\u0026gt;30\u0026lt;/update_rate\u0026gt; \u0026lt;left_joint\u0026gt;left_wheel_joint\u0026lt;/left_joint\u0026gt; \u0026lt;right_joint\u0026gt;right_wheel_joint\u0026lt;/right_joint\u0026gt; \u0026lt;wheel_separation\u0026gt;0.2\u0026lt;/wheel_separation\u0026gt; \u0026lt;wheel_diameter\u0026gt;0.1\u0026lt;/wheel_diameter\u0026gt; \u0026lt;max_wheel_torque\u0026gt;50\u0026lt;/max_wheel_torque\u0026gt; \u0026lt;max_wheel_acceleration\u0026gt;1.0\u0026lt;/max_wheel_acceleration\u0026gt; \u0026lt;command_topic\u0026gt;cmd_vel\u0026lt;/command_topic\u0026gt; \u0026lt;publish_odom\u0026gt;1\u0026lt;/publish_odom\u0026gt; \u0026lt;publish_odom_tf\u0026gt;1\u0026lt;/publish_odom_tf\u0026gt; \u0026lt;publish_wheel_tf\u0026gt;0\u0026lt;/publish_wheel_tf\u0026gt; \u0026lt;odometry_topic\u0026gt;odom\u0026lt;/odometry_topic\u0026gt; \u0026lt;odometry_frame\u0026gt;odom\u0026lt;/odometry_frame\u0026gt; \u0026lt;robot_base_frame\u0026gt;base_footprint\u0026lt;/robot_base_frame\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; fusionbot.gazebo 파일을 다시 수정하고, launch 파일을 실행시키면 tf와 함께 제어되는 로봇을 확인하실 수 있습니다. (기본적으로 /cmd_vel topic을 통해 로봇을 조종할 수 있습니다.) ROS 1 Gazebo Package 제공드린 zip 파일을 사용해서 ROS 1에서 동작하는 gazebo package를 만들어보겠습니다. ROS 2보다 훨씬 간편합니다. 😊\n연습을 위해 다시 한 번 파일을 다운받겠습니다.\n📂 fusionbot_description.zip\nfusionbot.gazebo을 아래와 같이 수정합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;gazebo\u0026gt; \u0026lt;plugin filename=\u0026#34;libgazebo_ros_control.so\u0026#34; name=\u0026#34;control\u0026#34;/\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.1\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.1\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;gravity\u0026gt;true\u0026lt;/gravity\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;lidar_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;0.2\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;0.2\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;right_wheel_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;100000.0\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;100000.0\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;gazebo reference=\u0026#34;left_wheel_1\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; \u0026lt;mu1\u0026gt;1500\u0026lt;/mu1\u0026gt; \u0026lt;mu2\u0026gt;1500\u0026lt;/mu2\u0026gt; \u0026lt;selfCollide\u0026gt;true\u0026lt;/selfCollide\u0026gt; \u0026lt;/gazebo\u0026gt; \u0026lt;/robot\u0026gt; fusionbot.xacro를 수정합니다. # From \u0026lt;joint name=\u0026#34;��ü3\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 0.0 0.11\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;lidar_1\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;ȸ��7\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 -1.0 0.0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;ȸ��8\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34;/\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34;/\u0026gt; \u0026lt;axis xyz=\u0026#34;-0.0 1.0 0.0\u0026#34;/\u0026gt; \u0026lt;/joint\u0026gt; # To \u0026lt;joint name=\u0026#34;lidar_joint\u0026#34; type=\u0026#34;fixed\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.05 0.0 0.11\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;lidar_1\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;right_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;left_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; joint 축 방향 수정 \u0026lt;joint name=\u0026#34;right_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 -0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;right_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; \u0026lt;joint name=\u0026#34;left_wheel_joint\u0026#34; type=\u0026#34;continuous\u0026#34;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0 0.1 0.05\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;left_wheel_1\u0026#34; /\u0026gt; \u0026lt;axis xyz=\u0026#34;0.0 1.0 0.0\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; base_footprint 추가 \u0026lt;link name=\u0026#39;base_footprint\u0026#39; /\u0026gt; ... \u0026lt;joint name=\u0026#39;base_link_joint\u0026#39; type=\u0026#39;fixed\u0026#39;\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;parent link=\u0026#34;base_footprint\u0026#34; /\u0026gt; \u0026lt;child link=\u0026#34;base_link\u0026#34; /\u0026gt; \u0026lt;/joint\u0026gt; 다시 한 번 description을 실행합니다. 이번에는 launch file이 이름이 바뀌었습니다. catkin build fusionbot_description source devel/setup.bash roslaunch fusionbot_description display.launch ROS 1의 launch file은 xml 문법을 사용했습니다. joint_state_publisher와 robot_state_publisher를 사용하는 부분은 모두 ROS 2와 동일하며, robot_state_publisher는 robot_description을 요구하기 때문에 argument로 지정하고 있습니다.\n# display.launch \u0026lt;launch\u0026gt; \u0026lt;arg default=\u0026#34;$(find fusionbot_description)/urdf/fusionbot.xacro\u0026#34; name=\u0026#34;model\u0026#34;/\u0026gt; \u0026lt;arg default=\u0026#34;true\u0026#34; name=\u0026#34;gui\u0026#34;/\u0026gt; \u0026lt;arg default=\u0026#34;$(find fusionbot_description)/launch/urdf.rviz\u0026#34; name=\u0026#34;rvizconfig\u0026#34;/\u0026gt; \u0026lt;param command=\u0026#34;$(find xacro)/xacro $(arg model)\u0026#34; name=\u0026#34;robot_description\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;use_gui\u0026#34; value=\u0026#34;$(arg gui)\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;joint_state_publisher\u0026#34; pkg=\u0026#34;joint_state_publisher\u0026#34; type=\u0026#34;joint_state_publisher\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;robot_state_publisher\u0026#34; pkg=\u0026#34;robot_state_publisher\u0026#34; type=\u0026#34;robot_state_publisher\u0026#34;/\u0026gt; \u0026lt;node args=\u0026#34;-d $(arg rvizconfig)\u0026#34; name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; required=\u0026#34;true\u0026#34; type=\u0026#34;rviz\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; fusionbot.xacro 수정 - package://를 통한 파일 접근을 모두 $(find pkg) 형태로 변형해줍니다. \u0026lt;link name=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0.0037594591254762827 0.0 0.052804115668456025\u0026#34; /\u0026gt; \u0026lt;mass value=\u0026#34;2.3079643337726483\u0026#34; /\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.00789\u0026#34; ixy=\u0026#34;0.0\u0026#34; ixz=\u0026#34;-0.000325\u0026#34; iyy=\u0026#34;0.008347\u0026#34; iyz=\u0026#34;0.0\u0026#34; izz=\u0026#34;0.01475\u0026#34; /\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;$(find fusionbot_description)/meshes/base_link.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;material name=\u0026#34;silver\u0026#34; /\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision\u0026gt; \u0026lt;origin rpy=\u0026#34;0 0 0\u0026#34; xyz=\u0026#34;0 0 0\u0026#34; /\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;mesh filename=\u0026#34;$(find fusionbot_description)/meshes/base_link.stl\u0026#34; scale=\u0026#34;0.001 0.001 0.001\u0026#34; /\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; ROS 2에서 세팅하였던 센서와 제어 plugin을 다시 ROS 1 버전으로 수정해주어야 합니다. 해당 작업은 gazebo_ros_pkg의 wiki 페이지를 참고하면 되며 이번 예시에서는 카메라 센서 하나 정도만 함께 작업해보겠습니다. ⇒ gazebo_ros_pkg \u0026lt;plugin name=\u0026#34;plugin_name\u0026#34; filename=\u0026#34;libgazebo_ros_camera.so\u0026#34;\u0026gt; \u0026lt;alwaysOn\u0026gt;true\u0026lt;/alwaysOn\u0026gt; \u0026lt;updateRate\u0026gt;0.0\u0026lt;/updateRate\u0026gt; \u0026lt;robotNamespace\u0026gt;custom_ns\u0026lt;/robotNamespace\u0026gt; \u0026lt;cameraName\u0026gt;custom_camera\u0026lt;/cameraName\u0026gt; \u0026lt;imageTopicName\u0026gt;custom_image\u0026lt;/imageTopicName\u0026gt; \u0026lt;cameraInfoTopicName\u0026gt;custom_info\u0026lt;/cameraInfoTopicName\u0026gt; \u0026lt;frameName\u0026gt;custom_frame\u0026lt;/frameName\u0026gt; \u0026lt;hackBaseline\u0026gt;0.07\u0026lt;/hackBaseline\u0026gt; \u0026lt;distortionK1\u0026gt;0.1\u0026lt;/distortionK1\u0026gt; \u0026lt;distortionK2\u0026gt;0.2\u0026lt;/distortionK2\u0026gt; \u0026lt;distortionK3\u0026gt;0.3\u0026lt;/distortionK3\u0026gt; \u0026lt;distortionT1\u0026gt;0.5\u0026lt;/distortionT1\u0026gt; \u0026lt;distortionT2\u0026gt;0.5\u0026lt;/distortionT2\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin name=\u0026#34;plugin_name\u0026#34; filename=\u0026#34;libgazebo_ros_camera.so\u0026#34;\u0026gt; \u0026lt;!-- Change namespace, camera name and topics so - * Images are published to: /custom_ns/custom_camera/custom_image * Camera info is published to: /custom_ns/custom_camera/custom_info --\u0026gt; \u0026lt;ros\u0026gt; \u0026lt;namespace\u0026gt;custom_ns\u0026lt;/namespace\u0026gt; \u0026lt;remapping\u0026gt;image_raw:=custom_img\u0026lt;/remapping\u0026gt; \u0026lt;remapping\u0026gt;camera_info:=custom_info\u0026lt;/remapping\u0026gt; \u0026lt;/ros\u0026gt; \u0026lt;!-- Set camera name. If empty, defaults to sensor name (i.e. \u0026#34;sensor_name\u0026#34;) --\u0026gt; \u0026lt;camera_name\u0026gt;custom_camera\u0026lt;/camera_name\u0026gt; \u0026lt;!-- Set TF frame name. If empty, defaults to link name (i.e. \u0026#34;link_name\u0026#34;) --\u0026gt; \u0026lt;frame_name\u0026gt;custom_frame\u0026lt;/frame_name\u0026gt; \u0026lt;hack_baseline\u0026gt;0.07\u0026lt;/hack_baseline\u0026gt; \u0026lt;!-- No need to repeat distortion parameters or to set autoDistortion --\u0026gt; \u0026lt;/plugin\u0026gt; ⇒ ROS 1에 존재했던 태크들이 대부분 ROS 2넘어가면서 중복 제거와 재편성이 되었습니다. 해당 부분을 참고하여 우리 상황에 맞게 수정을 해보겠습니다.\n모든 작업이 완료된 패키지 압축 파일을 제공드리니 실습 도중 오류가 발생하면 참고하시기 바랍니다.\n이제 모든 plugin들을 추가하였으니, fusionbot.gazebo파일에 include를 작성해주면 urdf 수정은 끝이 납니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;robot name=\u0026#34;fusionbot\u0026#34; xmlns:xacro=\u0026#34;http://www.ros.org/wiki/xacro\u0026#34; \u0026gt; \u0026lt;xacro:property name=\u0026#34;body_color\u0026#34; value=\u0026#34;Gazebo/Silver\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;lidar_color\u0026#34; value=\u0026#34;Gazebo/Blue\u0026#34; /\u0026gt; \u0026lt;xacro:property name=\u0026#34;wheel_color\u0026#34; value=\u0026#34;Gazebo/Black\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/mono_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/depth_cam.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/lidar_2d.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/lidar_3d.gazebo\u0026#34; /\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/imu.gazebo\u0026#34; /\u0026gt; \u0026lt;!-- hector_gazebo doesn\u0026#39;t supports noetic --\u0026gt; \u0026lt;!-- \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/sensors/gps.gazebo\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;xacro:include filename=\u0026#34;$(find fusionbot_description)/urdf/controllers/diff_drive.gazebo\u0026#34; /\u0026gt; \u0026lt;gazebo reference=\u0026#34;base_link\u0026#34;\u0026gt; \u0026lt;material\u0026gt;${body_color}\u0026lt;/material\u0026gt; gazebo를 실행시키기 위한 launch file을 만들고 패키지를 재빌드합니다. joint_state_publisher, robot_state_publisher, gazebo_ros와 urdf_spawner를 통해 gazebo 상에 로봇을 최종 등장시키는 launch file 입니다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- Robot pose --\u0026gt; \u0026lt;arg name=\u0026#34;x\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;y\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;z\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;roll\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;pitch\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;yaw\u0026#34; default=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; default=\u0026#34;gcamp_world.world\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;arg name=\u0026#34;world_file\u0026#34; default=\u0026#34;$(find fusionbot_description)/worlds/$(arg world_name)\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;arg name=\u0026#34;model_name\u0026#34; default=\u0026#34;fusionbot\u0026#34;/\u0026gt; \u0026lt;!-- send urdf to param server --\u0026gt; \u0026lt;!-- xacro --\u0026gt; \u0026lt;param name=\u0026#34;robot_description\u0026#34; command=\u0026#34;$(find xacro)/xacro --inorder \u0026#39;$(find fusionbot_description)/urdf/fusionbot.xacro\u0026#39;\u0026#34; /\u0026gt; \u0026lt;!-- urdf or raw xml file --\u0026gt; \u0026lt;!-- \u0026lt;param name=\u0026#34;robot_description\u0026#34; command=\u0026#34;cat $(find museumGuide)/urdf_model/peoplebot.xml\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- Send fake joint values--\u0026gt; \u0026lt;node name=\u0026#34;joint_state_publisher\u0026#34; pkg=\u0026#34;joint_state_publisher\u0026#34; type=\u0026#34;joint_state_publisher\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;use_gui\u0026#34; value=\u0026#34;False\u0026#34;/\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;!-- Send robot states to tf --\u0026gt; \u0026lt;node name=\u0026#34;robot_state_publisher\u0026#34; pkg=\u0026#34;robot_state_publisher\u0026#34; type=\u0026#34;robot_state_publisher\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;!-- Launch Gazebo World --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;!-- Spawn My Robot --\u0026gt; \u0026lt;node name=\u0026#34;urdf_spawner\u0026#34; pkg=\u0026#34;gazebo_ros\u0026#34; type=\u0026#34;spawn_model\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; args=\u0026#34;-urdf -param robot_description -model $(arg model_name) -x $(arg x) -y $(arg y) -z $(arg z) -R $(arg roll) -P $(arg pitch) -Y $(arg yaw)\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 현재는 주석처리가 되어 있지만 여러분의 world를 만들어 보시고 world 폴더 내 위치시킨 다음 해당 world에서 로봇을 등장시키는 실습도 해보시기 바랍니다.\nWorld Extensive github에는 다른 사람들이 만들어 둔 다양한 gazebo world들이 있습니다. 이들을 사용하는 방법을 익혀두면 여러분의 수고를 덜면서 더욱 다채로운 예시를 실행할 수 있습니다.\n이번에 사용해볼 world는 clearpath의 cpr_gazebo 패키지안에 존재합니다. 해당 repo를 clone하고 빌드하겠습니다. cd ~/catkin_ws/src git clone https://github.com/clearpathrobotics/cpr_gazebo.git cd ~/catkin_ws catkin build cpr_office_gazebo source devel/setup.bash 이제, 우리의 launch file을 수정해보겠습니다. 제가 uncomment 라고 해둔 라인 아래를 주석 해제 하신 뒤 마지막 부분에 아래의 라인을 추가하십니다. \u0026lt;!-- Spawn Structure --\u0026gt; \u0026lt;param name=\u0026#34;office_geom\u0026#34; command=\u0026#34;$(find xacro)/xacro --inorder \u0026#39;$(find cpr_office_gazebo)/urdf/office_construction_geometry.urdf.xacro\u0026#39;\u0026#34; /\u0026gt; \u0026lt;node name=\u0026#34;office_world_spawner\u0026#34; pkg=\u0026#34;gazebo_ros\u0026#34; type=\u0026#34;spawn_model\u0026#34; args=\u0026#34;-urdf -model office_construction_geometry -param office_geom -x 0 -y 0 -z 0 -Y 0\u0026#34; /\u0026gt; 이제 마지막 예시를 실행해보겠습니다.\ncatkin build fusionbot_description source devel/setup.bash # Terminal 1 roslaunch fusionbot_description gazebo.launch # Terminal 2 rviz 다채로운 시뮬레이션 world에서 plugin을 통해 추가했던 수많은 센서 데이터들을 rviz를 사용하여 마음껏 시각화해보시기 바랍니다. 😃 "
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]