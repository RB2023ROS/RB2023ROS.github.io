[
{
	"uri": "/kr/ros_basic_noetic/",
	"title": "ROS Basics",
	"tags": [],
	"description": "",
	"content": "\nLecture1. Lecture1 - Introduction to ROS Lecture2. Dev Env Setup Lecture3. Core of ROS Lecture4. ROS Launch, RViz Lecture5. First Programming, ROS Topic Lecture6. ROS Service, Parameter Lecture7. Rqt Tools and rosbag, ROS Time Lecture8. Deal with Open Source Projects, Custom Interfaces Lecture9. ROS TF and Examples Lecture10. TF2 Examples, Outro "
},
{
	"uri": "/kr/ros2_basic_foxy/",
	"title": "ROS 2 Basics",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "/kr/",
	"title": "2023 Road Balance ROS Lecture Note",
	"tags": [],
	"description": "",
	"content": "2023 ROAD BALANCE ROS LECTURE NOTE 본 사이트는 2023년 Road Balance의 ROS/ROS 2 강의에 사용되는 강의 노트입니다.\n현재까지 정리된 강의는 다음과 같습니다.\nCurrently Organized Lectures\u0026hellip;\nLecture 1. Course Introduction \u0026amp; Java Basics Lecture 2. Classes and Objects, Static, Types Lecture 3. Defining \u0026amp; Instantiating, Static vs Non-static, Managing - Complexity, Primitive Types Lecture 4. Unit Testing Lecture 5. Linked List (IntList \u0026amp; SLList), PUBLIC VS PRIVATE, Nested Classes, List \u0026amp; Array Lecture 6. Doubly Linked List, Generic Lists, AList Lecture 7. Inheritance and Interface, Overriding and Overloading Lecture 8. Java Built in Interfaces, Set, Exception, Iteration and Useful Class Methods "
},
{
	"uri": "/kr/ros_basic_noetic/lecture1/",
	"title": "Lecture1 - Introduction to ROS",
	"tags": [],
	"description": "",
	"content": "What is ROS? ROS란, 로봇 소프트웨어 개발에 사용되는 일종의 프레임워크입니다.\n프레임워크라는 말은, ROS 나름대로의 실행 시나리오를 갖고 있다는 뜻입니다.\n사용자인 우리들은, 이 시나리오를 사용하여 로봇을 다루는 우리만의 Application을 만들게 됩니다.\nimage from : wikimedia 그런데 왜 OS라는 이름이 붙게 되었을까요?\n로봇을 실행하기 위해서, 수많은 프로그램들이 실행되며, ROS는 이들 사이의 우선순위와, 프로그램 사이의 데이터 흐름을 책임집니다. 이 작업은 스케쥴링이라고 불리며, 이러한 동작을 수행하는 시스템을 Operating System이라고 부르기 때문에 ROS라는 이름을 갖게 되었습니다.\nimage from : tutorialspoint 로봇을 개발하기 위해서 어떠한 프로그램들이 필요할까요?\n로봇이 수행하는 임무들을 크게 3가지로 분류하면 인지, 판단, 제어의 3가지로 나뉩니다.\n인지란, 센서들을 통한 물체 인지, 자기 자신의 위치와 방향 인지, 상황 인지 등 로봇에게 있어 환경과 상호작용하는 과정에 해당합니다. 판단이란, 앞/뒤로 움직일지, 로봇 팔을 뻗을지와 같이 인지를 기반으로 얻은 데이터를 통해 결정을 내리는 작업들이 해당할 것입니다. 제어는 로봇에서 빼놓을 수 없는 영역으로, 로봇은 실제 세상에서 움직이기 때문에, 얼마나 움직일지, 어느정도의 속도로 힘은 얼마나 강하게 줄지 등 물리적인 임무를 포함합니다. 이렇게 로봇 시스템은 무척 복잡하며, 이뿐만 아니라 회로, 설계, 재료, 에너지 등을 고려해야 하는 완성품 로봇은 현대 공학의 집합 그 자체라고 말할 수 있습니다.\nAbout this lecture 이 강의에서 다루고자 하는 부분을 정확히하자면, 인지도 판단도 제어도 아닌, 시스템입니다.\n로봇의 센서, 구동부, 알고리즘이 모두 준비되어 있는 상황에서, 이들을 하나의 시스템으로 엮어주는 역할을 하는 것이 바로 ROS입니다.\nimage from : ROS Industrial ROS라는 시스템의 특성상 정해진 코드와 방법으로 소프트웨어를 개발해야 하며, 대부분 ROS를 다루는 강의라고 하면 이를 지칭합니다. 우리가 배우고자 하는 주된 내용도 바로 이 부분이라고 말할 수 있습니다.\nROS 개념 ROS 커멘드 다루기 ROS 프로그래밍 - Topic, Service, Action etc… 하지만, 여기서 그치지 않고, 저는 좀 더 실질적인 로봇 개발을 이야기하고자 합니다.\n리눅스 시스템 Docker 사용하기 로봇 시뮬레이션 라이브 코딩과 에러 디버깅 학교를 다니다 보면 아무리 많은 이론을 공부하고 머릿속에 집어넣어도, 시험을 치고 나면 모두 사라지곤 합니다. 머리 속에 남는 공부를 위해서는 직접 코딩을 해보고, 프로젝트를 진행해봐야 합니다.\n강의를 수강하기 위해 필요한 선수지식 본 강의는 최대한 많은 분들이 끝까지 이해할 수 있도록 설계되었습니다. 따라서, 최대한 쉽고, 프로그래밍 실력이 출중하지 않아도 모두 완강할 수 있게 진행합니다. 하지만 그럼에도, 아래 코드를 이해할 수 있을 정도의 배경지식은 필요합니다. class OOPNode: def __init__(self): self.counter_ = 0 def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; print(hello_du) self.counter_ += 1 def my_first_oop_node(): oop_node = OOPNode() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except Exception as e: print(e) 파이썬 클래스, 메소드와 인스턴스 for, while, if/else 등 기본 문법 강의 코드와 강의 노트 사용법 강의 도중 사용되는 코드들은 Github Repository를 통해 배포되어 있습니다. 코드 강의 중 지속해서 링크를 해드리며, 강의 시작 전 미리 살펴보시면 더욱 좋습니다.\nhttps://github.com/RB2023ROS/du2023-ros1 강의 노트의 주소는 https://rb2023ros.github.io/kr/ 입니다. 코드와 명령어 등 필요한 리소스를 모두 담고 있으므로 복사/붙여넣기를 활용하여 강의 청취 시간을 절약하시기 바랍니다.\n참고로 해당 노트는 hugo를 사용하여 제작된 웹 페이지임을 밝힙니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture2/",
	"title": "Lecture2 - Dev Env Setup",
	"tags": [],
	"description": "",
	"content": "Develpoment Environment Setup 프로젝트 기반의 강의인 만큼, 개발 환경이 구축되지 않으면 앞으로의 실습을 진행할 수 없습니다. 따라서 이번 파트에 많은 시간을 배정하였고, 힘들 수 있지만 끝까지 따라와주시면 감사합니다.\n준비한 환경은 다음과 같습니다.\nUbuntu Linux 설치와 ROS 설정 wsl2를 기반으로 한 Windows 내 ROS 설정 Docker 기반의 ROS 설정 1,2,3 순서로 추천하는 설정입니다. 1번을 진행하시다가 도저히 못하겠으면 2번으로, 그래도 안되면 3번으로 진행해 주시면 됩니다.\nUbuntu Linux 설치와 ROS 설정 Linux라고 함은 사실 OS 자체라기보다 OS의 기초가 되는 코어 소프트웨어에 가깝습니다. 이 코어를 사용하여 여러 버전의 OS가 개발되었으며 이를 Liunx 배포판 이라고 지칭합니다.\nUbuntu Linux는 리눅스 배포판 중 가장 널리 알려진 배포판으로, 영국의 Software회사인 Canonical과 우분투 재단에서 개발, 유지보수 및 배포를 하고 있습니다.\nimage from : omdriod.com 기존의 Windows 노트북을 사용하고 있었다면 듀얼 부팅이라는 것을 통해 Ubuntu + Windows를 모두 사용 가능합니다. 듀얼 부팅에 방법에 대해선 잘 설명한 영상들이 많으므로 링크로 대체하겠습니다.\nHow to Dual Boot Ubuntu 20.04 LTS and Windows 10 How to Dual Boot Ubuntu and Windows 11 Ubuntu 20.04 설치를 확인 하셨다면 터미널을 실행한 뒤 아래의 명령어들을 실행합니다.\nterminator 설치 sudo apt update sudo apt install terminator -y terminator 화면 분할 예시\nctrl + shift + e : 가로 분할 ctrl + shift + o : 세로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 ROS / ROS 2 한줄 설치 cd ~/ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; … Do you want to install ROS automatically? (y/N): y 다음으로, 시뮬레이션 프로그램인 Gazebo를 설치합니다. Gazebo는 ROS를 관리하는 조직인 OSRF에서 공식 지원하는 로봇 시뮬레이터입니다.\nsudo sh -c \u0026#39;echo \u0026#34;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\u0026#34; /etc/apt/sources.list.d/gazebo-stable.list\u0026#39; wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt update sudo apt install gazebo11 libgazebo11-dev -y sudo apt install ros-foxy-gazebo-ros-pkgs -y 그림와 같이 Gazebo의 화면이 어둡고, 그림자가 보이지 않는다면 호환되는 그래픽 드라이버를 설치해야 합니다.\nsudo ubuntu-drivers autoinstall sudo reboot # 장착된 장치 확인 ubuntu-drivers devices 마지막으로, catkin build system을 사용하기 위해 아래 커멘드 명령어를 실행합니다.\nsudo apt-get install python3-catkin-tools Windows + WSL2 설정 WSL(Windows Subsystem for Linux) 이란, 리눅스용 윈도우 하위 시스템의 약자로, 윈도우 10에서 네이티브로 리눅스 실행 파일(ELF)을 실행하기 위한 호환성 계층입니다.\nWindows10부터 WSL을 지원하며, Windows 2004(20H1) version부터 WLS2를 지원하고 있습니다.\n최신 Windows 업데이트 적용 (\u0026ldquo;Windows Key ⇒ 업데이트\u0026quot;로 이동하여 최신 업데이트를 적용합니다.) powershell을 관리자 권한으로 실행한 뒤, 설치 되어있는 WSL 2를 활성화시킵니다. \u0026gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. \u0026gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 배포 이미지 서비스 및 관리 도구 버전: 10.0.19041.844 이미지 버전: 10.0.19043.1348 기능을 사용하도록 설정하는 중 [==========================100.0%==========================] 작업을 완료했습니다. MS Store로 이동하여 windows terminal을 설치합니다. windows terminal 화면 분할 예시 alt + shift + - : 가로 분할 alt + shift + + : 세로 분할 ctrl + shift + w : 창 닫기 alt + 화살표 : 창 간 이동 다음 링크를 통해 프로그램을 다운받고 WSL 2 Linux 커널 업데이트를 설치/진행 후 재부팅합니다.\n커널 업데이트를 마친 다음, powershell에 아래 커맨드 라인을 입력하여 WSL 2를 기본 사용하도록 설정합니다.\n\u0026gt; wsl --set-default-version 2 WSL 2와의 주요 차이점에 대한 자세한 내용은 https://aka.ms/wsl2를 참조하세요 작업을 완료했습니다. 이 시점에서 발생할 수 있는 문제들을 한차례 살펴보고 가겠습니다.\nwsl --set-default-version 2 에서 작업 완료 메세지가 등장하지 않는 경우 ⇒ 제일 처음 명령어부터 제가 보여드린 예시와 동일한 결과를 얻었는지 확인해보세요\nLinux용 Windows 하위 시스템 설정 여부도 확인합니다.\n지금까지 진행한 작업들이 제대로 설정 되어있는지 확인해봅시다. \u0026gt; wsl -l -v NAME STATE VERSION * Ubuntu-20.04 Running 2 문제가 없다면 MS Store 진입 후, Ubuntu 20.04 버전을 설치합니다. 설치 이후, 열기 버튼을 눌러 초기 실행을 하고 username, password를 설정합니다.\n이 시점에서 발생할 수 있는 문제들도 다시 한차례 살펴보고 가겠습니다.\n‘The WSL Optional Component is not Enabled. Please Enable it and Try again’ 오류가 발생하는 경우 \u0026gt; Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 0x80370102 에러가 발생한 경우 ⇒ 부팅 BIOS에서 가상화 기능을 활성화해줍니다.\n0xc03a001a 에러가 발생한 경우 ⇒ 다음 블로그 포스팅을 참고합니다.\n설치 이후에는 windows terminal에서 Ubuntu Terminal을 선택하여 실행 및 진입이 가능합니다. 설정 탭을 통해 Ubuntu 20.04를 기본 터미널로 설정 후 저장합시다.\nROS / ROS 2를 한줄 설치합니다. $ cd ~/ $ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/kimsooyoung/ros_menu/main/scripts/setup.sh)\u0026#34; Installing Neuron Startup Menu... Cloning into \u0026#39;/home/kimsooyoung/ros_menu\u0026#39;... remote: Enumerating objects: 583, done. remote: Counting objects: 100% (290/290), done. remote: Compressing objects: 100% (193/193), done. remote: Total 583 (delta 179), reused 173 (delta 93), pack-reused 293 Receiving objects: 100% (583/583), 154.50 KiB | 3.22 MiB/s, done. Resolving deltas: 100% (340/340), done. Do you want to install ROS automatically? (y/N): y 설치가 완료되었다면, 앞으로 터미널을 새로 등장시킬 때마다 다음과 같이 사용할 ROS 버전을 묻게 됩니다. GUI 인터페이스 설정 링크를 통해 VcXsrv를 설치합니다. ⇒ https://sourceforge.net/projects/vcxsrv/ 설치 이후, XLaunch를 실행하고, 사진과 같은 설정을 진행합니다. 앞으로 재부팅 시마다 이 설정을 반복해줘야 하며, 종종 Gazebo의 Memory Leak로 인해 화면이 종료되지 않는 경우가 있는데, 이런 경우 XLaunch를 강제 종료해주면 됩니다.\n설정이 잘 되었는지 Gazebo를 실행해봅시다. export GAZEBO_IP=127.0.0.1 export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 export LIBGL_ALWAYS_INDIRECT=0 gazebo 마지막입니다! ~/.bashrc를 수정합니다. echo \u0026#39;export GAZEBO_IP=127.0.0.1\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;):0 \u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export LIBGL_ALWAYS_INDIRECT=0\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 발생할 수 있는 오류 상황들을 살펴보고 가겠습니다.\ngazebo 실행 시 symbol error $ gazebo gazebo: symbol lookup error: /usr/lib/x86_64-linux-gnu/libgazebo_common.so.9: undefined symbol: _ZN8ignition10fuel_tools12ClientConfig12SetUserAgentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE 해결 방법 ⇒ sudo apt upgrade -y libignition-math2\nGazebo 자체가 실행되지 않는 경우\nPC 재시작 후 백신 프로그램을 종료시킵니다. 제어판 ⇒ 시스템 및 보안 ⇒ Windows 방화벽 ⇒ 고급 설정 ⇒ 인바운드 규칙 ⇒ VcXsrv 사용 허용\nGazebo는 실행되지만, Grid (실선)이 등장하지 않는 경우\n안타깝지만 그래픽 드라이버 문제일 가능성이 큽니다. (Window ⇒ 업데이트 확인 진입 후 가장 최신 버전으로 모두 업그레이드를 실행해줍니다.)\nDocker 기반의 ROS 설정 이전 설치 모두 실패하신 경우 사용할 수 있는 최후의 방법이자. MacOS 사용자들을 위한 설정입니다.\ndocker desktop for windows를 설치합니다. ⇒ https://docs.docker.com/desktop/windows/install/ # 설치 확인 \u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 설치 확인 이후 동일한 명령 프롬프트에서 다음 커멘드 라인을 입력하여 도커 이미지를 다운받습니다. (해당 docker image는 강의에 필요한 작업을 제가 미리 준비해둔 것입니다.) docker pull tge1375/du_ros_noetic:0.0.0 docker 이미지를 최초 실행 시, 방금의 명령 프롬프트에서 아래와 같은 커멘드 라인을 입력해 주세요. docker run -it -p 6080:80 --name ros_noetic tge1375/du_ros_noetic:0.0.0 입력 후 링크를 통해 로컬 VNC 서버로 접속이 가능합니다. 첫 실행 시 방화벽 보안 경고가 등장하며, 이때 반드시 엑세스를 허용해줍니다. ⇒ (http://127.0.0.1:6080/) 위와 같은 화면이 등장했다면 noVNC에 접속이 성공한 것입니다.\n최초 명령 프롬프트에서 실행한 이후 다시 실행시키고 싶은 경우, 혹은 중지시키고 싶은 경우 docker desktop을 사용하면 매우 편리하게 작업이 가능합니다. VScode 셋업 VNC내에서의 개발은 매우 불편하기 때문에, VScode를 통해 코드 개발을 하고자 합니다. 다음과 같은 extension들을 설치합시다.\nDocker Docker Explorer Remote Development 설치 이후, cmd + p를 통해 Remote-Containers를 입력하면, 현재 실행 중인 컨테이너의 목록을 조회할 수 있습니다.\n이들 중 원하는 컨테이터를 선택하면, 새로운 vscode가 새로이 실행되며 작업 폴더를 설정하게 됩니다.\nLinux Commands 셋팅한 환경은 모두 리눅스를 기반으로 합니다.\n때문에 최소한의 리눅스 커멘드 지식이 필요하며, 짚고 넘어가겠습니다.\n리눅스 필수 명령어\ncd \u0026lt;디렉토리\u0026gt; : 해당 디렉토리로 이동하기 (절대 경로와 상대 경로, ../ 와 ~/) pwd : 현재 위치한 절대 경로 ls : 현재 디렉토리에 위치하는 모든 파일들 (ls -al 옵션) touch \u0026lt;파일 이름\u0026gt; : 해당 이름을 가진 파일 생성 source : 쉘 스크립트 실행하기 (source ~/.bashrc) 강의를 위해 알아야 할 추가 명령어들\nsudo : root 권한으로 실행하기 apt install / remove / purge : 리눅스 배포 패키지 설치 apt update : apt의 상태를 최신화, 설치된 패키지들을 최신화하는 과정을 포함함 그 외 알아두면 좋은 것들\ntop / htop : 리눅스의 작업 관리자 ps aux : 실행 중인 프로세스 출력 (ps aux | grep ros) tee \u0026lt;파일 이름\u0026gt; : 터미널 로그를 기록하기 xdg-open . : 현재 위치에서 파일 탐색기 열기 강의 중 설정된 Alias 설명\neb : edit bashrc의 약자로 ~/.bashrc 파일을 gedit을 통해 수정할 수 있습니다. sb : source bashrc의 약자로 수정된 ~/.bashrc 파일을 반영시킵니다. killg : 실행중인 Gazebo관련 모든 프로그램을 종료시킵니다. 유용한 프로그램들 설치하기\nsudo apt install gedit sudo apt install terminator -y 코드 에디터와 IDE 추천\nVSCode - https://code.visualstudio.com/ PyCharm - https://www.jetbrains.com/ko-kr/pycharm/download CLion - https://www.jetbrains.com/ko-kr/clion/ 참고자료\nhttps://www.youtube.com/watch?v=DW7l9LHdK5c https://www.lainyzine.com/ko/article/how-to-install-wsl2-and-use-linux-on-windows-10/ https://github.com/Tiryoh/docker-ros2-desktop-vnc https://89douner.tistory.com/123 "
},
{
	"uri": "/kr/ros_basic_noetic/lecture3/",
	"title": "Lecture3 - Core of ROS",
	"tags": [],
	"description": "",
	"content": " 지난 시간 개발환경 세팅을 잘 진행하였는지 확인을 해보면서 강의를 시작해보겠습니다.\n터미널 프로그램을 실행한 뒤, gazebo를 실행해 봅시다.\ngazebo 위 사진과 같은 화면이 나오지 않았다면 설치가 제대로 되지 않은 것입니다.\n다음으로, ROS 설치는 잘 되었는지도 확인해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun rospy_tutorials talker 모든 확인이 끝났다면, 예제 프로그램을 실행시켜보겠습니다.\nHusky Gazebo 예제 패키지 설치 sudo apt-get update sudo apt-get install ros-noetic-husky-desktop sudo apt-get install ros-noetic-husky-simulator 예제 프로그램 실행 # Terminal 1 roslaunch husky_gazebo husky_empty_world.launch # Terminal 2 roslaunch husky_viz view_robot.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py cmd_vel:=/husky_velocity_controller/cmd_vel Terminal 1에서 발생하는 아래 오류는 무시해도 좋습니다.\n모든 실행이 정상 동작하였다면, Terminal 3에서 키보드를 통해 Husky를 제어할 수 있습니다. 로봇이 움직임에 따라 두번째 터미널 결과였던 Rviz에 아래와 같은 변화가 생깁니다. 다음으로, 새로운 터미널에서 아래 커멘드 라인을 실행시켜 봅시다. rosrun rqt_graph rqt_graph 위 그림은 방금 전 실행한 예제 내부적으로 어떠한 동작들이 이루어지고 있었는지를 보여주는 것으로, 강의를 마칠 때면 여러분들은 위 그림이 어떠한 의미를 갖는지 모두 이해하실 수 있을 것입니다.\n다음으로, 터미널을 새로 실행시켜 rosnode list와 rostopic list를 실행시켜 봅시다.\nrosnode list $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rostopic list $ rostopic list /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state /gazebo/set_model_state ... 앞으로의 강의들에서, 위 명령어들이 어떠한 의미를 갖는지 하나하나씩 함께 살펴보겠습니다.\nROS Node ROS는 각 프로세스들을 Node라는 단위로 관리합니다.\n로봇을 움직이는 Node, 센서와 통신하는 Node, 시각화 Node 등 다양한 Node들이 얽혀 로봇 시스템을 구성하게 됩니다. Node들 사이에는 데이터의 송수신이 필요합니다. 이를 담당하는 ROS의 통신 메커니즘들이 있으며 각기 다른 특성을 갖고 있습니다. Node들끼리 데이터를 주고받기 위해서는 어떤 노드가 존재하는지, id는 몇번인지 등의 정보가 공유되어야 할 것입니다. 아래 그림의 ROS Master가 이를 관리해주는 것이라고 이해하시면 됩니다. image from : clearpathrobotics 그렇다면, 방금 우리가 실행한 예시에서도 ROS Master와 Node들이 실행되었겠군요!\n실행되는 Node를 확인하는 방법은 크게 두 가지가 있습니다.\nrosnode command $ rosnode list /base_controller_spawner /ekf_localization /gazebo /gazebo_gui /joy_teleop/joy_node /joy_teleop/teleop_twist_joy /robot_state_publisher /rosout /teleop_twist_keyboard /twist_marker_server /twist_mux rqt_graph rosrun rqt_graph rqt_graph rqt graph를 살펴보면, 동그란 Node와 Node들 사이의 데이터 송수신이 화살표로 표현된 것을 알 수 있습니다. 키보드를 통해 제어 데이터를 송신하는 teleop_twist_keyboard는 gazebo node로 데이터를 보내고 있으며, 따라서 gazebo는 이 데이터를 통해 실제 로봇을 움직이게 되는 것입니다.\n특정 Node에 대해서 더 자세한 정보를 얻고 싶다면, rosnode info 커맨드를 사용합니다. $ rosnode info /base_controller_spawner -------------------------------------------------------------------------------- Node [/base_controller_spawner] Publications: * /rosout [rosgraph_msgs/Log] Subscriptions: * /clock [rosgraph_msgs/Clock] Services: * /base_controller_spawner/get_loggers * /base_controller_spawner/set_logger_level contacting node http://192.168.55.236:33811/ ... Pid: 63764 Connections: * topic: /rosout * to: /rosout * direction: outbound (43329 - 192.168.55.236:34456) [10] * transport: TCPROS * topic: /clock * to: /gazebo (http://192.168.55.236:33853/) * direction: inbound * transport: TCPROS 이전 예제들은 일단 종료시킨 뒤, 간단한 새로운 예시를 실행해봅시다.\n# Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener # Terminal 4 rqt_graph rqt_graph를 보면 talker ⇒ listener로 데이터가 전송되는 것을 알 수 있습니다.\n이제, rqt_graph를 보는 것은 익숙해졌지요?\n첫번째 Gazebo 예시와 다른 점으로 roscore라는 것을 실행해주었습니다.\nroscore는 ROS Master를 실행시키는 명령어로 모든 ROS Node들은 Master에 의해 관리되기 때문에 roscore를 통해 실행시키거나, roslaunch를 사용해야 합니다. ROS Master가 실행되고 있지 않다면, 아래와 같이 오류가 발생합니다. ETH Super Mega Bot \u0026amp; ROS Workspace ROS는 catkin이라는 빌드 시스템을 사용합니다. 기존 c/c++ cross-platform 개발을 경험하셨다면 cmake에 익숙하실텐데, 이와 매우 비슷합니다. catkin을 통해 실행 가능한 프로그램 (C/C++의 빌드), 라이브러리, 인터페이스들을 만들 수 있으며, catkin 시스템을 사용하기 위해서는 workspace라는 특별한 폴더가 필요합니다. ROS 개발을 하다 보면 여러 프로젝트를 동시에 진행하는 경우가 생깁니다. 새로운 작업은 새로운 폴더를 만들어 작업하듯이 ROS 에서도 새로운 프로젝트는 새로운 WorkSpace에서 작업을 수행하는 것이 일반적입니다. 새로운 WS로 이동하게 되면 ROS에게 이러한 변화를 알려줘야 하며 이 명령어가 source devel/setup.bash 입니다. 이번 강의용 WS를 만들어보고, 이후 여러분들만의 WS도 만들어 작업해보세요! 일반적으로 ROS의 workspace는 name_ws라는 이름을 갖는 것이 일반적이며, 우리는 catkin_ws라는 workspace를 만들어보고자 합니다.\n아래 커멘드 라인들을 따라해주세요 cd ~/ mkdir -p catkin_ws/src cd catkin_ws catkin config --init catkin build 다음과 같이 build, devel, src, log 폴더가 만들어집니다. ROS 코드들은 모두 src 폴더 안에 위치하게 됩니다. src 폴더 내부에서 코드 개발 ⇒ catkin을 사용한 빌드 ⇒ build 폴더 내부에 실행 가능한 프로그램 생성의 순서로 개발이 이루어집니다. 실습을 통해 개발 프로세스에 익숙해져봅시다.\n아래 폴더를 catkin_ws/src 안에 압축 해제합니다. Example Packages smb_common.zip (2 ) 터미널 프로그램을 실행시키고 아래 커멘드 라인을 따라합니다. catkin build smb_description catkin build smb_gazebo catkin build smb_control source devel/setup.bash source로 시작하는 마지막 라인은 새로운 빌드 후에 항상 실행해줘야 합니다. 1강을 잘 따라했다면 sds라는 단축어로 사용이 가능합니다.\n예제 프로그램을 실행시킵니다. roslaunch smb_gazebo smb_gazebo.launch 실행 시 붉은 에러 메세지가 나오지만 동작만 된다면 문제 없습니다.\n이 로봇을 한번 움직여 볼까요? - teleop 실행 rosrun teleop_twist_keyboard teleop_twist_keyboard.py 파일 구조 관점에서, ROS Application은 여러 Package들로 이루어집니다. 이들 Package가 소스 파일을 담고 있고, catkin이 이들을 빌드하여 실행 프로그램들을 만들었습니다. 제가 공유한 압축 파일 안에도 3개의 Package가 포함되어있던 것이며, ROS 개발자들은 자신들의 로봇 Package를 개발하고 공유합니다. Package 생성 실습 Package를 생성하는 방법은 다음과 같습니다.\ncd \u0026lt;your-ws\u0026gt;/src catkin_create_pkg \u0026lt;package_name\u0026gt; [depend1] [depend2] [depend3] my_first_package라는 package를 시험삼아 생성해봅시다.\n# exameple $ catkin_create_pkg my_first_package rospy std_msgs Created file my_first_package/package.xml Created file my_first_package/CMakeLists.txt Created folder my_first_package/src Successfully created files in /home/kimsooyoung/catkin_ws/src/my_first_package. Please adjust the values in package.xml. depend에는 해당 패키지의 의존성 패키지들이 나열되며, rospy는 파이썬을 통해 ROS를 사용하기 위한 의존성입니다.\n미리 제공되었던 Package, smb_gazebo를 살펴봅시다.\nGazebo 실행에 필요한 모델 파일과 환경 파일 등 기능별 정리된 모습을 볼 수 있습니다.\n이렇게 Package를 잘 구성해두면 이후 코드의 관리에도 편리하다는 장점이 있습니다.\n참고자료\nhttp://wiki.ros.org/ko/ROS/Tutorials/CreatingPackage https://rsl.ethz.ch/education-students/lectures/ros.html https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture4/",
	"title": "Lecture4 - ROS Launch, RViz",
	"tags": [],
	"description": "",
	"content": "ROS Launch 일전 예시 실행에서 다음과 같은 커멘드 라인을 사용했었습니다.\nroslaunch smb_gazebo smb_gazebo.launch roslaunch란, 다수의 ROS Node들을 한번에 실행할 수 있도록 해주는 툴 입니다.\nroslaunch를 사용하기 위해서는 xml이라는 포멧을 사용하는 launch file이 있어야 하며, 이는 보통 패키지의 launch 폴더에 위치하고 있습니다.\nlaunch file의 구조를 파악해봅시다.\nlaunch파일은 xml이라는 문법을 사용합니다. html을 사용해보셨다면 아시겠지만, \u0026lt;\u0026gt;를 이용하여 라인을 구분하는 포멧입니다. 한 라인에서 끝나는 경우 /\u0026gt;로 맺을 수 있지만, 여러 라인이 필요한 경우에는 여는 태그와 닫는 태그를 사용하여 구분합니다. \u0026lt;tag /\u0026gt; or \u0026lt;tag (value)\u0026gt; ... \u0026lt;/tag\u0026gt; launch file은 시작과 끝, 태그로 감싸집니다.\nnode 태그는 실행되는 ROS Node를 지칭합니다. name 태그는 node를 실행할 때의 이름을 설정하는 부분으로 자유롭게 지정 가능합니다. pkg 태그에는 해당 node가 속해있는 package를 적습니다. type 태그에는 실행가능한 파일, 혹은 프로그램을 적게 되며, c++의 경우 빌드된 프로그램, 파이썬의 경우 파이썬 파일이 됩니다. output 태그는 로그가 출력되는 위치를 지정하며 screen일 시 터미널에 출력됩니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;listener\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;listener.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;talker\u0026#34; pkg=\u0026#34;rospy_tutorials\u0026#34; type=\u0026#34;talker.py\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 이번에는 smb_gazebo.launch를 살펴봅시다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;!-- GAZEBO ARGUMENTS --\u0026gt; \u0026lt;!-- Run Gazebo headless --\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;model_path\u0026#34; default=\u0026#34;$(find smb_gazebo)/\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_namespace\u0026#34; default=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;robot_model_name\u0026#34; default=\u0026#34;smb\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;enable_ekf\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; ... \u0026lt;!-- Load Gazebo world --\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; arg란, argument의 약자이며 launch 파일에서 인자로 작용하는 일종의 변수입니다.\narg 태그를 통해 argument를 선언하고 default를 통해 초기값을 정할 수 있습니다. argument의 선언 후 사용은 **$(arg )**입니다. roslaunch 시 argument를 바꿔 실행이 가능합니다. 예를 들어, smb_gazebo.launch 실행 시. world를 바꾸어 아래와 같이 사용이 가능합니다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school 초기 실행 시 시간이 다소 걸릴 수 있습니다.\n현재 예시에서 제공되는 world는 다음 3가지 입니다.\nroslaunch smb_gazebo smb_gazebo.launch 제작한 launch file을 다시 다른 launch file에서 불러오는 경우가 더러 있습니다.\n이때, include 태그를 사용하며, 패키지 단위를 기반으로 파일의 경로를 가져오게 됩니다.\ninclude하는 launch file의 내부에도 여러 argument들이 있을 것입니다. 이들은 arg 태그를 통해 접근할 수 있습니다.\n\u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;env name=\u0026#34;GAZEBO_MODEL_PATH\u0026#34; value=\u0026#34;$(arg model_path)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_file)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg run_gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;verbose\u0026#34; value=\u0026#34;$(arg verbose)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; html과 마찬가지로 \u0026lt;!-- --\u0026gt; 사이에 오는 코드는 주석으로 무시됩니다.\n단, 주의사항 하나 있습니다. launch 파일을 사용하다보면 --가 종종 쓰이곤 하는데요. 이 경우 주석에 오류가 나니 주의하시기 바랍니다.\nLaunch File을 다루는 연습을 해봅시다.\nsmb_gazebo.launch를 다음과 같이 수정합니다.\nworld를 big_map_summer_school로 수정합니다. 로봇이 등장하는 위치를 다음과 같이 수정합니다. xyz : (-0.5, -1.0, 0.4) yaw angle : 90도 (3.1415를 1 radian으로 잡습니다.) launch file에 rospy_tutorials Package에 있는 talker Node를 추가합니다. Rqt와 RViz ROS에는 로봇의 다양한 센서 데이터들을 시각화해주는 3D 툴이 있으며, 이는 RViz라고 불립니다.\nRviz의 사용법을 알아봅시다.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 rviz 사진과 같이 Gazebo와 RViz가 잘 실행된 상황에서 강의를 따라합니다.\nrviz에서 센서 데이터를 시각화하기 전, 우선 어떤 좌표계를 기준으로 시각화할지 설정해주어야 합니다.\n같은 센서라도 원점 좌표계에서 본 모습과, 센서 좌표계에서 본 모습이 다르기 때문입니다.\nimg from : mathworks 이는 RViz의 Fixed Frame에서 설정 가능합니다. (odom으로 설정해보겠습니다.)\n이제 다양한 시각화 기능들을 사용해보려 합니다.\n기본적으로 데이터의 추가는 왼쪽 하단 Add 버튼으로 실행합니다. tf 시각화 odometry 시각화 point cloud 시각화 이렇게 잘 설정해둔 RViz는 config 포멧으로 추출하여 이후에 다시 사용할 수 있습니다.\nFile ⇒ Save Config를 통해 config를 저장하고, Open Config를 통해 저장한 config를 불러올 수 있습니다.\n아래와 같이 다양한 Plugin을 통해 여러 센서, 로봇 데이터를 시각화할 수 있으며, 자신만의 Plugin을 제작할 수도 있습니다.\n지금까지 여러분들이 만든 RViz 설정을 저장해보고, launch file에 통합해봅시다.\nRViz의 좌측 상단 File 옵션을 사용하여 config file을 저장합니다. 저장 위치는 smb_gazebo/rviz로 지정하겠습니다. (새롭게 폴더를 만들어주었습니다.) 이제, launch file을 수정합시다. 파일 하단 launch 태그가 닫히기 전 부분에 아래와 같은 라인을 추가합니다. \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find smb_gazebo)/rviz/my_config.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; 이제, 다시 Gazebo launch를 해봅시다.\nroslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school Rqt Tools 지금까지 사용한 ROS 툴은 rqt_graph와 RViz가 있었습니다.\n사실 ROS에는 수많은 추가 툴들이 존재하며 이들을 묶어 rqt tools라고 부릅니다.\nrqt image view image from : wiki.ros.org\nrqt multiplot image from : project march\nrqt console image from : wiki.ros.org\nrqt robot steering rqt tf tree image from : rqt tf tree\n이러한 수많은 툴들이 있어 ROS 개발을 편리하게 해주고 있으며, 함께 ROS를 공부하면서 하나씩 같이 살펴보고 사용해보려 합니다.\n참고자료\nhttp://wiki.ros.org/roslaunch https://www.clearpathrobotics.com/assets/guides/noetic/ros/Drive a Husky.html https://rsl.ethz.ch/education-students/lectures/ros.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture5/",
	"title": "Lecture5 - First Programming, ROS Topic",
	"tags": [],
	"description": "",
	"content": "이번 강의부터, 본격적인 프로그래밍이 시작됩니다. 첫번째로 Node의 프로그래밍을 살펴보고자 하며, 시작 전 간단한 복습을 진행하고 시작하겠습니다.\nimage from : clearpathrobotics\nWorkspace와 패키지 # WS 생성 mkdir -p catkin_ws/src cd catkin_ws catkin config --init # Package 생성 catkin_create_pkg \u0026lt;pkg-name\u0026gt; \u0026lt;depend1\u0026gt; \u0026lt;depend2\u0026gt; ... ROS Node Programming C++ 코드는 src 폴더 안에, 파이썬 코드는 scripts라는 폴더 안에 위치시키는 것이 일반적입니다. cd \u0026lt;pkg-name\u0026gt; mkdir scripts 지금부터, 직접 명령어를 한줄씩 따라치면서 실습하셔도 좋고, 제가 미리 준비해둔 Package를 사용하셔도 좋습니다.\n다음으로, 파이썬 코드를 작성하고 패키지를 빌드해봅시다.\ncd scripts # my_first_node.py 생성 첫번째 프로그래밍 코드는 Node의 기본입니다.\n모든 소스코드는 github repo에서 확인 가능합니다.\nmy_first_node.py #!/usr/bin/env python3 import rospy from std_msgs.msg import String def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # ROS safe timer rate = rospy.Rate(10) # 10hz # Loop control Example while not rospy.is_shutdown(): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. rate.sleep() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드를 새로 작성한 다음에는 습관적으로 패키지를 빌드하고 실행합니다. 파이썬 코드의 경우 파일의 실행 권한이 주어져 있어야 합니다. cd scripts chmod +x * cd ~/catkin_ws catkin build my_first_pkg 작성한 node를 실행해봅시다. 반복해서 터미널 로그가 남을 것입니다. # Terminal 1 roscore # Terminal 2 rosrun my_first_package my_first_node.py 코드 분석 첫 코드인 만큼 자세하게 분석하고 넘어가보려 합니다.\nROS Noetic은 Python 3를 사용합니다. 가상환경의 파이썬, 직접 설치한 파이썬 등 여러 버전이 설치되어 있을 것입니다. 공식 문서에서는 이러한 혼란을 방지하기 위해 코드의 제일 처음 아래 라인을 추가하는 것을 추천하고 있습니다. #!/usr/bin/env python3 Python을 사용하여 ROS를 다루기 위해 사용되는 패키지는 rospy입니다. import를 사용해도 좋고 from / import를 통해 특정 클래스만 가져올 수도 있습니다. import rospy from std_msgs.msg import String 당장 사용하지는 않지만 Test Code를 작성해야 하는 경우가 있습니다. 이러한 상황에 대비하기 위해 main 함수를 따로 두고 아래와 같이 프로그램을 시작하기를 권장합니다. if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 이제, my_first_node를 분석해 보겠습니다. Node의 실행을 위해 Master에 등록하고, 초기화하는 작업이 필요하며, 이를 위해 별도로 init_node라는 메소드를 실행해주어야 합니다. def my_first_node(): # ROS nodes require initialization # It contains master registration, uploading parameters rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) ROS 시스템은 기본적으로 무한 Loop입니다. 이 Loop가 한차례 반복되는 주기를 설정하는 부분입니다. ROS의 시간 체계에 대해서는 이후 한번 더 다루겠습니다. # ROS safe timer rate = rospy.Rate(10) # 10hz rospy를 통해 실행 중인 Node의 상태를 확인할 수 있으며, is_shutdown()은 예기치 못한 에러가 발생하거나 사용자의 종료를 인지할 수 있습니다. 10Hz를 맞추기 위해 Loop마다 sleep을 걸어주고 있습니다. # Loop control Example while not rospy.is_shutdown(): ... rate.sleep() ROS에서 콘솔 로그를 얻는 방법으로 print 보다 rospy.log를 사용하기를 추천합니다. hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) # Below line calls sleep method in Python internally. ROS Timer ROS는 기본적으로 무한 Loop를 하나의 프로세스 안에서 동작시키는 프로그램입니다. Timer를 통해 일정 시간마다 동작하는 코드를 구현할 수 있습니다.\ncd my_first_pkg/scripts # spin_node.py 생성 spin_node.py #!/usr/bin/env python3 import rospy # callback method requires event, which is TimerEvent def hello_du(event=None): hello_du = \u0026#34;hello du %s\u0026#34; % rospy.get_time() rospy.loginfo(hello_du) def my_first_node(): rospy.init_node(\u0026#39;my_first_node\u0026#39;, anonymous=True) # Timer Class is kind of Thread. # It\u0026#39;s rule is execute sleep in certain period with given event. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_node() except rospy.ROSInterruptException: pass 코드의 실행 결과는 이전과 같기 때문에 Timer와 spin에 대해서만 짚고 넘어가겠습니다.\nTimer는 크게 두가지 매개변수를 받습니다. 실행 주기와 Callback 함수입니다. 해당 주기마다 Callback 함수를 실행시킵니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) 앞으로 여러분들은 직접 while loop를 구현하기보다 rospy.spin()을 더 많이 사용하시게 될 겁니다. Timer를 선언한 이후, 하나의 Thread에서 막혀버리는 것을 방지하는 역할을 수행합니다. rospy.Timer(rospy.Duration(1.0/100.0), hello_du) rospy.spin() image from : python tutorial\nOOP Node Programming my_first_oop_node.py #!/usr/bin/env python3 import rospy class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: my_first_oop_node() except rospy.ROSInterruptException: pass 이후의 실습들을 위해 한가지 예시만 더 살펴보고자 합니다. 객체 지향을 사용한 ROS Node 작성방법입니다. 파이썬에서 OOP를 사용하기 위해 Class 키워드를 사용하며, self등 OOP와 관련된 내용은 모두 알고 있다는 상태에서 진행하겠습니다.\nOOP를 사용하면 main 메소드가 매우 간편해진다는 장점이 있습니다. 클래스를 생성하고, spin을 하기만 하면 됩니다. def my_first_oop_node(): rospy.init_node(\u0026#39;my_first_oop_node\u0026#39;, anonymous=True) oop_node = OOPNode() rospy.spin() OOP로 전환되면서 변경된 구현에 주목합시다. Timer의 Callback 함수로 클래스 메소드가 사용되었으며, 클래스 변수인 counter를 사용하여 구현한 점에 주목합니다. class OOPNode: def __init__(self): self.counter_ = 0 self.timer_ = rospy.Timer(rospy.Duration(1.0/100.0), self.hello_du) def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.loginfo(hello_du) self.counter_ += 1 앞으로, 대부분의 코드는 OOP 기반으로 작성됩니다. 파이썬의 클래스에 대해 숙지가 되어있지 않다면 꼭 복습하고 다음 강의를 청취하세요!\nROS Topic 다시 개념 학습으로 돌아와보았습니다. 아래 그림은 지난 강의의 rqt_graph입니다.\n위 그림에서 동그라미는 Node를 뜻하고, 화살표는 topic을 뜻합니다.\n이번 시간에는 이 Topic이 무엇인지 배워보고자 합니다.\nTopic은 Node들 사이에 데이터(Message)가 오가는 길(Bus)의 이름입니다. image from : docs.ros.org 그림에서와 같이 ROS Topic은\nPublisher(발행자) Subscriber(구독자)로 나누어 Topic의 송신, 수신자를 구분합니다. Publisher, Subscriber는 Node안에서 생성되며 별도로 사용할 수는 없습니다. Pub/Sub 사이에 Message가 전달되며, 이 길의 이름이 Topic인 것입니다. 주의할 점은, Publisher, Subscriber는 오로지 Topic의 이름으로 소통한다는 것입니다. 어떤 Node에 publish 할지 Publisher는 전혀 모르며 오로지 Topic이 같은 Subscriber가 데이터를 받게 됩니다. 더불어, Topic은 여러 Node들로 부터 데이터를 받을 수 있고, 전송 시에도 여러 Node들에게 전송이 가능한 방식입니다. ⇒ Topic의 중요한 속성이니 꼭 알아두셨으면 좋겠습니다.\nimage from : docs.ros.org Node와 Topic의 개념을 다시 한 번 다잡고 갑시다.\nNode는 실행되는 프로그램이며, ROS Master에 등록하고 관리됩니다. Node들 사이의 통신 메커니즘 중 Topic이라는 것이 있으며, 이는 Publisher와 Subscriber라는 개념을 갖고 있습니다. Publisher와 Subscriber 사이의 오가는 데이터는 특정한 타입을 갖습니다. 이를 Message라고 부릅니다. Topic Message 로봇 프로그래밍 시에는 다양한 센서 데이터들이 다뤄집니다. 센서 뿐만 아니라, 제어 데이터도 주고 받아야 합니다. ROS에서는 주로 사용되는 이러한 데이터 형식을 Message라는 이름으로 지칭하며, 여러 기본 형태를 제공합니다. 더불어 사용자가 직접 Message를 커스터마이징할 수도 있습니다.\n일전 예시의 분석을 통해 Topic과 Message에 대해 다시 한 번 살펴봅시다. # Terminal 1 roscore # Terminal 2 rosrun roscpp_tutorials talker # Terminal 3 rosrun roscpp_tutorials listener 두 프로그램이 실행되고 있는 상태를 유지하면서, 아래 내용을 따라와주세요\nrostopic list를 통해 사용중인 topic들을 모두 조회 가능합니다. $ rostopic list /chatter /rosout /rosout_agg 특정 topic에 대한 자세한 정보를 알고 싶다면 rostopic info를 사용합니다. talker와 listener가 조회된 모습도 보입니다. $ rostopic info /chatter Type: std_msgs/String Publishers: * /talker_215337_1671763968667 (http://192.168.55.236:37863/) Subscribers: * /listener_215355_1671763970127 (http://192.168.55.236:44969/) 해당 topic이 사용중인 Message를 조회하기 위해 rostopic type을 사용합니다. $ rostopic type /chatter std_msgs/String rosmsg show를 통해 Message의 원형을 확인할 수 있습니다. $ rosmsg show std_msgs/String string data topic 데이터를 엿볼 수 있는 rostopic echo입니다. $ rostopic echo /chatter data: \u0026#34;hello world 1671764088.1913402\u0026#34; --- data: \u0026#34;hello world 1671764088.2913551\u0026#34; --- ... rostopic hz로 topic의 pub/sub 주기를 분석할 수 있습니다. $ rostopic hz /chatter subscribed to [/chatter] average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00014s window: 10 average rate: 9.999 min: 0.099s max: 0.100s std dev: 0.00023s window: 20 마지막으로 rqt_graph를 다시 한 번 살펴봅시다.\nrqt_graph 방금 살펴본 커멘드 라인들을 충분히 숙지하시기 바랍니다. 그러한 의미에서, 이번에는 Gazebo 예시를 분석해볼까 합니다.\n# Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun teleop_twist_keyboard teleop_twist_keyboard.py rostopic list 결과 $ rostopicist /clicked_point /clock /cmd_vel /diagnostics /e_stop /gazebo/link_states /gazebo/model_states /gazebo/parameter_descriptions /gazebo/parameter_updates /gazebo/performance_metrics /gazebo/set_link_state ... 우리가 집중하고자 하는 topic은 로봇을 제어하는 /cmd_vel입니다.\nrostopic info 결과 $ rostopic info /cmd_vel Type: geometry_msgs/Twist Publishers: * /teleop_twist_keyboard (http://192.168.55.236:33903/) Subscribers: * /twist_mux (http://192.168.55.236:38201/) * /gazebo (http://192.168.55.236:33033/) rostopic type 결과 $ rostopic type /cmd_vel geometry_msgs/Twist geometry_msgs/Twist의 rosmsg show 결과 $ rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z /scan의 rostopic echo 결과 $ rostopic echo /scan header: seq: 0 stamp: secs: 204 nsecs: 678000000 frame_id: \u0026#34;rslidar\u0026#34; angle_min: -1.5707999467849731 angle_max: 1.5707999467849731 angle_increment: 0.008700000122189522 time_increment: 0.0 scan_time: 0.033330000936985016 range_min: 0.44999998807907104 range_max: 50.0 ranges: [inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, ... /scan의 rostopic hz결과 $ rostopic hz /scan subscribed to [/scan] WARNING: may be using simulated time average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 8 average rate: 10.000 min: 0.100s max: 0.100s std dev: 0.00000s window: 17 rqt_graph에서 /cmd_vel을 찾아볼까요?\nrqt_graph Publisher 프로그래밍 이번 시간 사용할 Package는 py_topic_pkg 입니다. 실습 전 실행부터 해보겠습니다.\nPackage Build cd ~/catkin_ws catkin build py_topic_pkg source devel/setup.bash 예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg cmd_vel_pub.py 로봇이 아래와 같이 원을 그리며 움직일 것입니다.\ncmd_vel_pub.py #!/usr/bin/env python3 import rospy from geometry_msgs.msg import Twist class CmdVelPubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. topic queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) self.twist_ = Twist() def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) def cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: cmd_vel_node() except rospy.ROSInterruptException: pass 파이썬 ros 프로그래밍을 위한 rospy, 로봇의 속도 제어에 필요한 Message type인 Twist를 import 하고 있습니다. import rospy from geometry_msgs.msg import Twist rospy.Publisher를 통해 publisher를 생성할 수 있습니다. 이는 최소 3개의 매개변수를 필요로 합니다. topic 이름 topic type queue size self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10)= 우리는 로봇의 제어 신호를 주기적으로 전송하고자 합니다. 따라서 Timer도 선언하였습니다. self.timer_ = rospy.Timer(rospy.Duration(1.0/10.0), self.pub_msg) 다음으로, Message Type인 geometry_msgs/Twist 값을 채웁니다. 현재 우리 로봇은 2차원 평면에서 움직이며, 로봇 형태 때문에 앞뒤 선속도와 각속도를 갖게 됩니다. ... self.twist_ = Twist() def pub_msg(self, event=None): self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 Message의 종류는 매우 많습니다. 구글을 통해 검색하면서 코딩하는 습관을 들여봅시다.\nfrom : http://docs.ros.org/ linear의 단위는 m/s 이며, angular의 단위는 rad/s 입니다. pi = 3.14\n마지막, 가장 중요한 topic publish는 생성한 Publisher의 publish() 메소드를 사용합니다. 미리 준비해둔 topic message를 사용합시다. def pub_msg(self, event=None): # geometry_msgs.Twist # ref: http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/Twist.html self.twist_.linear.x = 0.5 self.twist_.angular.z = 1.0 self.cmd_vel_pub_.publish(self.twist_) 이 Node를 실행하면, 우리의 ROS가 일정 주기에 맞추어 알맞게 topic publish를 실행시켜줄 것입니다. 우리는 정해진 구현에 맞추어 코드만 작성하면 되는 것이지요 😊\ndef cmd_vel_node(): rospy.init_node(\u0026#39;cmd_vel_node\u0026#39;, anonymous=True) cmd_vel_pub_node = CmdVelPubNode() rospy.spin() Subscriber 프로그래밍 이번 예시에는 로봇에 장착된 라이다 센서를 사용해보려 합니다. 예시를 실행해보겠습니다. # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_topic_pkg laser_scan_sub.py 실행 이후, 영상과 같이 박스를 로봇의 전방에 배치해봅시다. 터미널에 등장하는 문구에 집중해보세요. 박스가 추가되면서 출력창에 어떠한 변화가 생기나요?\n로봇에 부착된 라이다 센서는 전방 180도 사방으로 360개의 레이저를 흩뿌립니다.\n레이저의 특성상 물체를 맞고 되돌아오게 되며, 이 시간을 통해 물체와의 거리를 알 수 있습니다.\n예시의 프로그램은 로봇에 부착된 레이저에서 publish되는 데이터를 subscribe한 것입니다. 이를 프로그래밍하면서 python으로 subscriber를 다루는 방법에 대해 배워봅시다.\nlaser_scan_sub.py #!/usr/bin/env python3 import rospy from sensor_msgs.msg import LaserScan class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) def laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: laser_sub_node() except rospy.ROSInterruptException: pass 이번에 사용하는 topic message는 sensor_msgs/LaserScan입니다. import rospy from sensor_msgs.msg import LaserScan subscriber는 publisher와 달리 Timer가 필요하지 않습니다. publish되는 데이터가 없으면 아무 동작을 할 수 없으며, publish 주기에 맞추어 subscribe할 수밖에 없는 것이지요.\nsubscriber는 rospy.Subscriber로 생성하며 최소 3개의 매개변수를 요구합니다. topic 이름 topic message 이름 subscribe 마다 실행되는 callback 메소드 class LaserSubNode: def __init__(self): # Publisher requires 3 paramters # 1. topic name # 2. topic msg type # 3. sub callback method self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) 이 callback 메소드에서 주의해야 할 점은, 항상 callback method의 매개변수가 subscribe된 데이터라는 점입니다. 지금의 경우 LaserScan 타입의 데이터일 것입니다. # first param of callback method is always topic msg def laser_cb(self, data): rospy.loginfo( len(data.ranges)) ... 마지막으로, 깔끔한 터미널 출력을 위해 print 함수를 사용하였습니다. print(f\u0026#34;\u0026#34;\u0026#34; data.ranges[0]: {data.ranges[0]} data.ranges[90]: {data.ranges[90]} data.ranges[179]: {data.ranges[179]} data.ranges[270]: {data.ranges[270]} data.ranges[360]: {data.ranges[360]} \u0026#34;\u0026#34;\u0026#34;) Subscriber 실행 시에는 항상 rospy.spin()을 잊지 말도록 합니다. spin 되지 않는다면 특정 쓰레드가 자원을 점유하기 때문에 subscriber의 상태를 갱신할 수 없습니다.\ndef laser_sub_node(): rospy.init_node(\u0026#39;laser_sub_node\u0026#39;, anonymous=True) laser_sub_node = LaserSubNode() rospy.spin() 과제 - 물체 회피하기 pub/sub의 개념을 잘 이해하였는지 알아볼 수 있는 과제를 준비해보았습니다. 정답이 따로 있는 것은 아니기에 부담 없이 해보시고, 저의 답안도 한번 살펴보세요.\n예제 실행 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Ternimal 2 rosrun py_topic_pkg collision_aviod.py Gazebo 예제를 실행하였다면, 로봇의 전방에 장애물을 놓아 진로를 막아봅니다. 여러분께서 구현해야 하는 것은, 라이다 센서를 사용하여 로봇이 회피 주행을 하도록 만드는 것입니다. 일종의 템플렛 코드를 첨부하였으며, my_collision_aviod.py라는 이름의 코드입니다.\n해당 코드의 TODO 부분을 작성하여 여러분만의 회피 알고리즘을 만들어 보세요!\n로봇의 라이다 데이터인 LaserScan을 Subscribe하여 Twist Type을 사용하는 scan topic으로 publish를 하게 됩니다. class CollisionAvoidNode: def __init__(self): self.laser_sub_ = rospy.Subscriber(\u0026#34;scan\u0026#34;, LaserScan, self.laser_cb) self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.twist_ = Twist() def laser_cb(self, data): # TODO: Prevent robot from collision # make your own logic to do that return None 제가 작성한 예시를 수정하여 더욱 똑똑한 로봇을 구현하셔도 좋고, 자유롭게 실습해보시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/msg "
},
{
	"uri": "/kr/ros_basic_noetic/lecture6/",
	"title": "Lecture6 - ROS Service, Parameter",
	"tags": [],
	"description": "",
	"content": " 지난 시간 마지막 예시였던 장애물 회피 코드부터 간단하게 리뷰해보고자 합니다.\n제가 작성한 로직은 다음과 같습니다.\n과제를 해보셨다면 아시겠지만, 측정 범위를 벗어나게 되면 data.ranges는 inf 값을 갖게 됩니다. 이를 걸러내는 코드가 아래 부분입니다. for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: 저의 로직은, 정면을 기점으로 왼쪽과 오른쪽 각각 inf가 아닌 데이터의 개수를 카운팅합니다. 전체 데이터가 362개이고 마지막 데이터는 사용하기 않는 값이기 때문에, 180을 기점으로 잡았습니다. left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 이제, 제어 데이터를 만들어줍니다. ROS를 비롯하여 로봇 시스템에서는 대부분 오른손 좌표계를 사용합니다. 따라서 위에서 보았을 rospy.loginfo(hello_du)때 오른손이 감기는 반시계 방향이 + 부호를 갖게 됩니다. 이를 고려하여 각속도를 정했습니다. 180은 magic number, 일종의 변환 상수입니다. image from : 오로카\ndef laser_cb(self, data): left_side_count = 0 right_side_count = 0 for i, point in enumerate(data.ranges): if not math.isinf(point) and point \u0026lt; 1.0: if i \u0026gt; 180: left_side_count += 1 else: right_side_count += 1 self.twist_.linear.x = 0.3 self.twist_.angular.z = (right_side_count - left_side_count) / 100 self.cmd_vel_pub_.publish(self.twist_) 지난 강의에서 이야기한 것과 같이 이 문제의 정답은 없습니다.\n다만, Topic의 Pub / Sub을 모두 사용할 수 있는지 스스로 점검해볼 수 있을 것입니다.\nROS Parameter 앞선 저의 예시에서 마지막 속도로 변환하는 부분 수식에 나누기 100이 있었던 것을 기억하시나요? 이런 상수를 직접 코드에 적는 것은 사실 추천되지 않습니다. 개발 이후 해당 상수를 변경하고자 하였을 시, 직접 코드를 수정하고 다시 실행해야 하기 때문에 불편을 야기합니다.\n이러한 문제의 해결 방법으로 ROS의 매개변수, parameter를 다루는 방법을 알아보겠습니다.\npy_param_pkg/scripts/various_params.py #!/usr/bin/env python3 import rospy class ParamNode: def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) rospy.loginfo(f\u0026#34;\u0026#34;\u0026#34; self.str_param_ = {self.str_param_} self.int_param_ = {self.int_param_} self.double_param_ = {self.double_param_} self.bool_param_ = {self.bool_param_} self.list_of_float_param_ = {self.list_of_float_param_} \u0026#34;\u0026#34;\u0026#34;) def param_node(): rospy.init_node(\u0026#39;param_node\u0026#39;, anonymous=True) param_node = ParamNode() rospy.spin() if __name__ == \u0026#39;__main__\u0026#39;: try: param_node() except rospy.ROSInterruptException: pa 실행 결과는 다음과 같습니다. $ rosrun py_param_pkg various_params.py [INFO] [1672014267.630578]: self.str_param_ = hello_world self.int_param_ = 2023 self.double_param_ = 3.14 self.bool_param_ = True self.list_of_float_param_ = [1.0, 2.0, 3.0, 4.0] 매개변수를 선언하고 기본값을 지정하는 방법은 **rospy.get_param()**을 사용하는 것입니다. 두번째 기본값을 잘 보면 어떤 타입을 사용하는지 알 수 있습니다. def __init__(self): self.str_param_ = rospy.get_param(\u0026#39;~str_param\u0026#39;, \u0026#39;hello_world\u0026#39;) self.int_param_ = rospy.get_param(\u0026#39;~int_param\u0026#39;, 2023) self.double_param_ = rospy.get_param(\u0026#39;~double_param\u0026#39;, 3.14) self.bool_param_ = rospy.get_param(\u0026#39;~bool_param\u0026#39;, True) self.list_of_float_param_ = rospy.get_param(\u0026#39;~list_of_float_param\u0026#39;, [1., 2., 3., 4.]) parameter 앞에 붙는 물결 표시 (~)는 private parameter를 의미합니다. 이에 대해 궁금하다면 아래의 추가 자료를 학습해보세요. global_name = rospy.get_param(\u0026#34;/global_name\u0026#34;) relative_name = rospy.get_param(\u0026#34;relative_name\u0026#34;) private_param = rospy.get_param(\u0026#39;~private_name\u0026#39;) default_param = rospy.get_param(\u0026#39;default_param\u0026#39;, \u0026#39;default_value\u0026#39;) 추가 자료 : wiki.ros\n매개변수를 변경하는 가장 보변적인 방법은 launch file을 사용하는 것입니다. launch file의 param 태그를 사용하여 Node에 원하는 parameter를 전달할 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; ROS 프로그래밍을 하다 보면 매개변수가 아주 많이 필요한 경우가 있습니다. 이럴 때마다 launch file에 param 태그 라인을 추가하는 것은 매우 귀찮은 일입니다.\nyaml이라는 형식의 파일로 매개변수를 한번에 관리할 수 있습니다.\npy_param_pkg/param/config.yaml str_param: \u0026#34;yaml string\u0026#34; int_param: 9 double_param: 2.71828 bool_param: \u0026#34;false\u0026#34; list_of_float_param: [3., 2., 1.] py_param_pkg/launch/param_with_yaml.launch \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;various_param_node\u0026#34; pkg=\u0026#34;py_param_pkg\u0026#34; type=\u0026#34;various_params.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;rosparam command=\u0026#34;load\u0026#34; file=\u0026#34;$(find py_param_pkg)/param/config.yaml\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;str_param\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;roslaunch changed me\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; launch file에 rosparam 태그를 추가하고, load command를 사용하며 사용하는 yaml 파일의 위치를 file 옵션을 통해 전달합니다.\nROS parameter Commands rostopic, rosnode와 같이 parameter 또한 터미널 명령어를 갖고 있습니다.\n접근 가능한 모든 parameter들을 나열합니다. rosparam list 특정 paramter의 값을 얻고자하면 아래 키워드를 사용합니다. rosparam get \u0026lt;parameter_name\u0026gt; 선언되어 있는 parameter의 값을 변경하고 싶은 경우 아래 키워드를 사용합니다. rosparam set \u0026lt;parameter_name\u0026gt; \u0026lt;value\u0026gt; 여러분들이 작성한 회피 프로그램에도 매개변수로 작용하는 상수들이 있을 것입니다. 이를 parameter로 변경하여 launch file과 yaml file로 업데이트하는 작업을 해보세요\nROS Service Topic에 이어 ROS의 통신 메커니즘 두번째로 Service를 배워보겠습니다.\nService가 동작하는 방식은 아래와 같습니다.\n그림과 같이 Client Node가 Server Node로 request를 주면, 해당 request에 대응하는 적절한 response가 다시 Client에게로 전달됩니다. 이 과정을 Service Call이라고 부릅니다.\nimage from : docs.ros.org\n하나의 Service Server에는 여러 Client Node가 request 할 수 있지만, Server는 동시에 여러 request를 처리하지는 못합니다. 두 Node에서 동시에 request가 왔다면, 조금이라도 먼저 통신한 Node의 작업을 우선 진행하고, 그동안 다른 Node는 기다리고 있어야 합니다. image from : https://docs.ros.org/en/foxy/Tutorials/Services/Understanding-ROS2-Services.html\nTopic과 비교하여 Service의 특징을 알아봅시다.\n1:1 통신 : Topic publish를 하면 여러 Node가 Subscribe 가능합니다. 반면, Service는 request가 온 대상에게만 response를 줍니다. 순차적 통신 : Service Server는 동시에 여러 request를 처리할 수 없습니다. 현재 작업중인 request가 처리될 때 까지 다른 request는 기다리고 있어야 합니다. 단발성 : Topic은 대부분 지속적으로 publish를 진행하는 반면, Service는 1회성 통신입니다. 실제 로봇 프로그램에서 Service는 어떻게 사용될 수 있을지, 예시를 통해 살펴봅시다.\n예제 패키지 빌드 cd ~/catkin_ws catkin build py_service_pkg source devel/setup.bash Service Client 예제 실행 - 아르키메데스 나선 # Terminal 1 roslaunch py_service_pkg empty_gazebo.launch # Terminal 2 rosrun py_service_pkg spawn_model_client.py 방금 실행한 예시는 Gazebo에게 box를 등장시켜달라고 하는 Service Client를 포함하고 있습니다.\nBox가 등장하는 위치를 아래 사진과 같은 수식에 맞추어 설정한 것 뿐입니다.\n그럼, 코드를 분석해 볼까요?\n필요한 파이썬 패키지들을 import 합니다. import math import rospy import rospkg from geometry_msgs.msg import Pose from gazebo_msgs.srv import SpawnModel 여기서 중요한 점은 msg와 srv 부분입니다. topic에서 사용되는 데이터 타입이 Message였고, 프로그래밍 시에는 msg로 사용하였습니다.\nService에서는 msg가 아니라 srv라는 데이터 타입을 사용합니다. image from : rsl.eth\n이 srv는 msg와 다른 점이 있는데, request와 response로 나뉘어 있다는 점입니다. \u0026mdash; 표시를 기점으로 위쪽은 Server에게 전달하는 request, 아래쪽은 Server가 다시 회답하는 response 부분입니다. 이번 예시에서 사용한 gazebo_msgs/SpawnModel도 아래와 같은 구조를 갖습니다. image from : docs.ros.org\ngazebo_msgs/SpawnModel를 살펴보면 파란 글자로 geometry_msgs/Pose라는 부분이 있습니다. 이와 같이 srv는 다른 msg를 품을 수도 있고, 이렇게 만든 srv를 또다시 다른 srv에 포함시킬 수도 있습니다.\n코드 구현 관점에서, geometry_msgs/Pose는 Model을 등장시킬 초기 위치를 지정하는데 사용됩니다.\n# initial_pose initial_pose = Pose() initial_pose.position.x = 0.0 initial_pose.position.y = -1 initial_pose.position.z = 0.2 # z rotation -pi/2 to Quaternion initial_pose.orientation.z = -0.707 initial_pose.orientation.w = 0.707 Service Client의 생성과 사용은 아래와 같습니다. spawn_model_prox = rospy.ServiceProxy(\u0026#34;gazebo/spawn_urdf_model\u0026#34;, SpawnModel) ... result = spawn_model_prox( entity_name, model_xml, robot_namespace, initial_pose, reference_frame ) rospy.ServiceProxy()는 2개의 매개변수를 필요로 합니다.\nservice 이름 service 데이터 타입 (srv) 생성한 client로 request를 하기 위해서는 생성한 인스턴스에 매개변수를 전달하기만 하면 됩니다. 마치 함수 호출처럼 말이지요. 이는 ServiceProxy 내부적으로 call 메소드가 구현되어있기 때문입니다.\nservice call의 결과로 result가 반환되며, 예시에서는 성공 여부를 반환하도록 되어 있습니다.\n추가적으로, model을 불러오는 부분을 간단하게 설명하고자 합니다. # model_xml rospack = rospkg.RosPack() model_path = rospack.get_path(\u0026#34;py_service_pkg\u0026#34;) + \u0026#34;/urdf/\u0026#34; with open(model_path + model_name + \u0026#34;.urdf\u0026#34;, \u0026#34;r\u0026#34;) as xml_file: model_xml = xml_file.read().replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) Gazebo는 urdf라는 파일을 전달하면 해당 파일을 기반으로 시뮬레이션에 물체를 등장시켜줍니다. 이 urdf라는 것은 로봇을 표현하기 위한 일종의 약속된 파일 확장명입니다.\nimage from : spart\n세상 모든 로봇들은 joint와 link로 표현 가능합니다. 이러한 개념을 바탕으로 로봇의 특성을 텍스트 파일로 표현하는 형식이 바로 urdf이며, 아래와 같이 여러 태그와 속성을 사용하여 작성 가능합니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;robot name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;link name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;inertial\u0026gt; \u0026lt;mass value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!-- Inertia values were calculated to be consistent with the mass and geometry size, assuming a uniform density. --\u0026gt; \u0026lt;inertia ixx=\u0026#34;0.0108\u0026#34; ixy=\u0026#34;0\u0026#34; ixz=\u0026#34;0\u0026#34; iyy=\u0026#34;0.0083\u0026#34; iyz=\u0026#34;0\u0026#34; izz=\u0026#34;0.0042\u0026#34;/\u0026gt; \u0026lt;/inertial\u0026gt; \u0026lt;visual\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/visual\u0026gt; \u0026lt;collision name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;geometry\u0026gt; \u0026lt;box size=\u0026#34;.1 .2 .3\u0026#34;/\u0026gt; \u0026lt;/geometry\u0026gt; \u0026lt;/collision\u0026gt; \u0026lt;/link\u0026gt; \u0026lt;/robot\u0026gt; ROS Service Commands gazebo/spawn_urdf_model과 같은 service는 gazebo_ros를 사용할 때 자동으로 함께 실행됩니다. 이렇게 현재 어떠한 service가 존재하며, 또 구체적인 정보는 어떻게 조회하는지 알아봅시다.\n현재 사용 가능한 모든 service를 조회해봅시다. $ ros2 service list /delete_entity /gazebo/describe_parameters /gazebo/get_parameter_types /gazebo/get_parameters /gazebo/list_parameters /gazebo/set_parameters ... 리눅스의 grep 명령어를 함께 사용해 보세요.\n특정 service가 어떤 srv 타입을 사용하는지 검색하고 싶다면 다음 커멘드 라인을 사용합니다. $ rosservice type /gazebo/spawn_urdf_model **** 이렇게 검색된 srv는 rossrv show와 결합할 때 더욱 진가를 발휘합니다. $ rossrv show `rosservice type /gazebo/spawn_urdf_model` 특정 srv 타입에 대한 자세한 정보는 다음과 같이 조회할 수 있습니다. $ rosservice info /gazebo/spawn_urdf_model gazebo_ros에서 제공하는 다양한 service들이 있습니다. rosservice 커멘드를 사용하여 조회해보고 여러분들만의 Application을 생각해 보세요.\nService Server 예제 실행 - 긴급 정지 # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch # Terminal 2 rosrun py_service_pkg emergency_stop.py # Terminal 3 rqt 두번째 Node 실행 시, 로봇이 원을 그리며 움직이기 시작합니다. 세번째 명령어를 통해 등장하는 rqt는 아래와 같이 사용 가능합니다. 로봇에게 긴급 정지 명령을 내려보겠습니다. 실제 로봇 개발시에도 Service는 이렇게 단발성이고, 빠르게 실행되어야 하는 동작에 주로 사용됩니다. 더불어, 지금 실행한 예시가 Service Server임을 다시 한 번 상기시켜드립니다.\nimage from : rsl.eth\n코드를 분석해 봅시다.\npy_service_pkg/scripts/emergency_stop.py from geometry_msgs.msg import Twist from std_srvs.srv import SetBool, SetBoolResponse 이번에 사용하는 데이터 타입은 크게 2 종류입니다.\n로봇 제어 topic에 사용되는 Twist 긴급 정지 service에 사용될 SetBool image from : docs.ros.org\nSetBoolResponse이라는 것은 SetBool srv 중 response 부분에 해당합니다. 기본 데이터 타입 이름 + Response를 붙여주기만 하면 사용 가능합니다.\nROS의 msg, srv는 다양한 언어와 상황을 고려하도록 만들어져 있으며, ROS 2에서는 IDL이라는 이름으로 더욱 발전하였습니다. 이후의 커스텀 데이터 타입 제작을 통해 이 과정을 다시 살펴봅시다.\n다음으로 통신 메커니즘을 생성합니다. class EmergencyStopNode(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;emergency_stop\u0026#34;, SetBool, self.stop_cb) 로봇 제어를 위한 topic publisher와 service server를 생성합니다.\nrospy.Service()를 통해 Service Server를 생성할 수 있으며 다음과 같은 매개변수를 필요로합니다.\nService 이름 srv 타입 Client로부터 request가 올 시 실행되는 callback 함수 callback 함수는 일전 subscriber에서 살펴본 바 있습니다. service server의 callback 함수는 항상 매개변수로 request srv를 받습니다. 그리고 return 값은 항상 response가 됩니다.\ndef stop_cb(self, request): ... return self.response_ request 데이터 중 boolean 값을 갖는 data의 true / false 여부에 따라 로봇의 정지 여부가 결정됩니다. if request.data is True: self.twist_msg_.linear.x = 0.0 self.twist_msg_.angular.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) self.response_.success = True self.response_.message = \u0026#34;Successfully Stopped\u0026#34; else: self.response_.success = False self.response_.message = \u0026#34;Stop Failed\u0026#34; 마지막에 사용한 rqt의 service caller는 별도의 프로그래밍이나 복잡한 터미널 명령어 없이도 손쉽게 service를 다룰 수 있게 해주는 ROS의 툴입니다.\n지금까지 ROS Service에 대해 배워보았습니다. Topic과 더불어 많이 사용되는 통신 메커니즘이므로 잘 숙지하고 복습하시기 바랍니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ko.wikipedia.org/wiki/아르키메데스_와선 https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/Services "
},
{
	"uri": "/kr/ros_basic_noetic/lecture7/",
	"title": "Lecture7 - Rqt Tools and rosbag, ROS Time",
	"tags": [],
	"description": "",
	"content": " 강의 초반, 다양한 rqt tool들을 살펴본 바 있습니다. 이제는 Topic과 Service에 모두 익숙해졌기 때문에, rqt의 많은 기능들을 사용할 수 있습니다. 다시 한 번 rqt를 살펴보면서 편리한 툴들의 사용법을 익혀봅시다.\nMessage Publisher \u0026amp; Topic Monitor 강의자를 따라 다음과 같이 화면을 구성합니다.\nplugins ⇒ topics ⇒ Message Publisher pulgins ⇒ topics ⇒ Topic Monitor message publisher를 사용하면 코딩 없이 cmd_vel을 publish가 가능합니다. Topic Msg에 원하는 데이터를 채워넣은 뒤, 주기를 선택한 후 체크박스를 클릭하면 로봇이 움직이기 시작합니다. Topic Monitor를 사용하면, 여러 데이터들을 효과적으로 모니터링 가능합니다. Topic Publisher와 동일하게 체크박스를 눌러 topic을 선택한 뒤, 변하는 데이터를 확인해봅시다. 코딩 없이 간단히 값의 확인과 동작 여부를 확인할 수 있는 툴들이었습니다.\nRQT Multiplot 수치 데이터를 그래프로 보고싶은 경우 rqt의 multiplot이 유용하게 사용됩니다.\nrosrun rqt_multiplot rqt_multiplot /odom topic의 X,Y position을 기준으로 그래프를 그려보도록 하겠습니다. 아래의 gif를 통해 모든 과정을 기록하였으니 차근차근 따라와주세요.\nRQT Console 지금까지 ROS의 콘솔 로그를 위해 rospy.loginfo()를 사용하였습니다. 사실 ROS에는 loginfo말고도 다양한 level의 logger level이 존재합니다. 실습을 통해 살펴봅시다.\nrospy logger level # Terminal 1 roscore # Terminal 2 rosrun my_first_package logger_level.py 코드의 내용과 함께 예시를 살펴봅시다. def hello_du(self, event=None): hello_du = f\u0026#34;hello du {rospy.get_time()}, counter: {self.counter_}\u0026#34; rospy.logdebug(hello_du) rospy.loginfo(hello_du) rospy.logwarn(hello_du) rospy.logerr(hello_du) rospy.logfatal(hello_du) self.counter_ += 1 ROS는 총 5가지의 logger level을 갖추고 있으며, Debug 부터 Fatal로 갈수록 더 높은 level을 갖는다고 보시면 됩니다. Info level 부터 콘솔 출력이 이루어지며, Python의 stdout를 사용합니다.\nimage from : 51CTO 상황에 따라 각기 다른 level의 log를 사용하도록 하면, 실제 로봇 개발시에도 큰 도움이 됩니다.\nrqt에는 이러한 다양한 level을 갖는 ros의 log를 필터링하는 rqt console이라는 툴이 있습니다. 사용 방법을 함께 알아봅시다.\n그 밖에도 수많은 rqt 도구들이 있지만, 모두 살펴보는 대신 링크로 대체하겠습니다. \u0026gt; ROS Wiki\nROS Bags rqt 툴에 속하지는 않지만, 개발 시 매우 유용한 ROS의 기능을 하나 더 소개시켜드리고자 합니다.\nrosbag은 프로그램 동작 중 발생하는 message 데이터를 기록하고 복기할 수 있게 해주는 툴입니다. 로봇 알고리즘을 개발할 때, 같은 상황에 대해 성능을 비교하는 경우, 혹은 교육 목적으로 데이터셋을 제공하는 경우 등에 매우 유용하게 사용할 수 있습니다.\nrosbag 사용법을 함께 실습해보겠습니다.\nsmb gazebo를 실행합니다. roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school rosbag의 사용 시 여러 옵션들이 있습니다. -o 옵션으로 rosbag의 이름을 지정합니다. -a 옵션 사용 시 모든 topic을 저장합니다. rosbag의 종료는 ctrl + c를 사용합니다. rosbag record -o first_rosbag /scan /tf /tf_static /tf와 /tf_static은 왜 저장하는 것일까요? 생각해봅시다.\nrosbag info를 통해 저장을 마친 rosbag의 정보를 조회할 수 있습니다. $ rosbag info first_rosbag_\u0026lt;time-format-sth\u0026gt;.bag path: first_rosbag_2022-12-27-15-51-55.bag version: 2.0 duration: 4.8s start: Jan 01 1970 09:07:35.31 (455.31) end: Jan 01 1970 09:07:40.12 (460.12) size: 83.8 KB messages: 49 compression: none [1/1 chunks] types: sensor_msgs/LaserScan [90c7ef2dc6895d81024acba2ac42f369] topics: /scan 49 msgs : sensor_msgs/LaserScan 저장 완료된 rosbag을 다시 복기해봅시다. $ rosbag play first_rosbag_2022-12-27-15-56-23.bag [ INFO] [1672124296.822088842]: Opening first_rosbag_2022-12-27-15-56-23.bag Waiting 0.2 seconds after advertising topics... done. ... rviz를 통해 시각화까지 해봅시다. rosbag은 기본적으로 topic을 저장합니다.\nrviz 화면을 살펴보면 아래와 같은 Warning이 발생할 것입니다. 그런데 이 문구, 익숙하지 않나요?\n[ WARN] [1672124550.336965013]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336981403]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.336991753]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.337003964]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RH_WHEEL at time 472.056000 according to authority unknown_publisher [ WARN] [1672124550.356035553]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame base_link at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356945321]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LF_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356960231]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame LH_WHEEL at time 472.076000 according to authority unknown_publisher [ WARN] [1672124550.356970561]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame RF_WHEEL at time 472.076000 according to authority unknown_publisher ROS Time 일전 강의에서 언급한 바와 같이, 이번 강의에 ROS의 시간 체계에 대해서 다잡고 가고자 합니다.\nrospy.loginfo를 통해 콘솔에 출력되는 시간과 같이 ROS에서 기본적으로 사용되는 시간의 기준은 PC의 Clock입니다. (이를 wall timer라고 부릅니다.) ROS 프로그램은 일정 주기를 갖고 무한히 반복되는 상황이 잦습니다. 이때 사용하는 주기가 정확해야 할 것입니다. 우리는 2023년 00월 00일이라는 시간체계를 사용하지만, Gazebo와 같은 시뮬레이션 툴은 시작되는 시점이 곧 0분 0초가 됩니다. 이러한 시간의 차이로 인해 warning과 error가 빈번하게 발생합니다. 그럼, 실질적으로 ROS에서 시각과 주기, 시간은 어떻게 다루는지 예시와 함께 python 코드를 살펴봅시다.\nros_time.py $ rosrun my_first_package ros_time.py [INFO] [1672127477.793024]: Current time 1672127477 792964935 [INFO] [1672127477.793593]: Current time to_sec 1672127477 [INFO] [1672127477.794082]: Past time 1672127477 292964935 [INFO] [1672127477.893132]: Current time 1672127477 893082141 [INFO] [1672127477.893684]: Current time to_sec 1672127477 [INFO] [1672127477.894148]: Past time 1672127477 393082141 ... 코드는 다음 위치에서 확인이 가능합니다. \u0026gt; https://github.com/RB2023ROS/du2023-ros1/blob/main/my_first_package/scripts/ros_time.py\nrospy Time instance rospy에서는 Time이라는 클래스로 시간을 표현합니다. 가장 많이 사용되는 현재 시간은 rospy.Time.now() 로 파악할 수 있으며, 이는 sec와 nsec등의 클래스 변수를 갖고 있습니다.\ndef hello_du(self, event=None): now = rospy.Time.now() seconds = now.to_sec() rospy.loginfo(\u0026#34;Current time %i %i\u0026#34;, now.secs, now.nsecs) rospy.loginfo(\u0026#34;Current time to_sec %i\u0026#34;, seconds) rospy Time Duration 시간 간격을 나타내는 클래스로 Duration이 사용되며, Time 인스턴스와 +,- 연산이 가능합니다.\ndelta = rospy.Duration(0.5) past = now - delta rospy.loginfo(\u0026#34;Past time %i %i\u0026#34;, past.secs, past.nsecs) rospy Rate while loop와 Rate를 사용하여 일정 주기다마 반복되는 구현이 가능합니다. 이때 사용되는 시간 기준은 PC의 Clock입니다.\nr = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): time_ex.hello_du() r.sleep() Topic vs Service and Action 지금까지 ROS의 통신 메커니즘으로 Topic과 Service에 대해 배워보았습니다. 그런데, 사실 ROS의 통신 메커니즘에는 Action이라는 한가지가 더 있습니다.\nAction은 Topic과 Service 모두의 특징을 갖고 있는 진보된 통신 메커니즘입니다. Action은 Feedback이라는 것으로 Goal Request 이후 계속적인 데이터 송수신이 가능합니다. Action은 ROS 2 강의에서 살펴볼 예정으로 어떻게 사용될 수 있을지 한번 고민해보세요.\nimage from : docs.rog.org 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://docs.ros.org/en/foxy/index.html "
},
{
	"uri": "/kr/ros_basic_noetic/lecture8/",
	"title": "Lecture8 - Deal with Open Source Projects, Custom Interfaces",
	"tags": [],
	"description": "",
	"content": "Deal with Open Source Projects 이번 시간에는 오픈 소스 프로젝트를 사용하는 방법에 대해 배워보겠습니다. 보다 실질적인 사용 방법을 보여드리기 위해 저 또한 여러분들과 같은 상황에서 처음부터 하나씩 같이 해보겠습니다.\n오늘 데모하고자 하는 로봇 소프트웨어는 드론 시뮬레이션입니다. 지금까지 지상을 움직이는 바퀴 로봇만을 다루었기 때문에 새로운 플렛폼을 동작시켜보고자 합니다.\n항상 시작은 구글링부터!! 검색 결과 원하는 패키지를 찾은 것 같습니다. \u0026gt; https://github.com/RAFALAMAO/hector-quadrotor-noetic 목적에 부합하는 오픈소스를 찾기 위해서 아래와 같은 기본적인 내용을 고려해야 합니다.\n버전 호환성 구체적인 목표에 부합하는지 Star, Fork를 통해 검증된 소스코드임을 확인 Issue를 통해 사용 중 문제가 있지는 않은지 Readme를 따라 package build를 진행하고 최초 실행을 해보겠습니다.\n# Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun hector_ui ui_hector_quad.py 동작에는 문제가 없어보입니다. 그럼 이 프로젝트가 내부적으로 어떻게 구현되어있는지 분석해봅시다.\nrqt_graph 로봇의 위치를 알려주는 topic인 /ground_truth/state와 /ground_truth_to_tf/pose를 파악할 수 있습니다. gazebo에서 물체의 절대적인 위치를 알려주기 때문에 이를 ground truth라고 부르고 있습니다.\n이번에는 조종 프로그램의 소스코드를 확인해봅시다. (hector_quadrotor_noetic/hector_ui/src에 위치하고 있습니다.) #Callback de pose y orientacion simulador def pose_callback(data): x_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.x)) y_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.y)) z_p.set(\u0026#34;{0:.2f}\u0026#34;.format(data.pose.pose.position.z)) def rot_callback(data): z_o.set(\u0026#34;{0:.2f}\u0026#34;.format( math.degrees(quaterionToRads(data)) )) rospy.init_node(\u0026#39;HectorQ_GUI\u0026#39;, anonymous=False) #Subscribers posicionLider_sub = rospy.Subscriber(\u0026#34;/ground_truth/state\u0026#34;, Odometry , pose_callback) orientaLider_sub = rospy.Subscriber(\u0026#34;/ground_truth_to_tf/pose\u0026#34;, PoseStamped , rot_callback) 두 종류의 subscriber가 존재하며 각각 UI의 상태를 업데이트하는 것 같이 보입니다.\n이번에는 launch file을 분석해봅시다 - hector_quadrotor/hector_quadrotor_gazebo/launch/quadrotor_empty_world.launch \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; default=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; default=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;$(arg paused)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;$(arg use_sim_time)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;$(arg gui)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;$(arg headless)\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;$(arg debug)\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; gazebo_ros의 empty_world.launch, hector_quadrotor_gazebo의 spawn_quadrotor.launch가 실행되며, model이라는 argument를 갖습니다.\nspawn_quadrotor.launch에는 다음과 같은 node들이 실행됩니다.\nspawn_model robot_state_publisher ground_truth_to_tf controller.launch ⇒ controller_spawner 이렇게 rqt 툴들과 코드의 구조를 파헤치면서 전체 구조를 파악할 수 있으며 원하는 부분만을 고치면서 Package를 발전시켜나가는 것입니다.\nlaunch file의 응용을 실습해봅시다. 일전 배워본 husky gazebo와 hector gazebo를 함께 사용해보는 것입니다.\nhusky gazebo 는 다음과 같은 내용을 담고 있었습니다. gazebo_ros를 실행시키고 husky model을 spawn하는 또다른 launch file을 include 하였습니다. \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; default=\u0026#34;worlds/empty.world\u0026#34;/\u0026gt; \u0026lt;include file=\u0026#34;$(find gazebo_ros)/launch/empty_world.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;world_name\u0026#34; value=\u0026#34;$(arg world_name)\u0026#34;/\u0026gt; \u0026lt;!-- world_name is wrt GAZEBO_RESOURCE_PATH environment variable --\u0026gt; \u0026lt;arg name=\u0026#34;paused\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;use_sim_time\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;gui\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;headless\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;arg name=\u0026#34;debug\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/spawn_husky.launch\u0026#34;\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/launch\u0026gt; 그럼, 겹치는 부분을 제외하고 quadrotor_empty_world.launch의 내용을 추가하여 새로운 launch file을 만들어 봅시다. (hetero_spawn.launch 생성) \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor_hokuyo_utm30lx.gazebo.xacro\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; 아래와 같은 오류가 발생하네요, 이는 robot_state_publisher node가 중복되기 때문에 발생하는 문제입니다. RLException: roslaunch file contains multiple nodes named [/robot_state_publisher]. Please check all \u0026lt;node\u0026gt; \u0026#39;name\u0026#39; attributes to make sure they are unique. Also check that $(anon id) use different ids. The traceback for the exception was written to the log file 이를 해결하기 위해서, 저는 다른 launch file(spawn_two_quadrotors.launch)을 참고해보았습니다. group 태그를 사용하면 같은 로봇의 중복 선언을 namespace를 통해 구분할 수 있게됩니다. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;launch\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;group ns=\u0026#34;uav2\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; ... \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 이제, hetero_spawn.launch를 최종 수정해봅시다. \u0026lt;launch\u0026gt; \u0026lt;include file=\u0026#34;$(find husky_gazebo)/launch/husky_empty_world.launch\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; default=\u0026#34;$(find hector_quadrotor_description)/urdf/quadrotor.gazebo.xacro\u0026#34; /\u0026gt; \u0026lt;group ns=\u0026#34;uav1\u0026#34;\u0026gt; \u0026lt;include file=\u0026#34;$(find hector_quadrotor_gazebo)/launch/spawn_quadrotor.launch\u0026#34;\u0026gt; \u0026lt;arg name=\u0026#34;name\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;tf_prefix\u0026#34; value=\u0026#34;uav1\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;model\u0026#34; value=\u0026#34;$(arg model)\u0026#34; /\u0026gt; \u0026lt;arg name=\u0026#34;z\u0026#34; value=\u0026#34;1.0\u0026#34; /\u0026gt; \u0026lt;/include\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/launch\u0026gt; 실행 후 topic을 조회해보면, 아래와 같이 quadrotor의 topic 앞에 namespace가 추가되어 있는 모습이 확인 가능합니다. 여러 로봇을 사용하게 되면 /cmd_vel, /scan등 사용하는 topic의 이름이 중복될 수 있어 namespace를 추가 설정하는 것이 일반적입니다.\n$ rostopic list /clock /cmd_vel /husky_velocity_controller/cmd_vel /husky_velocity_controller/odom /husky_velocity_controller/parameter_descriptions /husky_velocity_controller/parameter_updates /imu/data /odometry/filtered ... /uav1/aerodynamics/wrench /uav1/cmd_vel /uav1/command/motor /uav1/command/twist /uav1/command/wrench /uav1/fix_velocity ... 마지막으로, 로봇을 제어해보면서 이번 세션을 마무리해보겠습니다. gazebo의 world를 바꾸거나, husky가 아닌 smb로 모델을 바꾸는 등 응용 예시들을 직접 해보면서 launch file의 사용에 익숙해지시기 바랍니다.\n# husky 제어 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # quadrotor 제어 rosrun hector_ui ui_hector_quad_leader.py ROS Custom Interfaces ROS에서 기본 제공되는 msg와 srv도 훌륭하지만, 상황에 따라 나만의 custom msg/srv를 사용해야 하는 경우가 있습니다. 이번 시간에는 custom interface를 만들어보고, 사용해보겠습니다.\n드론의 이착륙을 제어하는 srv를 만들어보고자 합니다.\n이륙/착륙을 구분하는 string이 필요할 것이며, 기준은 시간을 사용하고자 합니다. ( ex - 2초간 이륙 ) service request는 성공 여부인 bool type으로 해보겠습니다. custom interface를 만들기 위해 저는 별도의 package를 생성하였습니다. cd ~/catkin_ws/src/du2023-ros1 catkin_create_pkg custom_interfaces package 내부에 msg 혹은 srv라는 폴더를 만들고, custom interface를 정의하는것이 추천됩니다. cd custom_interfaces mkdir srv # QuadrotorControl.srv 생성 string command uint8 seconds --- bool success custom_interfaces package의 package.xml을 수정합니다. \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt; custom_interfaces package의 CMakeLists.txt를 수정합니다. # 1. find_package 수정 find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) # 2. catkin_package 주석 해제 후 수정 catkin_package( ... CATKIN_DEPENDS message_runtime ... ...) # 3. add_service_files에 파일 반영 add_service_files( FILES QuadrotorControl.srv ) # 4. generate_messages 주석 해제 후 수정 generate_messages( DEPENDENCIES std_msgs # Or other packages containing msgs ) custom interface를 빌드하고 생성을 확인해봅시다. $ catkin build custom_interfaces $ rossrv show custom_interfaces/QuadrotorControl string command uint8 seconds --- bool success 지금 생성한 QuadrotorControl은 catkin_ws에서만 사용 가능한 srv라는 점에 유의합니다. 다른 workspace에서는 QuadrotorControl에 대해 알 길이 없습니다.\nCustom Interfaces 사용해보기 작성한 QuadrotorControl를 사용하여 Service Server를 만들어봅시다! 정해진 시간동안 takeoff와 land 움직임을 수행하는 Service입니다. # Terminal 1 roslaunch hector_quadrotor_gazebo quadrotor_empty_world.launch # Terminal 2 rosrun py_service_pkg quadrotor_custom_srv.py # Terminal 3 rqt 소스 코드는 이 링크에서 확인이 가능합니다.\ncustom_interfaces package에서 QuadrotorControl srv를 import 하며, 로봇의 제어를 위해 Twist msg도 import 하였습니다. import rospy from geometry_msgs.msg import Twist from custom_interfaces.srv import QuadrotorControl, QuadrotorControlResponse Service Server와 Topic Publisher를 생성합시다. class QuadRotorUpDown(object): def __init__(self): self.cmd_vel_pub_ = rospy.Publisher(\u0026#34;cmd_vel\u0026#34;, Twist, queue_size=10) self.stop_server_ = rospy.Service(\u0026#34;up_down\u0026#34;, QuadrotorControl, self.up_down_cb) self.twist_msg_ = Twist() self.response_ = QuadrotorControlResponse() rospy.loginfo(\u0026#34;Quadrotor Up-Down Server Started\u0026#34;) callback 함수인 up_down_cb입니다. command가 land/takeoff일 때의 경우를 나누고, 그 이외의 입력은 오류로 판명합니다. def up_down_cb(self, request): if request.command == \u0026#34;land\u0026#34;: self.twist_msg_.linear.z = -0.5 self.response_.success = True elif request.command == \u0026#34;takeoff\u0026#34;: self.twist_msg_.linear.z = 0.5 self.response_.success = True else: rospy.logwarn(\u0026#34;Unknown Command\u0026#34;) self.response_.success = False return self.response_ request의 seconds 시간동안 로봇이 움직여야 할 것이며, 이를 위해 now를 갱신하며 지나간 시간을 계속해서 tracking 합니다. start = rospy.Time.now() now = rospy.Time.now() while (now - start).secs \u0026lt; request.seconds: now = rospy.Time.now() self.cmd_vel_pub_.publish(self.twist_msg_) 모든 동작이 완료된 이후에는 로봇을 다시 정지시킵니다. rospy.loginfo(f\u0026#34;{request.command} done, quadrotor stop\u0026#34;) self.twist_msg_.linear.z = 0.0 self.cmd_vel_pub_.publish(self.twist_msg_) return self.response_ 참고자료\nhttp://wiki.ros.org/rospy/Overview/Time https://github.com/RAFALAMAO/hector-quadrotor-noetic https://docs.ros.org/en/foxy/index.html http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv "
},
{
	"uri": "/kr/ros_basic_noetic/lecture9/",
	"title": "Lecture9 - ROS TF and Examples",
	"tags": [],
	"description": "",
	"content": " 대부분의 로보틱스 과정들에서 가장 먼저 다루는 것이 바로 좌표계 변환(Transformation) 입니다. 로봇은 수많은 joint와 link로 이루어져 있기 때문에 좌표계를 다루는 일이 매우 빈번합니다.\nROS에서는 TF라는 특수한 형태로 이 좌표계와 시간을 함께 다루고 있습니다. 예시와 설명을 통해 ROS의 TF에 대해 배워봅시다 😊\nimage from : eth robot dynamics lecture notes ROS는 오픈소스이니만큼 사용자들이 원하는 기능들에 맞추어 변화가 빠릅니다. 하지만 이것이 단점이 되는 경우도 있는데, 이전 버전과 최신 버전의 호환성 문제가 종종 발생합니다.\ntf 또한 tf2로 개편되면서 코드의 수정이 있었으며, 이번 강의에서는 tf2를 중심으로 살펴보겠습니다.\nimage from : wiki.ros 예시를 먼저 살펴봅시다.\ntf broadcaster # Terminal 1 rosrun turtlesim turtlesim_node # Terminal 2 rosrun py_tf2_tutorial turtle_tf2_broadcaster.py # Terminal 3 rosrun turtlesim turtle_teleop_key # Terminal 4 rviz rviz를 실행한 뒤 아래와 같이 설정합니다. rviz에서 보이는 세가지 색상의 막대가 바로 tf 입니다.\nx,y,z의 각 축을 각기 다른 색으로 표현하였으며, 연관된 좌표계끼리는 노란 선을 통해 연결한 모습이 보입니다.\nTerminal 1에서 실행시킨 프로그램은 turtlesim이라는 것으로, 2차원 평면에서 거북이 형태의 로봇을 시뮬레이션한 프로그램입니다. 이제, Terminal 3에 커서를 두고 거북이를 움직이면서, rviz와 turtlesim의 변화를 살펴보세요. 거북이를 조종함에 따라 변화하는 rviz 화면을 확인할 수 있습니다.\n전체 코드는 아래 링크에서 확인할 수 있으며, 지금은 필요한 부분만 집중적으로 분석해보겠습니다.\nhttps://github.com/RB2023ROS/du2023-ros1/blob/main/py_tf2_tutorial/scripts/turtle_tf2_broadcaster.py\ntf 또한 하나의 Package입니다. 이에 따라 관련된 python import가 필요합니다. import rospy # Because of transformations import tf_conversions import tf2_ros import geometry_msgs.msg import turtlesim.msg tf의 데이터 송출은 broadcast라고 부릅니다. topic의 publisher와 같이 tf에서는 TransformBroadcaster를 사용하며 sendTransform이라는 메소드를 사용합니다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() ... br.sendTransform(t) TransformBroadcaster가 사용하는 데이터 타입은 geometry_msgs.msg.TransformStamped입니다. 해당 데이터 타입에는 3차원 좌표계에서의 위치, 방향, 그리고 시간이 포함되어 있습니다. image from : docs.ros.org\n해당 데이터 타입에 적절한 값을 채워넣어준 다음, 최종 broadcast가 진행됩니다. 주의할 점으로 쿼터니언 각도 체계를 사용했다는 점입니다. # prepare tf msg t = geometry_msgs.msg.TransformStamped() t.header.stamp = rospy.Time.now() t.header.frame_id = \u0026#34;world\u0026#34; t.child_frame_id = turtlename t.transform.translation.x = msg.x t.transform.translation.y = msg.y t.transform.translation.z = 0.0 q = tf_conversions.transformations.quaternion_from_euler(0, 0, msg.theta) t.transform.rotation.x = q[0] t.transform.rotation.y = q[1] t.transform.rotation.z = q[2] t.transform.rotation.w = q[3] 쿼터니언은 직관적으로 이해하기는 힘든 각도 체계입니다. 계산의 편의를 위해 다음과 같은 사이트를 사용할 수 있습니다. \u0026gt; 3D Rotation Converter\ntf의 사용 시 주의해야 할 점을 언급하고자 합니다.\nturtle_tf2_broadcaster.py 수정 - Experiment라고 되어 있는 부분을 주석 해제한 다음 다시 실행해봅시다. def handle_turtle_pose(msg, turtlename): # tf requires broadbaster # Be Careful, !!TF IS NOT A TOPIC!! br = tf2_ros.TransformBroadcaster() # prepare tf msg t = geometry_msgs.msg.TransformStamped() # t.header.stamp = rospy.Time.now() # Experiment, Late tf2 t.header.stamp = rospy.Time.now() - rospy.Duration(60) t.header.frame_id = \u0026#34;world\u0026#34; rviz를 실행시킨 터미널에서 아래와 같은 에러가 발생합니다. [ WARN] [1671940248.738235698]: TF_REPEATED_DATA ignoring data with redundant timestamp for frame turtle1 at time 1671940148.738096 according to authority unknown_publisher tf에는 시간 데이터가 포함되어 있습니다. 따라서 현재 시간과 tf에 담기 시간의 차이가 크다면 ROS는 이를 안정적이지 못한 것으로 판단해 무시합니다. (위 에러는 아마 로봇 개발을 하면서 마주치게 되는 Warning Top3안에 들지 않을까 싶습니다.)\n이번 예시에는 터미널이 4개나 필요하였습니다. 예시의 빠른 실행을 위해 launch file을 만들 수 있습니다. \u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;rviz\u0026#34; pkg=\u0026#34;rviz\u0026#34; type=\u0026#34;rviz\u0026#34; args=\u0026#34;-d $(find py_tf2_tutorial)/rviz/turtlesim_tf.rviz\u0026#34; /\u0026gt; \u0026lt;/launch\u0026gt; tf listener tf broadcaster의 다음으로 tf listener에 대해 배워봅시다.\nturtlesim follow demo roslaunch py_tf2_tutorial follow_demo.launch 사진과 같이 우리가 조종하는 첫번째 거북이를 두번째 거북이가 따라오게 됩니다. rviz를 통해 tf들 사이에 어떠한 변화가 있는지도 직접 확인해보세요 launch 파일은 다음과 같은 내용을 포함하고 있습니다.\n\u0026lt;launch\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtlesim_node\u0026#34; name=\u0026#34;sim\u0026#34;/\u0026gt; \u0026lt;node pkg=\u0026#34;turtlesim\u0026#34; type=\u0026#34;turtle_teleop_key\u0026#34; name=\u0026#34;teleop\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;turtle1_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle1\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node name=\u0026#34;turtle2_tf2_broadcaster\u0026#34; pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_broadcaster.py\u0026#34; respawn=\u0026#34;false\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;turtle\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;turtle2\u0026#34; /\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;node pkg=\u0026#34;py_tf2_tutorial\u0026#34; type=\u0026#34;turtle_tf2_listener.py\u0026#34; name=\u0026#34;listener\u0026#34; output=\u0026#34;screen\u0026#34;/\u0026gt; \u0026lt;/launch\u0026gt; turtlesim 실행 teleop key 실행 turtle1의 tf broadcaster turtle2의 tf broadcaster tf listener 이번 예제에서 살펴보고자 하는 것은 tf listener입니다.\nTransformListener 클래스는 생성되는 순간부터 /tf topic에 귀기울이기 시작합니다. Buffer는 정해진 사이즈만큼 tf 데이터를 품게 되며, TransformListener에 전달하게 되면, tf topic data를 받아 Buffer에 쌓아두는 것입니다. if __name__ == \u0026#39;__main__\u0026#39;: rospy.init_node(\u0026#39;tf2_turtle_listener\u0026#39;) tfBuffer = tf2_ros.Buffer() listener = tf2_ros.TransformListener(tfBuffer) Buffer의 lookup_transform 메소드는 두 frame 사이의 translation, rotation 변환을 계산해줍니다. while not rospy.is_shutdown(): try: # calculate transformation btw two dynamic tfs # those tfs were broadcasted from TransformBroadcaster trans = tfBuffer.lookup_transform(turtle_name, \u0026#39;turtle1\u0026#39;, rospy.Time(), rospy.Duration(1.0)) except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException): rate.sleep() continue lookup_transform 메소드의 원형은 다음과 같습니다. image from : docs.ros2.org lookup_transform의 계산 결과를 직접 살펴보고자 print 문을 추가하였으며, 캡쳐 사진을 통해 간단히 함께 살펴봅시다.\ntranslation은 두 거북이의 frame사이 수평 거리를 보여주며 rotation은 두 frame사이 회전을 쿼터니언으로 보여줍니다. 기준이 되는 frame과 목표 frame은 id로 구분하며, 현재 turtle1, turtle2로 구분하고 있습니다. 현 상황을 그림으로 간단히 정리하자면 다음과 같습니다.\nlookup_transform의 계산 결과는 target frame인 turtle2의 위치가 source frame인 turtle1 기준에서는 어떠한 좌표를 갖는지를 포함합니다.\nimage from : CMU Qatar 로보틱스에서 이러한 좌표 변환은 매우 자주 사용되며, 일반적으로 Homogeneous Matrix의 형태로 표현합니다.\nfrom : eth robotics lecture notes 그 밖에, 코드에서 구현된 기능을 간단히 살펴보며 마무리하겠습니다.\n두번째 거북이를 등장시키는 service client # Spawn second turtle rospy.wait_for_service(\u0026#39;spawn\u0026#39;) spawner = rospy.ServiceProxy(\u0026#39;spawn\u0026#39;, turtlesim.srv.Spawn) turtle_name = rospy.get_param(\u0026#39;turtle\u0026#39;, \u0026#39;turtle2\u0026#39;) spawner(4, 2, 0, turtle_name) 거북이를 제어하기 위한 Twist msg topic publisher # turtle2 controller turtle_vel = rospy.Publisher(\u0026#39;%s/cmd_vel\u0026#39; % turtle_name, geometry_msgs.msg.Twist, queue_size=1) rate = rospy.Rate(50.0) while not rospy.is_shutdown(): ... turtle_vel.publish(msg) rate.sleep() 이렇게 tf에 대해서 turtlesim 예시와 함께 살펴보았습니다. 로보틱스에서 자주 사용되는 좌표계와 그들 사이의 변환을 시간 데이터와 함께 표현하는 것이 ROS의 tf2입니다.\n다음 강의에 계속 이어집니다.\n"
},
{
	"uri": "/kr/ros_basic_noetic/lecture10/",
	"title": "Lecture10 - TF2 Examples, Outro",
	"tags": [],
	"description": "",
	"content": "tf2 사례 제가 강조해서 자꾸 좌표계가 tf가 중요하다고 말하고 있는데, 그 이유를 예시와 함께 좀 더 자세히 살펴보고자 합니다.\nhusky slam # 예시 종속성 설치 sudo apt install ros-noetic-slam-gmapping # Terminal 1 roslaunch smb_gazebo smb_gazebo.launch world:=big_map_summer_school # Terminal 2 roslaunch py_tf2_tutorial slam_gmapping.launch # Terminal 3 rosrun teleop_twist_keyboard teleop_twist_keyboard.py # [option] rviz (이전 예시에서 rviz를 추가하였다면 넘어가셔도 좋습니다.) rviz rviz를 다음과 같이 세팅합니다. 이제 teleop을 통해 로봇을 이동시키면서, rviz 화면의 변화를 확인해봅시다. 로봇이 움직이면서 자신의 위치를 파악함과 동시에 지도를 생성하는 예시입니다.\n마지막으로, rqt를 실행하여 tf tree를 실행시킵니다. tf tree는 tf 관련 상태를 시각화하여 한번에 볼 수 있게 해주는 고마운 툴입니다. tree를 확대해서 살펴보자면, slam_gmapping은 map → odom으로의 tf broadcast를 담당하고 있습니다. 더불어 map은 모든 tf의 최상단에 존재하고 있습니다. 이러한 이유로 rviz에서 fixed frame을 map으로 설정한 것입니다. 퀴즈: 만약 tf tree가 온전히 연결되어 있지 않다면 어떤 일이 발생할까요?\nimage from : answers.ros.org 센서 입장에서도 tf는 매우 중요합니다.\n같은 데이터라도 그 기준이 어딘지에 따라서 전혀 다른 의미를 가질 수 있기 때문입니다.\n예를 들어, 라이다의 tf를 180도 반대로 설정해버리면 후방에 있는 장애물을 전방 장애물로 잘못 인식할 수 있습니다.\nimage from : answers.ros.org 더불어, 로봇 팔과 같은 관절로봇에게도 tf는 무척 중요한 의미를 갖습니다. 각 joint의 상태를 통해 tf를 계산하고 이를 통해 최종적으로 로봇 팔의 끝점이 어디에 위치하는지 계산할 수 있습니다.\nMoveIt! 실습해보기 이번 시간에는 조금 쉬어가는 느낌으로 유용한 ROS Package를 소개해드리고자 합니다.\nimage from : moveit github MoveIt은 다관절 로봇의 모션 제어를 위한 프레임워크입니다. 이름만 들어서는 감이 잘 오지 않지요? 간단한 예시를 통해 살펴봅시다.\n우리 인간은 팔을 이용하여 물건을 잡는 것이 매우 쉽고 간단하지만, 사실 이는 기구학적으로, 동역학적으로, 에너지 차원에서 매우 최적화된 움직임입니다. 로봇 팔의 경우 장착된 모터의 방향각이 제한된 경우도 있고, 자기 자신과 얽혀버리는 문제도 발생할 수 있으며, 같은 목표를 갖더라고 다양한 경로로 움직일 수 있기 때문에 최적의 경로에 대한 기준도 고려해야 합니다. image from : mecademic 로봇 팔의 주요 구성 Base : 고정된 지지부 Arm : 실질적인 로봇 팔 End Effector : Arm 끝에 부착되는 기구의 통칭, 일반적으로 물체를 잡고 놓는 동작을 수행 MoveIt은 관절 로봇의 기본 구성과 Mass Matrix, 각 모터의 제한과 원하는 움직임을 지정해주면 이에 따라 각 관절의 위치, 속도, 가속도 경로를 최적화(Planning) 해주는 프레임워크이며, 그 밖에도, 물체 인지, 장애물 회피, End Effector에 가해지는 힘까지 고려 가능한 거대한 오픈소스 프로젝트입니다.\nMoveIt Motion Planning Framework\n이번 예제로 저와 함께 MoveIt의 가장 기본적인 데모를 함께 실행해보겠습니다. 예시에 사용되는 로봇은 FRANKA EMIKA의 PANDA라는 로봇입니다. FRANKA EMIKA - PANDA\n아래 커멘드 라인을 함께 따라와주세요.\napt 패키지 설치 sudo apt install ros-noetic-moveit-setup-assistant sudo apt install ros-noetic-moveit sudo apt install ros-noetic-gazebo-ros-control joint-state-publisher sudo apt install ros-noetic-controller-manager sudo apt install ros-noetic-ros-controllers sudo apt install ros-noetic-ros-control sudo apt install ros-noetic-robot-state-publisher 예제 패키지 Clone cd ~/catkin_ws git clone https://github.com/ros-planning/moveit_tutorials.git -b master git clone https://github.com/ros-planning/panda_moveit_config.git -b noetic-devel 관련 종속성 설치 - rosdep 추가 설명 cd ~/catkin_ws/src rosdep install -y --from-paths . --ignore-src --rosdistro noetic 패키지 빌드 cd ~/catkin_ws catkin build source devel/setup.bash 데모 실행 roslaunch panda_moveit_config demo_gazebo.launch 여기까지 잘 따라오셨나요? 그렇다면 강의자의 설명에 따라 RViz Motion Planning Plugin을 사용해봅니다.\n참고자료\nhttps://rsl.ethz.ch/education-students/lectures/ros.html https://ros-planning.github.io/moveit_tutorials/ http://wiki.ros.org/tf/Tutorials "
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]